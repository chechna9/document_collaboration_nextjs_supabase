"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   Promise_withResolvers: () => (/* binding */ Promise_withResolvers),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   SortedList: () => (/* binding */ SortedList),\n/* harmony export */   TextEditorType: () => (/* binding */ TextEditorType),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   autoRetry: () => (/* binding */ autoRetry),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentId: () => (/* binding */ createCommentId),\n/* harmony export */   createInboxNotificationId: () => (/* binding */ createInboxNotificationId),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   createThreadId: () => (/* binding */ createThreadId),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   generateCommentUrl: () => (/* binding */ generateCommentUrl),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   htmlSafe: () => (/* binding */ htmlSafe),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isCommentBodyLink: () => (/* binding */ isCommentBodyLink),\n/* harmony export */   isCommentBodyMention: () => (/* binding */ isCommentBodyMention),\n/* harmony export */   isCommentBodyText: () => (/* binding */ isCommentBodyText),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   resolveUsersInCommentBody: () => (/* binding */ resolveUsersInCommentBody),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toAbsoluteUrl: () => (/* binding */ toAbsoluteUrl),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   urljoin: () => (/* binding */ urljoin),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.11.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function _forceClear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    _forceClear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      const timeoutId = maxTimeout ? setTimeout(() => {\n        const reason = new Error(\"Timed out\");\n        this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n      }, maxTimeout) : void 0;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch, endpoint, body) {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options.size ?? DEFAULT_SIZE;\n    this.delay = options.delay;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.input) === stringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch) {\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    cache.set(cacheKey, state);\n    eventSource2.notify();\n  }\n  function invalidate(inputs) {\n    if (Array.isArray(inputs)) {\n      for (const input of inputs) {\n        cache.delete(getCacheKey(input));\n      }\n    } else {\n      cache.clear();\n    }\n    eventSource2.notify();\n  }\n  async function get(input) {\n    const cacheKey = getCacheKey(input);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(input);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(input) {\n    const cacheKey = getCacheKey(input);\n    return cache.get(cacheKey);\n  }\n  function _cacheKeys() {\n    return [...cache.keys()];\n  }\n  return {\n    ...eventSource2.observable,\n    get,\n    getState,\n    invalidate,\n    _cacheKeys\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let notifyImmediately = true;\n  let dirty = false;\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const oldState = state;\n    const newState = callback(oldState);\n    if (newState !== oldState) {\n      state = newState;\n      dirty = true;\n    }\n    if (notifyImmediately) {\n      notify();\n    }\n  }\n  function notify() {\n    if (!dirty) {\n      return;\n    }\n    dirty = false;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function batch(cb) {\n    if (notifyImmediately === false) {\n      return cb();\n    }\n    notifyImmediately = false;\n    try {\n      cb();\n    } finally {\n      notifyImmediately = true;\n      notify();\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    batch,\n    subscribe\n  };\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/autoRetry.ts\nvar HttpError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nvar DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;\nasync function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values[i - 1] ?? \"\") + str\n  );\n}\n\n// src/http-client.ts\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nvar HttpClient = class {\n  constructor(baseUrl, fetchPolyfill, authCallback) {\n    this._baseUrl = baseUrl;\n    this._fetchPolyfill = fetchPolyfill;\n    this._authCallback = authCallback;\n  }\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:    👈 This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async rawFetch(endpoint, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n    const url2 = urljoin(this._baseUrl, endpoint, params);\n    return await this._fetchPolyfill(url2, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        // Possible header overrides\n        ...options?.headers,\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(await this._authCallback())}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n  }\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:   👈 This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails (🤔)\n   *   6. Throw HttpError if response is an error\n   */\n  async fetch(endpoint, options, params) {\n    const response = await this.rawFetch(endpoint, options, params);\n    if (!response.ok) {\n      let error3;\n      try {\n        const errorBody = await response.json();\n        error3 = new HttpError(errorBody.message, response.status, errorBody);\n      } catch {\n        error3 = new HttpError(response.statusText, response.status);\n      }\n      throw error3;\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  async rawGet(endpoint, params, options) {\n    return await this.rawFetch(endpoint, options, params);\n  }\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  async rawPost(endpoint, body) {\n    return await this.rawFetch(endpoint, {\n      method: \"POST\",\n      body: JSON.stringify(body)\n    });\n  }\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  async rawDelete(endpoint) {\n    return await this.rawFetch(endpoint, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async get(endpoint, params, options) {\n    return await this.fetch(endpoint, options, params);\n  }\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async post(endpoint, body, options, params) {\n    return await this.fetch(\n      endpoint,\n      {\n        ...options,\n        method: \"POST\",\n        body: JSON.stringify(body)\n      },\n      params\n    );\n  }\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async delete(endpoint) {\n    return await this.fetch(endpoint, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async putBlob(endpoint, blob, params, options) {\n    return await this.fetch(\n      endpoint,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: blob\n      },\n      params\n    );\n  }\n};\n\n// src/notifications.ts\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetchPolyfill\n}) {\n  async function getAuthValue() {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    return authValue;\n  }\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill, getAuthValue);\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(url`/v2/c/inbox-notifications`, {\n      cursor: options?.cursor,\n      limit: PAGE_SIZE\n    });\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(options) {\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications/delta`,\n      { since: options.since.toISOString() },\n      { signal: options?.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await httpClient.get(\n      url`/v2/c/inbox-notifications/count`\n    );\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(url`/v2/c/inbox-notifications/read`, {\n      inboxNotificationIds: \"all\"\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await httpClient.post(url`/v2/c/inbox-notifications/read`, {\n      inboxNotificationIds\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(url`/v2/c/inbox-notifications`);\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`\n    );\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(url`/v2/c/threads`, {\n      cursor: options.cursor,\n      query,\n      limit: PAGE_SIZE\n    });\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await httpClient.get(\n      url`/v2/c/threads/delta`,\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  return {\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        const [prevNode] = this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\n      }\n      const prevIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      const [previousNode] = this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    const [prev] = this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, prev)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index, deletedNode) {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isValueWithOperator(value)) {\n      keyValuePairsWithOperator.push([key, value]);\n    } else if (typeof value === \"object\" && !(\"startsWith\" in value)) {\n      indexedKeys.push([key, value]);\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isValueWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(\n    ({ key, operator, value }) => formatFilter(key, operator, formatFilterValue(value))\n  ).join(\" AND \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  return false;\n};\nvar isValueWithOperator = (value) => {\n  if (typeof value === \"object\" && value !== null && \"startsWith\" in value) {\n    return true;\n  }\n  return false;\n};\nvar formatFilter = (key, operator, value) => {\n  return `${key}${operator}${value}`;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${JSON.stringify(nestedKey)}]`;\n  }\n  return key;\n};\nvar formatFilterValue = (value) => {\n  if (typeof value === \"string\") {\n    if (isStringEmpty(value)) {\n      throw new Error(\"Value cannot be empty\");\n    }\n    return JSON.stringify(value);\n  }\n  return value.toString();\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar GET_ATTACHMENT_URLS_BATCH_DELAY = 50;\nvar ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\nvar ATTACHMENT_PART_BATCH_SIZE = 5;\nvar RETRY_ATTEMPTS = 10;\nvar RETRY_DELAYS = [\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3\n];\nfunction splitFileIntoParts(file) {\n  const parts = [];\n  let start = 0;\n  while (start < file.size) {\n    const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n    parts.push({\n      partNumber: parts.length + 1,\n      part: file.slice(start, end)\n    });\n    start = end;\n  }\n  return parts;\n}\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Y.js\n    provider: void 0,\n    onProviderUpdate: makeEventSource(),\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  const fetchPolyfill = config.polyfills?.fetch || /* istanbul ignore next */\n  globalThis.fetch?.bind(globalThis);\n  const httpClient1 = new HttpClient(\n    config.baseUrl,\n    fetchPolyfill,\n    () => Promise.resolve(managedSocket.authValue ?? raise(\"Not authorized\"))\n  );\n  const httpClient2 = new HttpClient(\n    config.baseUrl,\n    fetchPolyfill,\n    () => (\n      // TODO: Use the right scope\n      delegates.authenticate()\n    )\n  );\n  async function createTextMention(userId, mentionId) {\n    await httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/text-mentions`, {\n      userId,\n      mentionId\n    });\n  }\n  async function deleteTextMention(mentionId) {\n    await httpClient1.rawDelete(\n      url`/v2/c/rooms/${config.roomId}/text-mentions/${mentionId}`\n    );\n  }\n  async function reportTextEditor(type, rootKey) {\n    await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/text-metadata`, {\n      type,\n      rootKey\n    });\n  }\n  async function listTextVersions() {\n    const result = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/versions`);\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function listTextVersionsSince(options2) {\n    const result = await httpClient2.get(\n      url`/v2/c/rooms/${config.roomId}/versions/delta`,\n      { since: options2.since.toISOString() },\n      { signal: options2.signal }\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function getTextVersion(versionId) {\n    return httpClient2.rawGet(\n      url`/v2/c/rooms/${config.roomId}/y-version/${versionId}`\n    );\n  }\n  async function createTextVersion() {\n    await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/version`);\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/send-message`, {\n          nonce,\n          messages\n        }).then((resp) => {\n          if (!resp.ok && resp.status === 403) {\n            managedSocket.reconnect();\n          }\n        });\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = self.current?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storageBatch.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (true) {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 407 /* THREAD_DELETED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 408 /* THREAD_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) return;\n    const result = await httpClient1.rawGet(\n      url`/v2/c/rooms/${config.roomId}/storage`\n    );\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  function isPresenceReady() {\n    return self.current !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  async function getThreadsSince(options2) {\n    const result = await httpClient2.get(\n      url`/v2/c/rooms/${config.roomId}/threads/delta`,\n      { since: options2?.since?.toISOString() },\n      { signal: options2.signal }\n    );\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function getThreads(options2) {\n    let query;\n    if (options2?.query) {\n      query = objectToQuery(options2.query);\n    }\n    const PAGE_SIZE = 50;\n    try {\n      const result = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/threads`, {\n        cursor: options2?.cursor,\n        query,\n        limit: PAGE_SIZE\n      });\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt)\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        return {\n          threads: [],\n          inboxNotifications: [],\n          nextCursor: null,\n          requestedAt: /* @__PURE__ */ new Date()\n        };\n      }\n      throw err;\n    }\n  }\n  async function getThread(threadId) {\n    const response = await httpClient2.rawGet(\n      url`/v2/c/rooms/${config.roomId}/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0\n      };\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId = createCommentId(),\n    threadId = createThreadId(),\n    attachmentIds\n  }) {\n    const thread = await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads`,\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body,\n          attachmentIds\n        },\n        metadata\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(threadId) {\n    await httpClient2.delete(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}`\n    );\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/metadata`,\n      metadata\n    );\n  }\n  async function markThreadAsResolved(threadId) {\n    await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-resolved`\n    );\n  }\n  async function markThreadAsUnresolved(threadId) {\n    await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-unresolved`\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId = createCommentId(),\n    body,\n    attachmentIds\n  }) {\n    const comment = await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments`,\n      {\n        id: commentId,\n        body,\n        attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body,\n    attachmentIds\n  }) {\n    const comment = await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`,\n      {\n        body,\n        attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    await httpClient2.delete(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`\n    );\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions`,\n      { emoji }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await httpClient2.delete(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions/${emoji}`\n    );\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    const abortSignal = options2.signal;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        () => httpClient2.putBlob(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          attachment.file,\n          { fileSize: attachment.size },\n          { signal: abortSignal }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        () => httpClient2.post(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          void 0,\n          { signal: abortSignal },\n          { fileSize: attachment.size }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const batches = chunk(parts, ATTACHMENT_PART_BATCH_SIZE);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                () => httpClient2.putBlob(\n                  url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  part,\n                  void 0,\n                  { signal: abortSignal }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return httpClient2.post(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error3) {\n        if (uploadId && error3?.name && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await httpClient2.rawDelete(\n              url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}`\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  async function getAttachmentUrls(attachmentIds) {\n    const { urls } = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/attachments/presigned-urls`, {\n      attachmentIds\n    });\n    return urls;\n  }\n  const batchedGetAttachmentUrls = new Batch(\n    async (batchedAttachmentIds) => {\n      const attachmentIds = batchedAttachmentIds.flat();\n      const attachmentUrls = await getAttachmentUrls(attachmentIds);\n      return attachmentUrls.map(\n        (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n      );\n    },\n    { delay: GET_ATTACHMENT_URLS_BATCH_DELAY }\n  );\n  const attachmentUrlsStore = createBatchStore(batchedGetAttachmentUrls);\n  function getAttachmentUrl(attachmentId) {\n    return batchedGetAttachmentUrls.get(attachmentId);\n  }\n  async function fetchNotificationsJson(endpoint, options2) {\n    return await httpClient2.get(endpoint, void 0, options2);\n  }\n  function getNotificationSettings(options2) {\n    return fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/notification-settings`,\n      { signal: options2?.signal }\n    );\n  }\n  function updateNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/notification-settings`,\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings)\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/inbox-notifications/read`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({ inboxNotificationIds })\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        getProvider() {\n          return context.provider;\n        },\n        setProvider(provider) {\n          context.provider = provider;\n          context.onProviderUpdate.notify();\n        },\n        onProviderUpdate: context.onProviderUpdate.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current,\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings,\n      updateNotificationSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v7\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const fetchPolyfill = clientOptions.polyfills?.fetch || /* istanbul ignore next */\n  globalThis.fetch?.bind(globalThis);\n  const notificationsAPI = createNotificationsApi({\n    baseUrl,\n    fetchPolyfill,\n    authManager,\n    currentUserIdStore\n  });\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  function invalidateResolvedUsers(userIds) {\n    usersStore.invalidate(userIds);\n  }\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  function invalidateResolvedRoomsInfo(roomIds) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n  const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n  const client = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      ...notificationsAPI,\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions\n      },\n      // Internal\n      [kInternal]: {\n        currentUserIdStore,\n        mentionSuggestionsCache,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        // \"All\" threads (= \"user\" threads)\n        getUserThreads_experimental: notificationsAPI.getUserThreads_experimental,\n        getUserThreadsSince_experimental: notificationsAPI.getUserThreadsSince_experimental,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: () => client\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n  return client;\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url2) {\n  if (url2.startsWith(\"http://\") || url2.startsWith(\"https://\")) {\n    return url2;\n  } else if (url2.startsWith(\"www.\")) {\n    return \"https://\" + url2;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ?? element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/comments/comment-url.ts\nvar PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nfunction generateCommentUrl({\n  roomUrl,\n  commentId\n}) {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(roomUrl);\n  const urlObject = new URL(\n    roomUrl,\n    isAbsolute ? void 0 : PLACEHOLDER_BASE_URL\n  );\n  urlObject.hash = `#${commentId}`;\n  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nvar BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\nfunction makePoller(callback, intervalMs, options) {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0\n  };\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n  const fsm = new FSM({}).addState(\"@idle\").addState(\"@enabled\").addState(\"@polling\");\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = 0;\n        }\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = BACKOFF_DELAYS2.find((delay) => delay > context.backoff) ?? BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1];\n        }\n      };\n    },\n    3e4\n    // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n  function setInForeground(inForeground) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale();\n  }\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/lib/SortedList.ts\nfunction bisectRight(arr, x, lt) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + (hi - lo >> 1);\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nvar SortedList = class _SortedList {\n  constructor(alreadySortedList, lt) {\n    this._lt = lt;\n    this._data = alreadySortedList;\n  }\n  static from(arr, lt) {\n    const sorted = new _SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n  static fromAlreadySorted(alreadySorted, lt) {\n    return new _SortedList(alreadySorted, lt);\n  }\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  clone() {\n    return new _SortedList(this._data.slice(), this._lt);\n  }\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   */\n  add(value) {\n    const idx = bisectRight(this._data, value, this._lt);\n    this._data.splice(idx, 0, value);\n  }\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   */\n  remove(value) {\n    const idx = this._data.indexOf(value);\n    if (idx >= 0) {\n      this._data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n  get length() {\n    return this._data.length;\n  }\n  *filter(predicate) {\n    for (const item of this._data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this._data[Symbol.iterator]();\n  }\n};\n\n// src/types/Others.ts\nvar TextEditorType = /* @__PURE__ */ ((TextEditorType2) => {\n  TextEditorType2[\"Lexical\"] = \"lexical\";\n  TextEditorType2[\"TipTap\"] = \"tiptap\";\n  return TextEditorType2;\n})(TextEditorType || {});\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nvar CommentsApiError = HttpError;\nvar NotificationsApiError = HttpError;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQixHQUFHLFVBQVU7QUFDeEU7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxxR0FBcUcsa0JBQWtCO0FBQ3ZIO0FBQ0E7QUFDQSxXQUFXLFNBQVMsRUFBRSxVQUFVO0FBQ2hDLFdBQVcsU0FBUyxFQUFFLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHdCQUF3QjtBQUMzRztBQUNBO0FBQ0EsYUFBYSxVQUFVLFFBQVEsWUFBWTtBQUMzQyxhQUFhLFNBQVMsUUFBUSxXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0MscUJBQXFCLFdBQVcsZ0JBQWdCLHVCQUF1QixnQkFBZ0I7QUFDdkg7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkJBQTZCO0FBQ3ZELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbURBQW1ELDRGQUE0RjtBQUMvSTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUksY0FBYztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQkFBc0IscUVBQXFFLEdBQUcsWUFBWSxtQkFBbUIsU0FBUztBQUN0STtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JELE1BQU07QUFDTixpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0VBQWdFLFNBQVMsS0FBSztBQUM5RTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjLG1DQUFtQyxTQUFTLGFBQWE7QUFDdkg7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdCQUFnQix5QkFBeUIsSUFBSSxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUyxHQUFHLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNEdBQTRHLGFBQWEsWUFBWSxlQUFlO0FBQ3BKO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0Esb0NBQW9DLGdDQUFnQztBQUNwRSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVUsWUFBWSxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsZ0NB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQSx5QkFBeUIsa0NBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0IsSUFBSTtBQUM1RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sbUNBQW1DLG1CQUFtQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTSxtQ0FBbUMsdUJBQXVCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTSxtQ0FBbUMsdUJBQXVCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQXFDLEdBQUcsQ0FBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsYUFBYSxNQUFxQztBQUNsRDtBQUNBLEVBQUUsQ0FBUTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELCtCQUErQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUs7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxHQUFHLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxzQkFBc0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksR0FBRywwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGNBQWMsSUFBcUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdDQUF3QztBQUN4RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLGdDQUFnQztBQUNsQztBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBLDRCQUE0Qiw4Q0FBOEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QyxRQUFRLHVDQUF1QztBQUMvQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQixZQUFZO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQ0FBZ0MsbUJBQW1CO0FBQ25ELG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDLE1BQU07QUFDTixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQStFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1ibG9ja25vdGUvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcz80Yjg3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4xMS4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9kdXBlLWRldGVjdGlvbi50c1xudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xudmFyIGNyb3NzTGlua2VkRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2Nyb3NzLWxpbmtlZFwiO1xudmFyIGR1cGVzRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2R1cGVzXCI7XG52YXIgU1BBQ0UgPSBcIiBcIjtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3REdXBlcyhwa2dOYW1lLCBwa2dWZXJzaW9uLCBwa2dGb3JtYXQpIHtcbiAgY29uc3QgcGtnSWQgPSBTeW1ib2wuZm9yKHBrZ05hbWUpO1xuICBjb25zdCBwa2dCdWlsZEluZm8gPSBwa2dGb3JtYXQgPyBgJHtwa2dWZXJzaW9uIHx8IFwiZGV2XCJ9ICgke3BrZ0Zvcm1hdH0pYCA6IHBrZ1ZlcnNpb24gfHwgXCJkZXZcIjtcbiAgaWYgKCFnW3BrZ0lkXSkge1xuICAgIGdbcGtnSWRdID0gcGtnQnVpbGRJbmZvO1xuICB9IGVsc2UgaWYgKGdbcGtnSWRdID09PSBwa2dCdWlsZEluZm8pIHtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBbXG4gICAgICBgTXVsdGlwbGUgY29waWVzIG9mIExpdmVibG9ja3MgYXJlIGJlaW5nIGxvYWRlZCBpbiB5b3VyIHByb2plY3QuIFRoaXMgd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2R1cGVzRG9jcyArIFNQQUNFfWAsXG4gICAgICBcIlwiLFxuICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7Z1twa2dJZF19IChhbHJlYWR5IGxvYWRlZClgLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke3BrZ0J1aWxkSW5mb30gKHRyeWluZyB0byBsb2FkIHRoaXMgbm93KWBcbiAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgZXJyb3IobXNnKTtcbiAgfVxuICBpZiAocGtnVmVyc2lvbiAmJiBQS0dfVkVSU0lPTiAmJiBwa2dWZXJzaW9uICE9PSBQS0dfVkVSU0lPTikge1xuICAgIGVycm9yKFxuICAgICAgW1xuICAgICAgICBgQ3Jvc3MtbGlua2VkIHZlcnNpb25zIG9mIExpdmVibG9ja3MgZm91bmQsIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtjcm9zc0xpbmtlZERvY3MgKyBTUEFDRX1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgICAgYC0gJHtQS0dfTkFNRX0gaXMgYXQgJHtQS0dfVkVSU0lPTn1gLFxuICAgICAgICBgLSAke3BrZ05hbWV9IGlzIGF0ICR7cGtnVmVyc2lvbn1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkFsd2F5cyB1cGdyYWRlIGFsbCBMaXZlYmxvY2tzIHBhY2thZ2VzIHRvIHRoZSBzYW1lIHZlcnNpb24gbnVtYmVyLlwiXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9saWIvYXNzZXJ0LnRzXG5mdW5jdGlvbiBhc3NlcnROZXZlcihfdmFsdWUsIGVycm1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IoZXJybXNnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIGVycm1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihlcnJtc2cpO1xuICAgICAgZXJyLm5hbWUgPSBcIkFzc2VydGlvbiBmYWlsdXJlXCI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBubih2YWx1ZSwgZXJybXNnID0gXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBub24tbnVsbGFibGVcIikge1xuICBhc3NlcnQodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCwgZXJybXNnKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBzcmMvbGliL2NvbnRyb2xsZWRQcm9taXNlLnRzXG5mdW5jdGlvbiBjb250cm9sbGVkUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiBbcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0XTtcbn1cbmZ1bmN0aW9uIFByb21pc2Vfd2l0aFJlc29sdmVycygpIHtcbiAgY29uc3QgW3Byb21pc2UsIHJlc29sdmUsIHJlamVjdF0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cblxuLy8gc3JjL2xpYi9FdmVudFNvdXJjZS50c1xuZnVuY3Rpb24gbWFrZUV2ZW50U291cmNlKCkge1xuICBjb25zdCBfb25ldGltZU9ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IF9vYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgX2J1ZmZlciA9IG51bGw7XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIF9idWZmZXIgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiB1bnBhdXNlKCkge1xuICAgIGlmIChfYnVmZmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgX2J1ZmZlcikge1xuICAgICAgbm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gICAgX2J1ZmZlciA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgX29ic2VydmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBfb2JzZXJ2ZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlT25jZShjYWxsYmFjaykge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vbmV0aW1lT2JzZXJ2ZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsKHByZWRpY2F0ZSkge1xuICAgIGxldCB1bnN1YjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgdW5zdWIgPSBzdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUgPT09IHZvaWQgMCB8fCBwcmVkaWNhdGUoZXZlbnQpKSB7XG4gICAgICAgICAgcmVzKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB1bnN1Yj8uKCkpO1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeU9yQnVmZmVyKGV2ZW50KSB7XG4gICAgaWYgKF9idWZmZXIgIT09IG51bGwpIHtcbiAgICAgIF9idWZmZXIucHVzaChldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgX29ic2VydmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgfVxuICBmdW5jdGlvbiBfZm9yY2VDbGVhcigpIHtcbiAgICBfb25ldGltZU9ic2VydmVycy5jbGVhcigpO1xuICAgIF9vYnNlcnZlcnMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBjb3VudCgpIHtcbiAgICByZXR1cm4gX29uZXRpbWVPYnNlcnZlcnMuc2l6ZSArIF9vYnNlcnZlcnMuc2l6ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIFByaXZhdGUvaW50ZXJuYWwgY29udHJvbCBvdmVyIGV2ZW50IGVtaXNzaW9uXG4gICAgbm90aWZ5OiBub3RpZnlPckJ1ZmZlcixcbiAgICBzdWJzY3JpYmUsXG4gICAgc3Vic2NyaWJlT25jZSxcbiAgICBfZm9yY2VDbGVhcixcbiAgICBjb3VudCxcbiAgICB3YWl0VW50aWwsXG4gICAgcGF1c2UsXG4gICAgdW5wYXVzZSxcbiAgICAvLyBQdWJsaWNseSBleHBvc2FibGUgc3Vic2NyaXB0aW9uIEFQSVxuICAgIG9ic2VydmFibGU6IHtcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIHN1YnNjcmliZU9uY2UsXG4gICAgICB3YWl0VW50aWxcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZmFuY3ktY29uc29sZS50c1xudmFyIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFuY3lfY29uc29sZV9leHBvcnRzLCB7XG4gIGVycm9yOiAoKSA9PiBlcnJvcjIsXG4gIGVycm9yV2l0aFRpdGxlOiAoKSA9PiBlcnJvcldpdGhUaXRsZSxcbiAgd2FybjogKCkgPT4gd2FybixcbiAgd2FybldpdGhUaXRsZTogKCkgPT4gd2FybldpdGhUaXRsZVxufSk7XG52YXIgYmFkZ2UgPSBcImJhY2tncm91bmQ6IzBlMGQxMjtib3JkZXItcmFkaXVzOjk5OTlweDtjb2xvcjojZmZmO3BhZGRpbmc6M3B4IDdweDtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjYwMDtcIjtcbnZhciBib2xkID0gXCJmb250LXdlaWdodDo2MDBcIjtcbmZ1bmN0aW9uIHdyYXAobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXCIlY0xpdmVibG9ja3NcIiwgYmFkZ2UsIG1lc3NhZ2UsIC4uLmFyZ3MpXG4gICk7XG59XG52YXIgd2FybiA9IHdyYXAoXCJ3YXJuXCIpO1xudmFyIGVycm9yMiA9IHdyYXAoXCJlcnJvclwiKTtcbmZ1bmN0aW9uIHdyYXBXaXRoVGl0bGUobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICh0aXRsZSwgbWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFxuICAgICAgYCVjTGl2ZWJsb2NrcyVjICR7dGl0bGV9YCxcbiAgICAgIGJhZGdlLFxuICAgICAgYm9sZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5hcmdzXG4gICAgKVxuICApO1xufVxudmFyIHdhcm5XaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwid2FyblwiKTtcbnZhciBlcnJvcldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJlcnJvclwiKTtcblxuLy8gc3JjL2xpYi9mc20udHNcbmZ1bmN0aW9uIGRpc3RhbmNlKHN0YXRlMSwgc3RhdGUyKSB7XG4gIGlmIChzdGF0ZTEgPT09IHN0YXRlMikge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgY29uc3QgY2h1bmtzMSA9IHN0YXRlMS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGNodW5rczIgPSBzdGF0ZTIuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBtaW5MZW4gPSBNYXRoLm1pbihjaHVua3MxLmxlbmd0aCwgY2h1bmtzMi5sZW5ndGgpO1xuICBsZXQgc2hhcmVkID0gMDtcbiAgZm9yICg7IHNoYXJlZCA8IG1pbkxlbjsgc2hhcmVkKyspIHtcbiAgICBpZiAoY2h1bmtzMVtzaGFyZWRdICE9PSBjaHVua3MyW3NoYXJlZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCB1cCA9IGNodW5rczEubGVuZ3RoIC0gc2hhcmVkO1xuICBjb25zdCBkb3duID0gY2h1bmtzMi5sZW5ndGggLSBzaGFyZWQ7XG4gIHJldHVybiBbdXAsIGRvd25dO1xufVxuZnVuY3Rpb24gcGF0dGVybnModGFyZ2V0U3RhdGUsIGxldmVscykge1xuICBjb25zdCBwYXJ0cyA9IHRhcmdldFN0YXRlLnNwbGl0KFwiLlwiKTtcbiAgaWYgKGxldmVscyA8IDEgfHwgbGV2ZWxzID4gcGFydHMubGVuZ3RoICsgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGxldmVsc1wiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGxldmVscyA+IHBhcnRzLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKFwiKlwiKTtcbiAgfVxuICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gbGV2ZWxzICsgMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2goc2xpY2Uuam9pbihcIi5cIikgKyBcIi4qXCIpO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaCh0YXJnZXRTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgU2FmZUNvbnRleHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxDb250ZXh0KSB7XG4gICAgdGhpcy5jdXJyID0gaW5pdGlhbENvbnRleHQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycjtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHBhdGNoaW5nIG9mIHRoZSBjb250ZXh0LCBieVxuICAgKiBjYWxsaW5nIGBjb250ZXh0LnBhdGNoKClgLiBQYXRjaGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSBkdXJhdGlvblxuICAgKiBvZiB0aGlzIHdpbmRvdy5cbiAgICovXG4gIGFsbG93UGF0Y2hpbmcoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgYWxsb3dlZCA9IHRydWU7XG4gICAgY29uc3QgcGF0Y2hhYmxlQ29udGV4dCA9IHtcbiAgICAgIC4uLnRoaXMuY3VycixcbiAgICAgIHBhdGNoKHBhdGNoKSB7XG4gICAgICAgIGlmIChhbGxvd2VkKSB7XG4gICAgICAgICAgc2VsZi5jdXJyID0gT2JqZWN0LmFzc2lnbih7fSwgc2VsZi5jdXJyLCBwYXRjaCk7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIE9iamVjdC5lbnRyaWVzKHBhdGNoKSkge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwicGF0Y2hcIikge1xuICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vIGxvbmdlciBwYXRjaCBzdGFsZSBjb250ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjYWxsYmFjayhwYXRjaGFibGVDb250ZXh0KTtcbiAgICBhbGxvd2VkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG59O1xudmFyIG5leHRJZCA9IDE7XG52YXIgRlNNID0gY2xhc3Mge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5pdGlhbCBzdGF0ZSwgd2hpY2ggaXMgZGVmaW5lZCBieSB0aGUgZmlyc3QgY2FsbCBtYWRlIHRvXG4gICAqIC5hZGRTdGF0ZSgpLlxuICAgKi9cbiAgZ2V0IGluaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnN0YXRlcy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhdGVzIGRlZmluZWQgeWV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucnVubmluZ1N0YXRlID09PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0b3BwZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbDtcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIHRoZSBtYWNoaW5lIGJ5IGVudGVyaW5nIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgbWFjaGluZSBoYXMgYWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDEgLyogU1RBUlRFRCAqLztcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IHRoaXMuaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuZW50ZXIobnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBzdGF0ZSBtYWNoaW5lLiBTdG9wcGluZyB0aGUgc3RhdGUgbWFjaGluZSB3aWxsIGNhbGwgZXhpdFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc3RhdGUsIGJ1dCBub3QgZW50ZXIgYSBuZXcgc3RhdGUuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMSAvKiBTVEFSVEVEICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RvcCBhIHN0YXRlIG1hY2hpbmUgdGhhdCBoYXNuJ3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgfVxuICAgIHRoaXMuZXhpdChudWxsKTtcbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDIgLyogU1RPUFBFRCAqLztcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmlkID0gbmV4dElkKys7XG4gICAgdGhpcy5ydW5uaW5nU3RhdGUgPSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLztcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZW50ZXJGbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2xlYW51cFN0YWNrID0gW107XG4gICAgdGhpcy5rbm93bkV2ZW50VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gbmV3IFNhZmVDb250ZXh0KGluaXRpYWxDb250ZXh0KTtcbiAgICB0aGlzLmV2ZW50SHViID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogbWFrZUV2ZW50U291cmNlKClcbiAgICB9O1xuICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiB0aGlzLmV2ZW50SHViLmRpZFJlY2VpdmVFdmVudC5vYnNlcnZhYmxlLFxuICAgICAgd2lsbFRyYW5zaXRpb246IHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ub2JzZXJ2YWJsZSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsRXhpdFN0YXRlOiB0aGlzLmV2ZW50SHViLndpbGxFeGl0U3RhdGUub2JzZXJ2YWJsZSxcbiAgICAgIGRpZEVudGVyU3RhdGU6IHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5vYnNlcnZhYmxlXG4gICAgfTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50O1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYW4gZXhwbGljaXQgZmluaXRlIHN0YXRlIGluIHRoZSBzdGF0ZSBtYWNoaW5lLlxuICAgKi9cbiAgYWRkU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVzLmFkZChzdGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25FbnRlcihuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lbnRlckZucy5oYXMobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gVE9ETyBXZSBfY3VycmVudGx5XyBkb24ndCBzdXBwb3J0IG11bHRpcGxlIC5vbkVudGVycygpIGZvciB0aGUgc2FtZVxuICAgICAgICAvLyBzdGF0ZSwgYnV0IHRoaXMgaXMgbm90IGEgZnVuZGFtZW50YWwgbGltaXRhdGlvbi4gSnVzdCBub3RcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgeWV0LiBJZiB3ZSB3YW50ZWQgdG8sIHdlIGNvdWxkIG1ha2UgdGhpcyBhbiBhcnJheS5cbiAgICAgICAgYGVudGVyL2V4aXQgZnVuY3Rpb24gZm9yICR7bmFtZU9yUGF0dGVybn0gYWxyZWFkeSBleGlzdHNgXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVudGVyRm5zLnNldChuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lcyBhIHByb21pc2UtYmFzZWQgc3RhdGUuIFdoZW4gdGhlIHN0YXRlIGlzIGVudGVyZWQsIHRoZSBwcm9taXNlIGlzXG4gICAqIGNyZWF0ZWQuIFdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMsIHRoZSBtYWNoaW5lIHdpbGwgdHJhbnNpdGlvbiB0byB0aGVcbiAgICogcHJvdmlkZWQgYG9uT0tgIHRhcmdldCBzdGF0ZS4gV2hlbiB0aGUgcHJvbWlzZSByZWplY3RzLCB0aGUgbWFjaGluZSB3aWxsXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIGBvbkVycm9yYCB0YXJnZXQgc3RhdGUuXG4gICAqXG4gICAqIE9wdGlvbmFsbHksIGEgYG1heFRpbWVvdXRgIGNhbiBiZSBzZXQuIElmIHRoZSB0aW1lb3V0IGhhcHBlbnMgYmVmb3JlIHRoZVxuICAgKiBwcm9taXNlIGlzIHNldHRsZWQsIHRoZW4gdGhlIG1hY2hpbmUgd2lsbCBhbHNvIHRyYW5zaXRpb24gdG8gdGhlIGBvbkVycm9yYFxuICAgKiB0YXJnZXQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yUGF0dGVybiAgVGhlIHN0YXRlIG5hbWUsIG9yIHN0YXRlIGdyb3VwIHBhdHRlcm4gbmFtZS5cbiAgICogQHBhcmFtIHByb21pc2VGbiAgICAgICBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzdGF0ZSBpcyBlbnRlcmVkLlxuICAgKiBAcGFyYW0gb25PSyAgICAgICAgICAgIFRoZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvIHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMuXG4gICAqIEBwYXJhbSBvbkVycm9yICAgICAgICAgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8gd2hlbiB0aGUgcHJvbWlzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdHMsIG9yIHdoZW4gdGhlIHRpbWVvdXQgaGFwcGVucyBiZWZvcmUgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSBoYXMgYmVlbiBzZXR0bGVkLlxuICAgKiBAcGFyYW0gbWF4VGltZW91dCAgICAgIE9wdGlvbmFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBXaGVuIHRoZSBwcm9taXNlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQsIGl0J3MgcHJvdmlkZWQgd2l0aCBhblxuICAgKiBBYm9ydFNpZ25hbCAoMm5kIGFyZ3VtZW50KS5cbiAgICogSWYgYSBzdGF0ZSB0cmFuc2l0aW9uIGhhcHBlbnMgd2hpbGUgdGhlIHByb21pc2UgaXMgcGVuZGluZyAoZm9yIGV4YW1wbGUsXG4gICAqIGFuIGV2ZW50LCBvciBhIHRpbWVvdXQgaGFwcGVucyksIHRoZW4gYW4gYWJvcnQgc2lnbmFsIHdpbGwgYmUgdXNlZCB0b1xuICAgKiBpbmRpY2F0ZSB0aGlzLiBJbXBsZW1lbnRlcnMgY2FuIHVzZSB0aGlzIGFib3J0IHNpZ25hbCB0byB0ZXJtaW5hdGUgdGhlXG4gICAqIGluLWZsaWdodCBwcm9taXNlLCBvciBpZ25vcmUgaXRzIHJlc3VsdHMsIGV0Yy5cbiAgICovXG4gIG9uRW50ZXJBc3luYyhuYW1lT3JQYXR0ZXJuLCBwcm9taXNlRm4sIG9uT0ssIG9uRXJyb3IsIG1heFRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKG5hbWVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBtYXhUaW1lb3V0ID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IG5ldyBFcnJvcihcIlRpbWVkIG91dFwiKTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19FUlJPUlwiLCByZWFzb24gfSwgb25FcnJvcik7XG4gICAgICB9LCBtYXhUaW1lb3V0KSA6IHZvaWQgMDtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB2b2lkIHByb21pc2VGbih0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQsIHNpZ25hbCkudGhlbihcbiAgICAgICAgLy8gT24gT0tcbiAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfT0tcIiwgZGF0YSB9LCBvbk9LKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE9uIEVycm9yXG4gICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfRVJST1JcIiwgcmVhc29uIH0sIG9uRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGlmIChuYW1lT3JQYXR0ZXJuID09PSBcIipcIikge1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZU9yUGF0dGVybi5lbmRzV2l0aChcIi4qXCIpKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuYW1lT3JQYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy5zdGF0ZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YXRlcyBtYXRjaCAke0pTT04uc3RyaW5naWZ5KG5hbWVPclBhdHRlcm4pfWApO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFsbCBhbGxvd2VkIG91dGdvaW5nIHRyYW5zaXRpb25zIGZvciBhIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0cyBmb3IgZWFjaCBldmVudCBjYW4gYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gICAqIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by4gVGhlc2UgZnVuY3Rpb25zIGNhbiBsb29rIGF0IHRoZSBgZXZlbnRgIG9yXG4gICAqIGBjb250ZXh0YCBwYXJhbXMgdG8gY29uZGl0aW9uYWxseSBkZWNpZGUgd2hpY2ggbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uXG4gICAqIHRvLlxuICAgKlxuICAgKiBJZiB5b3Ugc2V0IGl0IHRvIGBudWxsYCwgdGhlbiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIGV4cGxpY2l0bHkgZm9yYmlkZGVuXG4gICAqIGFuZCB0aHJvdyBhbiBlcnJvci4gSWYgeW91IGRvbid0IGRlZmluZSBhIHRhcmdldCBmb3IgYSB0cmFuc2l0aW9uLCB0aGVuXG4gICAqIHN1Y2ggZXZlbnRzIHdpbGwgZ2V0IGlnbm9yZWQuXG4gICAqL1xuICBhZGRUcmFuc2l0aW9ucyhuYW1lT3JQYXR0ZXJuLCBtYXBwaW5nKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyY1N0YXRlIG9mIHRoaXMuZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5nZXQoc3JjU3RhdGUpO1xuICAgICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLnNldChzcmNTdGF0ZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHRhcmdldF9dIG9mIE9iamVjdC5lbnRyaWVzKG1hcHBpbmcpKSB7XG4gICAgICAgIGlmIChtYXAuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzZXQgdHJhbnNpdGlvbiBcIiR7dHlwZX1cIiBvbiBcIiR7c3JjU3RhdGV9XCIgKHZpYSBcIiR7bmFtZU9yUGF0dGVybn1cIiksIGJ1dCBhIHRyYW5zaXRpb24gYWxyZWFkeSBleGlzdHMgdGhlcmUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0XztcbiAgICAgICAgdGhpcy5rbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuICBUaGUgc3RhdGUgbmFtZSwgb3Igc3RhdGUgZ3JvdXAgcGF0dGVybiBuYW1lLlxuICAgKiBAcGFyYW0gYWZ0ZXIgICAgICAgICAgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdG8gdGFrZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpcyB0YWtlbiwgdGhlIHRpbWVyIHdpbGwgZ2V0IGNhbmNlbGxlZC5cbiAgICogQHBhcmFtIHRhcmdldCAgICAgICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCkgOiBhZnRlcjI7XG4gICAgICBjb25zdCB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJUSU1FUlwiIH0sIHRhcmdldCk7XG4gICAgICB9LCBtcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldCh0aGlzLmN1cnJlbnRTdGF0ZSk/LmdldChldmVudE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGl0cyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuXG4gICAqIENhbGwgdGhpcyBiZWZvcmUgY2hhbmdpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBsZXZlbHMgRGVmaW5lcyBob3cgbWFueSBcImxldmVsc1wiIG9mIG5lc3Rpbmcgd2lsbCBiZVxuICAgKiBleGl0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tIGBmb28uYmFyLnF1eGAgdG9cbiAgICogYGZvby5iYXIuYmF6YCwgdGhlbiB0aGUgbGV2ZWwgaXMgMS4gQnV0IGlmIHlvdSB0cmFuc2l0aW9uIGZyb21cbiAgICogYGZvby5iYXIucXV4YCB0byBgYmxhLmJsYWAsIHRoZW4gdGhlIGxldmVsIGlzIDMuXG4gICAqIElmIGBudWxsYCwgaXQgd2lsbCBleGl0IGFsbCBsZXZlbHMuXG4gICAqL1xuICBleGl0KGxldmVscykge1xuICAgIHRoaXMuZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzID8/IHRoaXMuY2xlYW51cFN0YWNrLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgZW50ZXIobGV2ZWxzKSB7XG4gICAgY29uc3QgZW50ZXJQYXR0ZXJucyA9IHBhdHRlcm5zKFxuICAgICAgdGhpcy5jdXJyZW50U3RhdGUsXG4gICAgICBsZXZlbHMgPz8gdGhpcy5jdXJyZW50U3RhdGUuc3BsaXQoXCIuXCIpLmxlbmd0aCArIDFcbiAgICApO1xuICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVudGVyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgZW50ZXJGbiA9IHRoaXMuZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKGNsZWFudXBGbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMua25vd25FdmVudFR5cGVzLmhhcyhldmVudC50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV2ZW50ICR7SlNPTi5zdHJpbmdpZnkoZXZlbnQudHlwZSl9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMiAvKiBTVE9QUEVEICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZuID0gdGhpcy5nZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbihldmVudCwgdGFyZ2V0Rm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRTdGF0ZTtcbiAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICBjb25zdCBuZXh0VGFyZ2V0ID0gdGFyZ2V0Rm4oZXZlbnQsIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCk7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgZWZmZWN0cyA9IHZvaWQgMDtcbiAgICBpZiAobmV4dFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGVzLmhhcyhuZXh0U3RhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV4dCBzdGF0ZSBuYW1lOiAke0pTT04uc3RyaW5naWZ5KG5leHRTdGF0ZSl9YCk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ubm90aWZ5KHsgZnJvbTogb2xkU3RhdGUsIHRvOiBuZXh0U3RhdGUgfSk7XG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpc3RhbmNlKHRoaXMuY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIGlmICh1cCA+IDApIHtcbiAgICAgIHRoaXMuZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFN0YXRlT3JOdWxsID0gbmV4dFN0YXRlO1xuICAgIGlmIChlZmZlY3RzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGVmZmVjdHNUb1J1biA9IGVmZmVjdHM7XG4gICAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0c1RvUnVuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWZmZWN0KHBhdGNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hhYmxlQ29udGV4dC5wYXRjaChlZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb3duID4gMCkge1xuICAgICAgdGhpcy5lbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKTtcbn1cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmosIG1hcEZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGNvbnN0IGtleSA9IHBhaXJbMF07XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcGFpclsxXTtcbiAgICByZXN1bHRba2V5XSA9IG1hcEZuKHZhbHVlLCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpzb24ocmF3TWVzc2FnZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJhd01lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZGVlcENsb25lKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBiNjRkZWNvZGUoYjY0dmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGI2NHZhbHVlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgIGF0b2IoZm9ybWF0dGVkVmFsdWUpLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB9KS5qb2luKFwiXCIpXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYXRvYihiNjR2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhY3QoaXRlbXMpIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlcihcbiAgICAoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3Qob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgaWYgKG5ld09ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuZnVuY3Rpb24gd2FpdChtaWxsaXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtaWxsaXMpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1pbGxpcywgZXJybXNnKSB7XG4gIGxldCB0aW1lcklEO1xuICBjb25zdCB0aW1lciQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgdGltZXJJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJtc2cpKTtcbiAgICB9LCBtaWxsaXMpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZXIkXSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXJJRCkpO1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9uU3VjY2VzcyhmYWN0b3J5Rm4pIHtcbiAgbGV0IGNhY2hlZCA9IG51bGw7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGNhY2hlZCA9PT0gbnVsbCkge1xuICAgICAgY2FjaGVkID0gZmFjdG9yeUZuKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjYWNoZWQgPSBudWxsO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL1NlcnZlck1zZy50c1xudmFyIFNlcnZlck1zZ0NvZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJ2ZXJNc2dDb2RlMikgPT4ge1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9QUkVTRU5DRVwiXSA9IDEwMF0gPSBcIlVQREFURV9QUkVTRU5DRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfSk9JTkVEXCJdID0gMTAxXSA9IFwiVVNFUl9KT0lORURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0xFRlRcIl0gPSAxMDJdID0gXCJVU0VSX0xFRlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJCUk9BRENBU1RFRF9FVkVOVFwiXSA9IDEwM10gPSBcIkJST0FEQ0FTVEVEX0VWRU5UXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUk9PTV9TVEFURVwiXSA9IDEwNF0gPSBcIlJPT01fU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIl0gPSAyMDBdID0gXCJJTklUSUFMX1NUT1JBR0VfU1RBVEVcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiUkVKRUNUX1NUT1JBR0VfT1BcIl0gPSAyOTldID0gXCJSRUpFQ1RfU1RPUkFHRV9PUFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAwXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfQ1JFQVRFRFwiXSA9IDQwMF0gPSBcIlRIUkVBRF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX0RFTEVURURcIl0gPSA0MDddID0gXCJUSFJFQURfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCJdID0gNDAxXSA9IFwiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfVVBEQVRFRFwiXSA9IDQwOF0gPSBcIlRIUkVBRF9VUERBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9DUkVBVEVEXCJdID0gNDAyXSA9IFwiQ09NTUVOVF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9FRElURURcIl0gPSA0MDNdID0gXCJDT01NRU5UX0VESVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfREVMRVRFRFwiXSA9IDQwNF0gPSBcIkNPTU1FTlRfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIl0gPSA0MDVdID0gXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCJdID0gNDA2XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCI7XG4gIHJldHVybiBTZXJ2ZXJNc2dDb2RlMjtcbn0pKFNlcnZlck1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvSVdlYlNvY2tldC50c1xudmFyIFdlYnNvY2tldENsb3NlQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChXZWJzb2NrZXRDbG9zZUNvZGVzMikgPT4ge1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX05PUk1BTFwiXSA9IDFlM10gPSBcIkNMT1NFX05PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX0FCTk9STUFMXCJdID0gMTAwNl0gPSBcIkNMT1NFX0FCTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVU5FWFBFQ1RFRF9DT05ESVRJT05cIl0gPSAxMDExXSA9IFwiVU5FWFBFQ1RFRF9DT05ESVRJT05cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUUllfQUdBSU5fTEFURVJcIl0gPSAxMDEzXSA9IFwiVFJZX0FHQUlOX0xBVEVSXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiXSA9IDRlM10gPSBcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJOT1RfQUxMT1dFRFwiXSA9IDQwMDFdID0gXCJOT1RfQUxMT1dFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIl0gPSA0MDAyXSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiXSA9IDQwMDNdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiXSA9IDQwMDRdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiXSA9IDQwMDVdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJST09NX0lEX1VQREFURURcIl0gPSA0MDA2XSA9IFwiUk9PTV9JRF9VUERBVEVEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiS0lDS0VEXCJdID0gNDEwMF0gPSBcIktJQ0tFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRPS0VOX0VYUElSRURcIl0gPSA0MTA5XSA9IFwiVE9LRU5fRVhQSVJFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX1dJVEhPVVRfUkVUUllcIl0gPSA0OTk5XSA9IFwiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiO1xuICByZXR1cm4gV2Vic29ja2V0Q2xvc2VDb2RlczI7XG59KShXZWJzb2NrZXRDbG9zZUNvZGVzIHx8IHt9KTtcbmZ1bmN0aW9uIHNob3VsZERpc2Nvbm5lY3QoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gNDk5OSAvKiBDTE9TRV9XSVRIT1VUX1JFVFJZICovIHx8IGNvZGUgPj0gNGUzICYmIGNvZGUgPCA0MTAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gNDEwMCAmJiBjb2RlIDwgNDIwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMDEzIC8qIFRSWV9BR0FJTl9MQVRFUiAqLyB8fCBjb2RlID49IDQyMDAgJiYgY29kZSA8IDQzMDA7XG59XG5cbi8vIHNyYy9jb25uZWN0aW9uLnRzXG5mdW5jdGlvbiBpc0lkbGUoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IFwiaW5pdGlhbFwiIHx8IHN0YXR1cyA9PT0gXCJkaXNjb25uZWN0ZWRcIjtcbn1cbmZ1bmN0aW9uIHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXRlID0gbWFjaGluZS5jdXJyZW50U3RhdGU7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIFwiQG9rLmNvbm5lY3RlZFwiOlxuICAgIGNhc2UgXCJAb2suYXdhaXRpbmctcG9uZ1wiOlxuICAgICAgcmV0dXJuIFwiY29ubmVjdGVkXCI7XG4gICAgY2FzZSBcIkBpZGxlLmluaXRpYWxcIjpcbiAgICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgICBjYXNlIFwiQGF1dGguYnVzeVwiOlxuICAgIGNhc2UgXCJAYXV0aC5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiOlxuICAgIGNhc2UgXCJAaWRsZS56b21iaWVcIjpcbiAgICAgIHJldHVybiBtYWNoaW5lLmNvbnRleHQuc3VjY2Vzc0NvdW50ID4gMCA/IFwicmVjb25uZWN0aW5nXCIgOiBcImNvbm5lY3RpbmdcIjtcbiAgICBjYXNlIFwiQGlkbGUuZmFpbGVkXCI6XG4gICAgICByZXR1cm4gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHN0YXRlLCBcIlVua25vd24gc3RhdGVcIik7XG4gIH1cbn1cbnZhciBCQUNLT0ZGX0RFTEFZUyA9IFsyNTAsIDUwMCwgMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xudmFyIFJFU0VUX0RFTEFZID0gQkFDS09GRl9ERUxBWVNbMF0gLSAxO1xudmFyIEJBQ0tPRkZfREVMQVlTX1NMT1cgPSBbMmUzLCAzZTQsIDZlNCwgM2U1XTtcbnZhciBIRUFSVEJFQVRfSU5URVJWQUwgPSAzZTQ7XG52YXIgUE9OR19USU1FT1VUID0gMmUzO1xudmFyIEFVVEhfVElNRU9VVCA9IDFlNDtcbnZhciBTT0NLRVRfQ09OTkVDVF9USU1FT1VUID0gMWU0O1xudmFyIFN0b3BSZXRyeWluZyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59O1xuZnVuY3Rpb24gbmV4dEJhY2tvZmZEZWxheShjdXJyZW50RGVsYXksIGRlbGF5cykge1xuICByZXR1cm4gZGVsYXlzLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGN1cnJlbnREZWxheSkgPz8gZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZUylcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVNfU0xPVylcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNldFN1Y2Nlc3NDb3VudChjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBzdWNjZXNzQ291bnQ6IDAgfSk7XG59XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgY29uc3QgbG9nZ2VyID0gbGV2ZWwgPT09IDIgLyogRVJST1IgKi8gPyBlcnJvcjIgOiBsZXZlbCA9PT0gMSAvKiBXQVJOICovID8gd2FybiA6IChcbiAgICAvKiBibGFjayBob2xlICovXG4gICAgKCkgPT4ge1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsb2dnZXIobWVzc2FnZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlKSB7XG4gIGNvbnN0IGNvbm4gPSBcIkNvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyXCI7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgd2FybihgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuICR7U3RyaW5nKGUpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpc0Nsb3NlRXZlbnQoZSkgPyBgJHtjb25ufSBjbG9zZWQgcHJlbWF0dXJlbHkgKGNvZGU6ICR7ZS5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gIDogYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbG9nQ2xvc2VFdmVudChldmVudCkge1xuICBjb25zdCBkZXRhaWxzID0gW2Bjb2RlOiAke2V2ZW50LmNvZGV9YF07XG4gIGlmIChldmVudC5yZWFzb24pIHtcbiAgICBkZXRhaWxzLnB1c2goYHJlYXNvbjogJHtldmVudC5yZWFzb259YCk7XG4gIH1cbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYENvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZCAoJHtkZXRhaWxzLmpvaW4oXCIsIFwiKX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYFxuICAgICk7XG4gIH07XG59XG52YXIgbG9nUGVybWFuZW50Q2xvc2UgPSBsb2coXG4gIDEgLyogV0FSTiAqLyxcbiAgXCJDb25uZWN0aW9uIHRvIFdlYlNvY2tldCBjbG9zZWQgcGVybWFuZW50bHkuIFdvbid0IHJldHJ5LlwiXG4pO1xuZnVuY3Rpb24gaXNDbG9zZUV2ZW50KGVycm9yMykge1xuICByZXR1cm4gIShlcnJvcjMgaW5zdGFuY2VvZiBFcnJvcikgJiYgZXJyb3IzLnR5cGUgPT09IFwiY2xvc2VcIjtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNpbmcobWFjaGluZSkge1xuICBjb25zdCBzdGFydCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICBmdW5jdGlvbiBsb2cyKC4uLmFyZ3MpIHtcbiAgICB3YXJuKFxuICAgICAgYCR7KCgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIDFlMykudG9GaXhlZCgyKX0gW0ZTTSAjJHttYWNoaW5lLmlkfV1gLFxuICAgICAgLi4uYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3QgdW5zdWJzID0gW1xuICAgIG1hY2hpbmUuZXZlbnRzLmRpZFJlY2VpdmVFdmVudC5zdWJzY3JpYmUoKGUpID0+IGxvZzIoYEV2ZW50ICR7ZS50eXBlfWApKSxcbiAgICBtYWNoaW5lLmV2ZW50cy53aWxsVHJhbnNpdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoeyBmcm9tLCB0byB9KSA9PiBsb2cyKFwiVHJhbnNpdGlvbmluZ1wiLCBmcm9tLCBcIlxcdTIxOTJcIiwgdG8pXG4gICAgKSxcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRJZ25vcmVFdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZSkgPT4gbG9nMihcIklnbm9yZWQgZXZlbnRcIiwgZS50eXBlLCBlLCBcIihjdXJyZW50IHN0YXRlIHdvbid0IGhhbmRsZSBpdClcIilcbiAgICApXG4gICAgLy8gbWFjaGluZS5ldmVudHMud2lsbEV4aXRTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkV4aXRpbmcgc3RhdGVcIiwgcykpLFxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFbnRlcmluZyBzdGF0ZVwiLCBzKSksXG4gIF07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdHVzRGlkQ2hhbmdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZENvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkRGlzY29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBsZXQgbGFzdFN0YXR1cyA9IG51bGw7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJTdGF0dXMgPSB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSk7XG4gICAgaWYgKGN1cnJTdGF0dXMgIT09IGxhc3RTdGF0dXMpIHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZS5ub3RpZnkoY3VyclN0YXR1cyk7XG4gICAgfVxuICAgIGlmIChsYXN0U3RhdHVzID09PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZERpc2Nvbm5lY3Qubm90aWZ5KCk7XG4gICAgfSBlbHNlIGlmIChsYXN0U3RhdHVzICE9PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZENvbm5lY3Qubm90aWZ5KCk7XG4gICAgfVxuICAgIGxhc3RTdGF0dXMgPSBjdXJyU3RhdHVzO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNEaWRDaGFuZ2U6IHN0YXR1c0RpZENoYW5nZS5vYnNlcnZhYmxlLFxuICAgIGRpZENvbm5lY3Q6IGRpZENvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICBkaWREaXNjb25uZWN0OiBkaWREaXNjb25uZWN0Lm9ic2VydmFibGUsXG4gICAgdW5zdWJzY3JpYmVcbiAgfTtcbn1cbnZhciBhc3NpZ24gPSAocGF0Y2gpID0+IChjdHgpID0+IGN0eC5wYXRjaChwYXRjaCk7XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKGRlbGVnYXRlcywgb3B0aW9ucykge1xuICBjb25zdCBvbk1lc3NhZ2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgb25NZXNzYWdlLnBhdXNlKCk7XG4gIGNvbnN0IG9uTGl2ZWJsb2Nrc0Vycm9yID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGZ1bmN0aW9uIGZpcmVFcnJvckV2ZW50KGVycm1zZywgZXJyY29kZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgTGl2ZWJsb2Nrc0Vycm9yKGVycm1zZywgZXJyY29kZSk7XG4gICAgICBvbkxpdmVibG9ja3NFcnJvci5ub3RpZnkoZXJyKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGluaXRpYWxDb250ZXh0ID0ge1xuICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICBhdXRoVmFsdWU6IG51bGwsXG4gICAgc29ja2V0OiBudWxsLFxuICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgfTtcbiAgY29uc3QgbWFjaGluZSA9IG5ldyBGU00oaW5pdGlhbENvbnRleHQpLmFkZFN0YXRlKFwiQGlkbGUuaW5pdGlhbFwiKS5hZGRTdGF0ZShcIkBpZGxlLmZhaWxlZFwiKS5hZGRTdGF0ZShcIkBpZGxlLnpvbWJpZVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJ1c3lcIikuYWRkU3RhdGUoXCJAYXV0aC5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYnVzeVwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAb2suY29ubmVjdGVkXCIpLmFkZFN0YXRlKFwiQG9rLmF3YWl0aW5nLXBvbmdcIik7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCIqXCIsIHtcbiAgICBSRUNPTk5FQ1Q6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgcmVzZXRTdWNjZXNzQ291bnRdXG4gICAgfSxcbiAgICBESVNDT05ORUNUOiBcIkBpZGxlLmluaXRpYWxcIlxuICB9KTtcbiAgbWFjaGluZS5vbkVudGVyKFwiQGlkbGUuKlwiLCByZXNldFN1Y2Nlc3NDb3VudCkuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS4qXCIsIHtcbiAgICBDT05ORUNUOiAoXywgY3R4KSA9PiAoXG4gICAgICAvLyBJZiB3ZSBzdGlsbCBoYXZlIGEga25vd24gYXV0aFZhbHVlLCB0cnkgdG8gcmVjb25uZWN0IHRvIHRoZSBzb2NrZXQgZGlyZWN0bHksXG4gICAgICAvLyBvdGhlcndpc2UsIHRyeSB0byBvYnRhaW4gYSBuZXcgYXV0aFZhbHVlXG4gICAgICBjdHguYXV0aFZhbHVlICE9PSBudWxsID8gXCJAY29ubmVjdGluZy5idXN5XCIgOiBcIkBhdXRoLmJ1c3lcIlxuICAgIClcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAYXV0aC5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBhdXRoLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBhdXRoLmJ1c3lcIixcbiAgICAoKSA9PiB3aXRoVGltZW91dChcbiAgICAgIGRlbGVnYXRlcy5hdXRoZW50aWNhdGUoKSxcbiAgICAgIEFVVEhfVElNRU9VVCxcbiAgICAgIFwiVGltZWQgb3V0IGR1cmluZyBhdXRoXCJcbiAgICApLFxuICAgIC8vIE9uIHN1Y2Nlc3NmdWwgYXV0aGVudGljYXRpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIGF1dGhWYWx1ZTogb2tFdmVudC5kYXRhXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIEF1dGggZmFpbGVkXG4gICAgKGZhaWxlZEV2ZW50KSA9PiB7XG4gICAgICBpZiAoZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheSxcbiAgICAgICAgICBsb2coXG4gICAgICAgICAgICAyIC8qIEVSUk9SICovLFxuICAgICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlIDogU3RyaW5nKGZhaWxlZEV2ZW50LnJlYXNvbil9YFxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IG9uU29ja2V0RXJyb3IgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0VSUk9SXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldENsb3NlID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRVwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRNZXNzYWdlID0gKGV2ZW50KSA9PiBldmVudC5kYXRhID09PSBcInBvbmdcIiA/IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiUE9OR1wiIH0pIDogb25NZXNzYWdlLm5vdGlmeShldmVudCk7XG4gIGZ1bmN0aW9uIHRlYXJkb3duU29ja2V0KHNvY2tldCkge1xuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBjb25uZWN0aW5nLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGNvbm5lY3RpbmcuYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vXG4gICAgLy8gVXNlIHRoZSBcImNyZWF0ZVNvY2tldFwiIGRlbGVnYXRlIGZ1bmN0aW9uIChwcm92aWRlZCB0byB0aGVcbiAgICAvLyBNYW5hZ2VkU29ja2V0KSB0byBjcmVhdGUgdGhlIGFjdHVhbCBXZWJTb2NrZXQgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICAvLyBUaGVuLCBzZXQgdXAgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLCBhbmQgd2FpdCBmb3IgdGhlXG4gICAgLy8gXCJvcGVuXCIgZXZlbnQgdG8gb2NjdXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBcIm9wZW5cIiBldmVudCBoYXBwZW5zLCB3ZSdyZSByZWFkeSB0byB0cmFuc2l0aW9uIHRvIHRoZVxuICAgIC8vIE9LIHN0YXRlLiBUaGlzIGlzIGRvbmUgYnkgcmVzb2x2aW5nIHRoZSBQcm9taXNlLlxuICAgIC8vXG4gICAgYXN5bmMgKGN0eCwgc2lnbmFsKSA9PiB7XG4gICAgICBsZXQgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IG51bGw7XG4gICAgICBsZXQgdW5jb25maXJtZWRTb2NrZXQgPSBudWxsO1xuICAgICAgY29uc3QgY29ubmVjdCQgPSBuZXcgUHJvbWlzZShcbiAgICAgICAgKHJlc29sdmUsIHJlaikgPT4ge1xuICAgICAgICAgIGlmIChjdHguYXV0aFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIGF1dGhWYWx1ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc29ja2V0ID0gZGVsZWdhdGVzLmNyZWF0ZVNvY2tldChjdHguYXV0aFZhbHVlKTtcbiAgICAgICAgICB1bmNvbmZpcm1lZFNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgICBmdW5jdGlvbiByZWplY3QoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgW2FjdG9yJCwgZGlkUmVjZWl2ZUFjdG9yXSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gd2FpdEZvckFjdG9ySWQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlck1zZyA9IHRyeVBhcnNlSnNvbihldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJNc2c/LnR5cGUgPT09IDEwNCAvKiBST09NX1NUQVRFICovKSB7XG4gICAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICAgICAgICBjb25zdCB1bnN1YiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdm9pZCBhY3RvciQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoW3NvY2tldCwgdW5zdWJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHdpdGhUaW1lb3V0KFxuICAgICAgICBjb25uZWN0JCxcbiAgICAgICAgU09DS0VUX0NPTk5FQ1RfVElNRU9VVCxcbiAgICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIHdlYnNvY2tldCBjb25uZWN0aW9uXCJcbiAgICAgICkudGhlbihcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUGFydCAzOlxuICAgICAgICAvLyBCeSBub3csIG91ciBcIm9wZW5cIiBldmVudCBoYXMgZmlyZWQsIGFuZCB0aGUgcHJvbWlzZSBoYXMgYmVlblxuICAgICAgICAvLyByZXNvbHZlZC4gVHdvIHBvc3NpYmxlIHNjZW5hcmlvczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMS4gVGhlIGhhcHB5IHBhdGguIE1vc3QgbGlrZWx5LlxuICAgICAgICAvLyAyLiBVaC1vaC4gQSBwcmVtYXR1cmUgY2xvc2UvZXJyb3IgZXZlbnQgaGFzIGJlZW4gb2JzZXJ2ZWQuIExldCdzXG4gICAgICAgIC8vICAgIHJlamVjdCB0aGUgcHJvbWlzZSBhZnRlciBhbGwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFueSBjbG9zZS9lcnJvciBldmVudCB0aGF0IHdpbGwgZ2V0IHNjaGVkdWxlZCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIG9ud2FyZHMsIHdpbGwgYmUgY2F1Z2h0IGluIHRoZSBPSyBzdGF0ZSwgYW5kIGRlYWx0IHdpdGhcbiAgICAgICAgLy8gYWNjb3JkaW5nbHkuXG4gICAgICAgIC8vXG4gICAgICAgIChbc29ja2V0LCB1bnN1Yl0pID0+IHtcbiAgICAgICAgICB1bnN1YigpO1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJvcnRlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQpIHtcbiAgICAgICAgICAgIHRocm93IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgIH1cbiAgICAgICkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGVhcmRvd25Tb2NrZXQodW5jb25maXJtZWRTb2NrZXQpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBPbmx5IHRyYW5zaXRpb24gdG8gT0sgc3RhdGUgYWZ0ZXIgYSBzdWNjZXNzZnVsbHkgb3BlbmVkIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQG9rLmNvbm5lY3RlZFwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBzb2NrZXQ6IG9rRXZlbnQuZGF0YSxcbiAgICAgICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2Fubm90IGJlIGVzdGFibGlzaGVkXG4gICAgKGZhaWx1cmUpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGZhaWx1cmUucmVhc29uO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlcnIubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2xvc2VFdmVudChlcnIpKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksXG4gICAgICAgICAgICAgIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycilcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5yZWFzb24pLFxuICAgICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlcnIucmVhc29uLCBlcnIuY29kZSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKV1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBzZW5kSGVhcnRiZWF0ID0ge1xuICAgIHRhcmdldDogXCJAb2suYXdhaXRpbmctcG9uZ1wiLFxuICAgIGVmZmVjdDogKGN0eCkgPT4ge1xuICAgICAgY3R4LnNvY2tldD8uc2VuZChcInBpbmdcIik7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYXliZUhlYXJ0YmVhdCA9ICgpID0+IHtcbiAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgICBjb25zdCBjYW5ab21iaWUgPSBkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIiAmJiBkZWxlZ2F0ZXMuY2FuWm9tYmllKCk7XG4gICAgcmV0dXJuIGNhblpvbWJpZSA/IFwiQGlkbGUuem9tYmllXCIgOiBzZW5kSGVhcnRiZWF0O1xuICB9O1xuICBtYWNoaW5lLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5jb25uZWN0ZWRcIiwgSEVBUlRCRUFUX0lOVEVSVkFMLCBtYXliZUhlYXJ0YmVhdCkuYWRkVHJhbnNpdGlvbnMoXCJAb2suY29ubmVjdGVkXCIsIHtcbiAgICBOQVZJR0FUT1JfT0ZGTElORTogbWF5YmVIZWFydGJlYXQsXG4gICAgLy8gRG9uJ3QgdGFrZSB0aGUgYnJvd3NlcidzIHdvcmQgZm9yIGl0IHdoZW4gaXQgc2F5cyBpdCdzIG9mZmxpbmUuIERvIGEgcGluZy9wb25nIHRvIG1ha2Ugc3VyZS5cbiAgICBXSU5ET1dfR09UX0ZPQ1VTOiBzZW5kSGVhcnRiZWF0XG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuem9tYmllXCIsIHtcbiAgICBXSU5ET1dfR09UX0ZPQ1VTOiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIlxuICAgIC8vIFdoZW4gaW4gem9tYmllIHN0YXRlLCB0aGUgY2xpZW50IHdpbGwgdHJ5IHRvIHdha2UgdXAgYXV0b21hdGljYWxseSB3aGVuIHRoZSB3aW5kb3cgcmVnYWlucyBmb2N1c1xuICB9KTtcbiAgbWFjaGluZS5vbkVudGVyKFwiQG9rLipcIiwgKGN0eCkgPT4ge1xuICAgIGN0eC5wYXRjaCh7IHN1Y2Nlc3NDb3VudDogY3R4LnN1Y2Nlc3NDb3VudCArIDEgfSk7XG4gICAgY29uc3QgdGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAvLyBPbiB0aGUgbmV4dCB0aWNrLCBzdGFydCBkZWxpdmVyaW5nIGFsbCBtZXNzYWdlcyB0aGF0IGhhdmUgYWxyZWFkeVxuICAgICAgLy8gYmVlbiByZWNlaXZlZCwgYW5kIGNvbnRpbnVlIHN5bmNocm9ub3VzIGRlbGl2ZXJ5IG9mIGFsbCBmdXR1cmVcbiAgICAgIC8vIGluY29taW5nIG1lc3NhZ2VzLlxuICAgICAgb25NZXNzYWdlLnVucGF1c2UsXG4gICAgICAwXG4gICAgKTtcbiAgICByZXR1cm4gKGN0eDIpID0+IHtcbiAgICAgIHRlYXJkb3duU29ja2V0KGN0eDIuc29ja2V0KTtcbiAgICAgIGN0eDIucGF0Y2goeyBzb2NrZXQ6IG51bGwgfSk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7XG4gICAgICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgICB9O1xuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5hd2FpdGluZy1wb25nXCIsIHsgUE9ORzogXCJAb2suY29ubmVjdGVkXCIgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgUE9OR19USU1FT1VULCB7XG4gICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvLyBMb2cgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzIGFuZCBkcm9wIHRoZSBjdXJyZW50IG9wZW4gc29ja2V0XG4gICAgZWZmZWN0OiBsb2coXG4gICAgICAxIC8qIFdBUk4gKi8sXG4gICAgICBcIlJlY2VpdmVkIG5vIHBvbmcgZnJvbSBzZXJ2ZXIsIGFzc3VtZSBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MuXCJcbiAgICApXG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLipcIiwge1xuICAgIC8vIFdoZW4gYSBzb2NrZXQgcmVjZWl2ZXMgYW4gZXJyb3IsIHRoaXMgY2FuIGNhdXNlIHRoZSBjbG9zaW5nIG9mIHRoZVxuICAgIC8vIHNvY2tldCwgb3Igbm90LiBTbyBhbHdheXMgY2hlY2sgdG8gc2VlIGlmIHRoZSBzb2NrZXQgaXMgc3RpbGwgT1BFTiBvclxuICAgIC8vIG5vdC4gV2hlbiBzdGlsbCBPUEVOLCBkb24ndCB0cmFuc2l0aW9uLlxuICAgIEVYUExJQ0lUX1NPQ0tFVF9FUlJPUjogKF8sIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChjb250ZXh0LnNvY2tldD8ucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogaW5jcmVhc2VCYWNrb2ZmRGVsYXlcbiAgICAgIH07XG4gICAgfSxcbiAgICBFWFBMSUNJVF9TT0NLRVRfQ0xPU0U6IChlKSA9PiB7XG4gICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nUGVybWFuZW50Q2xvc2UsXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChlLmV2ZW50LnJlYXNvbiwgZS5ldmVudC5jb2RlKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICBpZiAoZS5ldmVudC5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICAgIGNvbnN0IHJvb3QgPSB3aW4gPz8gZG9jO1xuICAgIG1hY2hpbmUub25FbnRlcihcIipcIiwgKGN0eCkgPT4ge1xuICAgICAgZnVuY3Rpb24gb25OZXR3b3JrT2ZmbGluZSgpIHtcbiAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJOQVZJR0FUT1JfT0ZGTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25OZXR3b3JrQmFja09ubGluZSgpIHtcbiAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJOQVZJR0FUT1JfT05MSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIGlmIChkb2M/LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIldJTkRPV19HT1RfRk9DVVNcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgIHJvb3Q/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByb290Py5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KGN0eC5zb2NrZXQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBjbGVhbnVwcyA9IFtdO1xuICBjb25zdCB7IHN0YXR1c0RpZENoYW5nZSwgZGlkQ29ubmVjdCwgZGlkRGlzY29ubmVjdCwgdW5zdWJzY3JpYmUgfSA9IGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKTtcbiAgY2xlYW51cHMucHVzaCh1bnN1YnNjcmliZSk7XG4gIGlmIChvcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZykge1xuICAgIGNsZWFudXBzLnB1c2goZW5hYmxlVHJhY2luZyhtYWNoaW5lKSk7XG4gIH1cbiAgbWFjaGluZS5zdGFydCgpO1xuICByZXR1cm4ge1xuICAgIG1hY2hpbmUsXG4gICAgY2xlYW51cHMsXG4gICAgLy8gT2JzZXJ2YWJsZSBldmVudHMgdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhpcyBtYWNoaW5lXG4gICAgZXZlbnRzOiB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2UsXG4gICAgICBkaWRDb25uZWN0LFxuICAgICAgZGlkRGlzY29ubmVjdCxcbiAgICAgIG9uTWVzc2FnZTogb25NZXNzYWdlLm9ic2VydmFibGUsXG4gICAgICBvbkxpdmVibG9ja3NFcnJvcjogb25MaXZlYmxvY2tzRXJyb3Iub2JzZXJ2YWJsZVxuICAgIH1cbiAgfTtcbn1cbnZhciBNYW5hZ2VkU29ja2V0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZXMsIGVuYWJsZURlYnVnTG9nZ2luZyA9IGZhbHNlLCB3YWl0Rm9yQWN0b3JJZCA9IHRydWUpIHtcbiAgICBjb25zdCB7IG1hY2hpbmUsIGV2ZW50cywgY2xlYW51cHMgfSA9IGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoXG4gICAgICBkZWxlZ2F0ZXMsXG4gICAgICB7IHdhaXRGb3JBY3RvcklkLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgfVxuICAgICk7XG4gICAgdGhpcy5tYWNoaW5lID0gbWFjaGluZTtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLmNsZWFudXBzID0gY2xlYW51cHM7XG4gIH1cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdG9OZXdDb25uZWN0aW9uU3RhdHVzKHRoaXMubWFjaGluZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dGggYXV0aFZhbHVlLlxuICAgKi9cbiAgZ2V0IGF1dGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNoaW5lLmNvbnRleHQuYXV0aFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIHRyeSB0byBjb25uZWN0IHRvIGEgV2ViU29ja2V0LiBUaGlzIG9ubHkgaGFzIGFuIGVmZmVjdFxuICAgKiBpZiB0aGUgbWFjaGluZSBpcyBpZGxlIGF0IHRoZSBtb21lbnQsIG90aGVyd2lzZSB0aGlzIGlzIGEgbm8tb3AuXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIGlkbGUsIHdpbGwgdHJ5IHRvIGNvbm5lY3QuIE90aGVyd2lzZSwgaXQgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCB0b1xuICAgKiB0aGUgc29ja2V0LCBwb3RlbnRpYWxseSBvYnRhaW5pbmcgYSBuZXcgYXV0aFZhbHVlIGZpcnN0LCBpZiBuZWVkZWQuXG4gICAqL1xuICByZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlJFQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudCBXZWJTb2NrZXQuIElzIGdvaW5nIHRvIGJlXG4gICAqIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJESVNDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBzdG9wIHRoZSBtYWNoaW5lIGFuZCBydW4gbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLiBBZnRlclxuICAgKiBjYWxsaW5nIGRlc3Ryb3koKSwgeW91IGNhbiBubyBsb25nZXIgdXNlIHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpcyBiZWZvcmVcbiAgICogbGV0dGluZyB0aGUgaW5zdGFuY2UgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc3RvcCgpO1xuICAgIGxldCBjbGVhbnVwO1xuICAgIHdoaWxlIChjbGVhbnVwID0gdGhpcy5jbGVhbnVwcy5wb3AoKSkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2FmZWx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uLiBXaWxsIGVtaXQgYSBsb2dcbiAgICogbWVzc2FnZSBpZiB0aGlzIGlzIHNvbWVob3cgaW1wb3NzaWJsZS5cbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubWFjaGluZS5jb250ZXh0Py5zb2NrZXQ7XG4gICAgaWYgKHNvY2tldCA9PT0gbnVsbCkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBub3QgY29ubmVjdGVkIHlldFwiLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IFdlYlNvY2tldCBubyBsb25nZXIgb3BlblwiLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOT1RFOiBVc2VkIGJ5IHRoZSBFMkUgYXBwIG9ubHksIHRvIHNpbXVsYXRlIGV4cGxpY2l0IGV2ZW50cy5cbiAgICogTm90IGlkZWFsIHRvIGtlZXAgZXhwb3NlZCA6KFxuICAgKi9cbiAgX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoZXZlbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQXV0aFRva2VuLnRzXG5mdW5jdGlvbiBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gY2FuQ29tbWVudChzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZGF0YSkgJiYgKGRhdGEuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aFRva2VuKHJhd1Rva2VuU3RyaW5nKSB7XG4gIGNvbnN0IHRva2VuUGFydHMgPSByYXdUb2tlblN0cmluZy5zcGxpdChcIi5cIik7XG4gIGlmICh0b2tlblBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBpbnZhbGlkIEpXVCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gdHJ5UGFyc2VKc29uKGI2NGRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gIGlmICghKHBheWxvYWQgJiYgaXNWYWxpZEF1dGhUb2tlblBheWxvYWQocGF5bG9hZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogZXhwZWN0ZWQgYSB2YWxpZCB0b2tlbiBidXQgZGlkIG5vdCBnZXQgb25lLiBIaW50OiBpZiB5b3UgYXJlIHVzaW5nIGEgY2FsbGJhY2ssIGVuc3VyZSB0aGUgcm9vbSBpcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudENhbGxiYWNrXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdUb2tlblN0cmluZyxcbiAgICBwYXJzZWQ6IHBheWxvYWRcbiAgfTtcbn1cblxuLy8gc3JjL2F1dGgtbWFuYWdlci50c1xuZnVuY3Rpb24gY3JlYXRlQXV0aE1hbmFnZXIoYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgYXV0aGVudGljYXRpb24gPSBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpO1xuICBjb25zdCBzZWVuVG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IGV4cGlyeVRpbWVzID0gW107XG4gIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNlZW5Ub2tlbnMuY2xlYXIoKTtcbiAgICB0b2tlbnMubGVuZ3RoID0gMDtcbiAgICBleHBpcnlUaW1lcy5sZW5ndGggPSAwO1xuICAgIHJlcXVlc3RQcm9taXNlcy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdGVkU2NvcGUsIHNjb3Blcykge1xuICAgIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJjb21tZW50czpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czpyZWFkXCIgLyogQ29tbWVudHNSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJyb29tOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguY2VpbChEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGV4cGlyeVRpbWVzW2ldO1xuICAgICAgaWYgKGV4cGlyZXNBdCA8PSBub3cpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXhwaXJ5VGltZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovKSB7XG4gICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkICYmIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykpIHtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiByZXF1ZXN0T3B0aW9ucy5yb29tSWQuc3RhcnRzV2l0aChyZXNvdXJjZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSkgfHwgcmVxdWVzdE9wdGlvbnMucm9vbUlkID09PSByZXNvdXJjZSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gYXV0aE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHdpbmRvdy5mZXRjaCk7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICBpZiAoZmV0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50IHdpdGggYSB1cmwgYXMgYXV0aCBlbmRwb2ludCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIGZldGNoIHBvbHlmaWxsLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXV0aEVuZHBvaW50KGZldGNoZXIsIGF1dGhlbnRpY2F0aW9uLnVybCwge1xuICAgICAgICByb29tOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICBpZiAoc2VlblRva2Vucy5oYXMocGFyc2VkLnJhdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRoZSBzYW1lIExpdmVibG9ja3MgYXV0aCB0b2tlbiB3YXMgaXNzdWVkIGZyb20gdGhlIGJhY2tlbmQgYmVmb3JlLiBDYWNoaW5nIExpdmVibG9ja3MgdG9rZW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcImN1c3RvbVwiKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0aW9uLmNhbGxiYWNrKG9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChyZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS50b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXV0aFRva2VuKHJlc3BvbnNlLnRva2VuKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5lcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7XCJyZWFzb25cIiBpbiByZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UucmVhc29uID09PSBcInN0cmluZ1wiID8gcmVzcG9uc2UucmVhc29uIDogXCJGb3JiaWRkZW5cIn1gO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvciA9PT0gXCJmb3JiaWRkZW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhyZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdXIgYXV0aGVudGljYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHRva2VuLCBidXQgaXQgZGlkIG5vdC4gSGludDogdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgbG9vayBsaWtlOiB7IHRva2VuOiBcIi4uLlwiIH0nXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVuZXhwZWN0ZWQgYXV0aGVudGljYXRpb24gdHlwZS4gTXVzdCBiZSBwcml2YXRlIG9yIGN1c3RvbS5cIlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFZhbHVlKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwicHVibGljXCIsIHB1YmxpY0FwaUtleTogYXV0aGVudGljYXRpb24ucHVibGljQXBpS2V5IH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFRva2VuID0gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpO1xuICAgIGlmIChjYWNoZWRUb2tlbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbjogY2FjaGVkVG9rZW4gfTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQcm9taXNlO1xuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KHJlcXVlc3RPcHRpb25zLnJvb21JZCwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIik7XG4gICAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIiwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjdXJyZW50UHJvbWlzZTtcbiAgICAgIGNvbnN0IEJVRkZFUiA9IDMwO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSArICh0b2tlbi5wYXJzZWQuZXhwIC0gdG9rZW4ucGFyc2VkLmlhdCkgLSBCVUZGRVI7XG4gICAgICBzZWVuVG9rZW5zLmFkZCh0b2tlbi5yYXcpO1xuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rICE9PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgZXhwaXJ5VGltZXMucHVzaChleHBpcmVzQXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW4gfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKHJlcXVlc3RPcHRpb25zLnJvb21JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc2V0LFxuICAgIGdldEF1dGhWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IHsgcHVibGljQXBpS2V5LCBhdXRoRW5kcG9pbnQgfSA9IGF1dGhPcHRpb25zO1xuICBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDAgJiYgcHVibGljQXBpS2V5ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgdXNlIGBwdWJsaWNBcGlLZXlgIGFuZCBgYXV0aEVuZHBvaW50YCBvcHRpb25zLiBQbGVhc2UgcGljayBvbmUgYW5kIGxlYXZlIHRoZSBvdGhlciBvcHRpb24gdW5zcGVjaWZpZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIHB1YmxpY0FwaUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgYHB1YmxpY0FwaUtleWAgb3B0aW9uLiBUaGUgdmFsdWUgeW91IHBhc3NlZCBpcyBhIHNlY3JldCBrZXksIHdoaWNoIHNob3VsZCBub3QgYmUgdXNlZCBmcm9tIHRoZSBjbGllbnQuIFBsZWFzZSBvbmx5IGV2ZXIgcGFzcyBhIHB1YmxpYyBrZXkgaGVyZS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghcHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJwa19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGtleS4gUGxlYXNlIHVzZSB0aGUgcHVibGljIGtleSBmb3JtYXQ6IHBrXzxwdWJsaWMga2V5Pi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInB1YmxpY1wiLFxuICAgICAgcHVibGljQXBpS2V5XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByaXZhdGVcIixcbiAgICAgIHVybDogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgIGNhbGxiYWNrOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgYGF1dGhFbmRwb2ludGAgb3B0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50QXV0aEVuZHBvaW50XCJcbiAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkludmFsaWQgTGl2ZWJsb2NrcyBjbGllbnQgb3B0aW9ucy4gUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHB1YmxpY0FwaUtleWAgb3IgYGF1dGhFbmRwb2ludGAgb3B0aW9uLiBUaGV5IGNhbm5vdCBib3RoIGJlIGVtcHR5LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2gsIGVuZHBvaW50LCBib2R5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgcmVhc29uID0gYCR7KGF3YWl0IHJlcy50ZXh0KCkpLnRyaW0oKSB8fCBcInJlYXNvbiBub3QgcHJvdmlkZWQgaW4gYXV0aCByZXNwb25zZVwifSAoJHtyZXMuc3RhdHVzfSByZXR1cm5lZCBieSBQT1NUICR7ZW5kcG9pbnR9KWA7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSB8fCByZXMuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoYFVuYXV0aG9yaXplZDogJHtyZWFzb259YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZTogJHtyZWFzb259YCk7XG4gICAgfVxuICB9XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIuICR7U3RyaW5nKFxuICAgICAgICBlclxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkgfHwgdHlwZW9mIGRhdGEudG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIG9mIHRoZSBmb3JtIFxcYHsgdG9rZW46IFwiLi4uXCIgfVxcYCB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIiwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBkYXRhXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRhdGE7XG4gIHJldHVybiB7IHRva2VuIH07XG59XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5saXZlYmxvY2tzLmlvXCI7XG5cbi8vIHNyYy9pbnRlcm5hbC50c1xudmFyIGtJbnRlcm5hbCA9IFN5bWJvbCgpO1xuXG4vLyBzcmMvZGV2dG9vbHMvYnJpZGdlLnRzXG52YXIgX2JyaWRnZUFjdGl2ZSA9IGZhbHNlO1xuZnVuY3Rpb24gYWN0aXZhdGVCcmlkZ2UoYWxsb3dlZCkge1xuICBfYnJpZGdlQWN0aXZlID0gYWxsb3dlZDtcbn1cbmZ1bmN0aW9uIHNlbmRUb1BhbmVsKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZ1bGxNc2cgPSB7XG4gICAgLi4ubWVzc2FnZSxcbiAgICBzb3VyY2U6IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1jbGllbnRcIlxuICB9O1xuICBpZiAoIShvcHRpb25zPy5mb3JjZSB8fCBfYnJpZGdlQWN0aXZlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cucG9zdE1lc3NhZ2UoZnVsbE1zZywgXCIqXCIpO1xufVxudmFyIGV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhPy5zb3VyY2UgPT09IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1wYW5lbFwiKSB7XG4gICAgICBldmVudFNvdXJjZS5ub3RpZnkoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9uTWVzc2FnZUZyb21QYW5lbCA9IGV2ZW50U291cmNlLm9ic2VydmFibGU7XG5cbi8vIHNyYy9kZXZ0b29scy9pbmRleC50c1xudmFyIFZFUlNJT04gPSBQS0dfVkVSU0lPTiB8fCBcImRldlwiO1xudmFyIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cERldlRvb2xzKGdldEFsbFJvb21zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoX2RldnRvb2xzU2V0dXBIYXNSdW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSB0cnVlO1xuICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgIGNhc2UgXCJjb25uZWN0XCI6IHtcbiAgICAgICAgYWN0aXZhdGVCcmlkZ2UodHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIGdldEFsbFJvb21zKCkpIHtcbiAgICAgICAgICBzZW5kVG9QYW5lbCh7XG4gICAgICAgICAgICBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiBWRVJTSU9OXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwid2FrZS11cC1kZXZ0b29sc1wiIH0sIHsgZm9yY2U6IHRydWUgfSk7XG59XG52YXIgdW5zdWJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFN5bmNTdHJlYW0ocm9vbUlkKSB7XG4gIGNvbnN0IHVuc3VicyA9IHVuc3Vic0J5Um9vbUlkLmdldChyb29tSWQpID8/IFtdO1xuICB1bnN1YnNCeVJvb21JZC5kZWxldGUocm9vbUlkKTtcbiAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICB1bnN1YigpO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFN5bmNTdHJlYW0ocm9vbSkge1xuICBzdG9wU3luY1N0cmVhbShyb29tLmlkKTtcbiAgZnVsbFN5bmMocm9vbSk7XG4gIHVuc3Vic0J5Um9vbUlkLnNldChyb29tLmlkLCBbXG4gICAgLy8gV2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pKSxcbiAgICAvLyBXaGVuIHN0b3JhZ2UgaW5pdGlhbGl6ZXMsIHNlbmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBzdG9yYWdlIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyBzdG9yYWdlIHJvb3RcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgXCJtZVwiIG9yIFwib3RoZXJzXCIgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHZhbHVlcyBhY2NvcmRpbmdseVxuICAgIHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jTWUocm9vbSkpLFxuICAgIHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHlkb2MgaXMgdXBkYXRlZCwgZm9yd2FyZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMueWRvYy5zdWJzY3JpYmUoKHVwZGF0ZSkgPT4gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSksXG4gICAgLy8gQW55IHRpbWUgYSBjdXN0b20gcm9vbSBldmVudCBpcyByZWNlaXZlZCwgZm9yd2FyZCBpdFxuICAgIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChldmVudERhdGEpID0+IGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpXG4gICAgKVxuICBdKTtcbn1cbmZ1bmN0aW9uIHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6Onlkb2NcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgdXBkYXRlXG4gIH0pO1xufVxudmFyIGxvYWRlZEF0ID0gRGF0ZS5ub3coKTtcbnZhciBldmVudENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbmV4dEV2ZW50SWQoKSB7XG4gIHJldHVybiBgZXZlbnQtJHtsb2FkZWRBdH0tJHtldmVudENvdW50ZXIrK31gO1xufVxuZnVuY3Rpb24gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OmV2ZW50czo6Y3VzdG9tLWV2ZW50XCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBcIkN1c3RvbUV2ZW50XCIsXG4gICAgICBpZDogbmV4dEV2ZW50SWQoKSxcbiAgICAgIGtleTogXCJFdmVudFwiLFxuICAgICAgY29ubmVjdGlvbklkOiBldmVudERhdGEuY29ubmVjdGlvbklkLFxuICAgICAgcGF5bG9hZDogZXZlbnREYXRhLmV2ZW50XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKClcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgaWYgKHJvb3QpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgc3RvcmFnZTogcm9vdC50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jTWUocm9vbSkge1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGlmIChtZSkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBtZVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY090aGVycyhyb29tKSB7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG90aGVycykge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBvdGhlcnNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZnVsbFN5bmMocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgY29uc3QgbWUgPSByb29tW2tJbnRlcm5hbF0uZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBjb25zdCBvdGhlcnMgPSByb29tW2tJbnRlcm5hbF0uZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIHJvb20uZmV0Y2hZRG9jKFwiXCIpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OmZ1bGxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpLFxuICAgIHN0b3JhZ2U6IHJvb3Q/LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWQgPz8gbnVsbCxcbiAgICBtZSxcbiAgICBvdGhlcnNcbiAgfSk7XG59XG52YXIgcm9vbUNoYW5uZWxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZ2V0KHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLmRlbGV0ZShyb29tSWQpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBsaW5rRGV2VG9vbHMocm9vbUlkLCByb29tKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJyb29tOjphdmFpbGFibGVcIiwgcm9vbUlkLCBjbGllbnRWZXJzaW9uOiBWRVJTSU9OIH0pO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5zZXQoXG4gICAgcm9vbUlkLFxuICAgIC8vIFJldHVybnMgdGhlIHVuc3Vic2NyaWJlIGNhbGxiYWNrLCB0aGF0IHdlIHN0b3JlIGluIHRoZVxuICAgIC8vIHJvb21DaGFubmVsTGlzdGVuZXJzIHJlZ2lzdHJ5XG4gICAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgICAgY2FzZSBcInJvb206OnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RhcnRTeW5jU3RyZWFtKHJvb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicm9vbTo6dW5zdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHVubGlua0RldlRvb2xzKHJvb21JZCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjp1bmF2YWlsYWJsZVwiLFxuICAgIHJvb21JZFxuICB9KTtcbn1cblxuLy8gc3JjL2xpYi9zdHJpbmdpZnkudHNcbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmplY3QsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgfHwgb2JqZWN0ID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmplY3QsIC4uLmFyZ3MpO1xuICB9XG4gIGNvbnN0IHNvcnRlZE9iamVjdCA9IE9iamVjdC5rZXlzKG9iamVjdCkuc29ydCgpLnJlZHVjZShcbiAgICAoc29ydGVkT2JqZWN0Miwga2V5KSA9PiB7XG4gICAgICBzb3J0ZWRPYmplY3QyW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgIHJldHVybiBzb3J0ZWRPYmplY3QyO1xuICAgIH0sXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNvcnRlZE9iamVjdCwgLi4uYXJncyk7XG59XG5cbi8vIHNyYy9saWIvYmF0Y2gudHNcbnZhciBERUZBVUxUX1NJWkUgPSA1MDtcbnZhciBCYXRjaENhbGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gIH1cbn07XG52YXIgQmF0Y2ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplID8/IERFRkFVTFRfU0laRTtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgfVxuICBjbGVhckRlbGF5VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5kZWxheVRpbWVvdXRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7XG4gICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBzY2hlZHVsZSgpIHtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IHRoaXMuc2l6ZSkge1xuICAgICAgdm9pZCB0aGlzLmZsdXNoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5jbGVhckRlbGF5VGltZW91dCgpO1xuICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gdm9pZCB0aGlzLmZsdXNoKCksIHRoaXMuZGVsYXkpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FsbHMgPSB0aGlzLnF1ZXVlLnNwbGljZSgwKTtcbiAgICBjb25zdCBpbnB1dHMgPSBjYWxscy5tYXAoKGNhbGwpID0+IGNhbGwuaW5wdXQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5jYWxsYmFjayhpbnB1dHMpO1xuICAgICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0cz8uW2luZGV4XTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QobmV3IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXkuXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxscy5sZW5ndGggIT09IHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBDYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG51bWJlciBvZiBwcm92aWRlZCBpdGVtcy4gRXhwZWN0ZWQgJHtjYWxscy5sZW5ndGh9LCBidXQgZ290ICR7cmVzdWx0cy5sZW5ndGh9LmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICB0aGlzLmVycm9yID0gdHJ1ZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICAgICAgY2FsbC5yZWplY3QoZXJyb3IzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQoaW5wdXQpIHtcbiAgICBjb25zdCBleGlzdGluZ0NhbGwgPSB0aGlzLnF1ZXVlLmZpbmQoXG4gICAgICAoY2FsbDIpID0+IHN0cmluZ2lmeShjYWxsMi5pbnB1dCkgPT09IHN0cmluZ2lmeShpbnB1dClcbiAgICApO1xuICAgIGlmIChleGlzdGluZ0NhbGwpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0NhbGwucHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgY2FsbCA9IG5ldyBCYXRjaENhbGwoaW5wdXQpO1xuICAgIHRoaXMucXVldWUucHVzaChjYWxsKTtcbiAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgcmV0dXJuIGNhbGwucHJvbWlzZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVvdXQoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2gpIHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBldmVudFNvdXJjZTIgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoYXJncykge1xuICAgIHJldHVybiBzdHJpbmdpZnkoYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHN0YXRlKSB7XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzdGF0ZSk7XG4gICAgZXZlbnRTb3VyY2UyLm5vdGlmeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGludmFsaWRhdGUoaW5wdXRzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRzKSkge1xuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgY2FjaGUuZGVsZXRlKGdldENhY2hlS2V5KGlucHV0KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIGV2ZW50U291cmNlMi5ub3RpZnkoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXQoaW5wdXQpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGlucHV0KTtcbiAgICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmF0Y2guZ2V0KGlucHV0KTtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IHJlc3VsdCB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvcjNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0ZShpbnB1dCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoaW5wdXQpO1xuICAgIHJldHVybiBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICB9XG4gIGZ1bmN0aW9uIF9jYWNoZUtleXMoKSB7XG4gICAgcmV0dXJuIFsuLi5jYWNoZS5rZXlzKCldO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnRTb3VyY2UyLm9ic2VydmFibGUsXG4gICAgZ2V0LFxuICAgIGdldFN0YXRlLFxuICAgIGludmFsaWRhdGUsXG4gICAgX2NhY2hlS2V5c1xuICB9O1xufVxuXG4vLyBzcmMvbGliL2NyZWF0ZS1zdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUoaW5pdGlhbFN0YXRlKSB7XG4gIGxldCBub3RpZnlJbW1lZGlhdGVseSA9IHRydWU7XG4gIGxldCBkaXJ0eSA9IGZhbHNlO1xuICBsZXQgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHN0YXRlO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY2FsbGJhY2sob2xkU3RhdGUpO1xuICAgIGlmIChuZXdTdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBkaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChub3RpZnlJbW1lZGlhdGVseSkge1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBpZiAoIWRpcnR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpcnR5ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVyKHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2goY2IpIHtcbiAgICBpZiAobm90aWZ5SW1tZWRpYXRlbHkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9XG4gICAgbm90aWZ5SW1tZWRpYXRlbHkgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgY2IoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbm90aWZ5SW1tZWRpYXRlbHkgPSB0cnVlO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIHN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgYmF0Y2gsXG4gICAgc3Vic2NyaWJlXG4gIH07XG59XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gIGNvbnN0IGNvbW1lbnRzID0gZGF0YS5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQsXG4gICAgdXBkYXRlZEF0LFxuICAgIGNvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoZGF0YSkge1xuICBjb25zdCBub3RpZmllZEF0ID0gbmV3IERhdGUoZGF0YS5ub3RpZmllZEF0KTtcbiAgY29uc3QgcmVhZEF0ID0gZGF0YS5yZWFkQXQgPyBuZXcgRGF0ZShkYXRhLnJlYWRBdCkgOiBudWxsO1xuICBpZiAoXCJhY3Rpdml0aWVzXCIgaW4gZGF0YSkge1xuICAgIGNvbnN0IGFjdGl2aXRpZXMgPSBkYXRhLmFjdGl2aXRpZXMubWFwKChhY3Rpdml0eSkgPT4gKHtcbiAgICAgIC4uLmFjdGl2aXR5LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShhY3Rpdml0eS5jcmVhdGVkQXQpXG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbm90aWZpZWRBdCxcbiAgICAgIHJlYWRBdCxcbiAgICAgIGFjdGl2aXRpZXNcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBub3RpZmllZEF0LFxuICAgIHJlYWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhkYXRhKSB7XG4gIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGRlbGV0ZWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5cbi8vIHNyYy9saWIvYXV0b1JldHJ5LnRzXG52YXIgSHR0cEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbnZhciBET05UX1JFVFJZXzRYWCA9ICh4KSA9PiB4IGluc3RhbmNlb2YgSHR0cEVycm9yICYmIHguc3RhdHVzID49IDQwMCAmJiB4LnN0YXR1cyA8IDUwMDtcbmFzeW5jIGZ1bmN0aW9uIGF1dG9SZXRyeShwcm9taXNlRm4sIG1heFRyaWVzLCBiYWNrb2ZmLCBzaG91bGRTdG9wUmV0cnlpbmcgPSBET05UX1JFVFJZXzRYWCkge1xuICBjb25zdCBmYWxsYmFja0JhY2tvZmYgPSBiYWNrb2ZmLmxlbmd0aCA+IDAgPyBiYWNrb2ZmW2JhY2tvZmYubGVuZ3RoIC0gMV0gOiAwO1xuICBsZXQgYXR0ZW1wdCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgYXR0ZW1wdCsrO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZUZuKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoc2hvdWxkU3RvcFJldHJ5aW5nKGVycikpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgaWYgKGF0dGVtcHQgPj0gbWF4VHJpZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgYWZ0ZXIgJHttYXhUcmllc30gYXR0ZW1wdHM6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gYmFja29mZlthdHRlbXB0IC0gMV0gPz8gZmFsbGJhY2tCYWNrb2ZmO1xuICAgIHdhcm4oXG4gICAgICBgQXR0ZW1wdCAke2F0dGVtcHR9IHdhcyB1bnN1Y2Nlc3NmdWwuIFJldHJ5aW5nIGluICR7ZGVsYXl9IG1pbGxpc2Vjb25kcy5gXG4gICAgKTtcbiAgICBhd2FpdCB3YWl0KGRlbGF5KTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3VybC50c1xuZnVuY3Rpb24gdG9VUkxTZWFyY2hQYXJhbXMocGFyYW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cmxqb2luKGJhc2VVcmwsIHBhdGgsIHBhcmFtcykge1xuICBjb25zdCB1cmwyID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKTtcbiAgaWYgKHBhcmFtcyAhPT0gdm9pZCAwKSB7XG4gICAgdXJsMi5zZWFyY2ggPSAocGFyYW1zIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID8gcGFyYW1zIDogdG9VUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdXJsMi50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gdXJsKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gc3RyaW5ncy5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgc3RyLCBpKSA9PiByZXN1bHQgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWVzW2kgLSAxXSA/PyBcIlwiKSArIHN0clxuICApO1xufVxuXG4vLyBzcmMvaHR0cC1jbGllbnQudHNcbmZ1bmN0aW9uIGdldEJlYXJlclRva2VuRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpIHtcbiAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS50b2tlbi5yYXc7XG4gIH1cbn1cbnZhciBIdHRwQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihiYXNlVXJsLCBmZXRjaFBvbHlmaWxsLCBhdXRoQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLl9mZXRjaFBvbHlmaWxsID0gZmV0Y2hQb2x5ZmlsbDtcbiAgICB0aGlzLl9hdXRoQ2FsbGJhY2sgPSBhdXRoQ2FsbGJhY2s7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFB1YmxpYyBtZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQ29uc3RydWN0cyBhbmQgbWFrZXMgdGhlIEhUVFAgcmVxdWVzdCwgYnV0IGRvZXMgbm90IGhhbmRsZSB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIFRoaXMgaXMgd2hhdCAucmF3RmV0Y2goKSBkb2VzOiAgICDwn5GIIFRoaXMgbWV0aG9kIVxuICAgKiAgIDEuIFNldCBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAqICAgMi4gU2V0IEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqICAgMy4gQ2FsbCB0aGUgY2FsbGJhY2sgdG8gb2J0YWluIHRoZSBgYXV0aFZhbHVlYCB0byB1c2UgaW4gdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqXG4gICAqIFRoaXMgaXMgd2hhdCAuZmV0Y2goKSBkb2VzIE9OIFRPUCBvZiB0aGF0OlxuICAgKiAgIDQuIFBhcnNlIHJlc3BvbnNlIGJvZHkgYXMgSnNvblxuICAgKiAgIDUuIC4uLmJ1dCBzaWxlbnRseSByZXR1cm4gYHt9YCBpZiB0aGF0IHBhcnNpbmcgZmFpbHNcbiAgICogICA2LiBUaHJvdyBIdHRwRXJyb3IgaWYgcmVzcG9uc2UgaXMgYW4gZXJyb3JcbiAgICovXG4gIGFzeW5jIHJhd0ZldGNoKGVuZHBvaW50LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICBpZiAoIWVuZHBvaW50LnN0YXJ0c1dpdGgoXCIvdjIvYy9cIikpIHtcbiAgICAgIHJhaXNlKFwiVGhpcyBjbGllbnQgY2FuIG9ubHkgYmUgdXNlZCB0byBtYWtlIC92Mi9jLyogcmVxdWVzdHNcIik7XG4gICAgfVxuICAgIGNvbnN0IHVybDIgPSB1cmxqb2luKHRoaXMuX2Jhc2VVcmwsIGVuZHBvaW50LCBwYXJhbXMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9mZXRjaFBvbHlmaWxsKHVybDIsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC8vIFRoZXNlIGhlYWRlcnMgYXJlIGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBoZWFkZXJzXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAvLyBQb3NzaWJsZSBoZWFkZXIgb3ZlcnJpZGVzXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIC8vIENhbm5vdCBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGhlYWRlcnNcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEJlYXJlclRva2VuRnJvbUF1dGhWYWx1ZShhd2FpdCB0aGlzLl9hdXRoQ2FsbGJhY2soKSl9YCxcbiAgICAgICAgXCJYLUxCLUNsaWVudFwiOiBQS0dfVkVSU0lPTiB8fCBcImRldlwiXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMsIG1ha2VzIHRoZSBIVFRQIHJlcXVlc3QsIGFuZCBoYW5kbGVzIHRoZSByZXNwb25zZSBieSBwYXJzaW5nXG4gICAqIEpTT04gYW5kL29yIHRocm93aW5nIGFuIEh0dHBFcnJvciBpZiBpdCBmYWlsZWQuXG4gICAqXG4gICAqIFRoaXMgaXMgd2hhdCAucmF3RmV0Y2goKSBkb2VzOlxuICAgKiAgIDEuIFNldCBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAqICAgMi4gU2V0IEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqICAgMy4gQ2FsbCB0aGUgY2FsbGJhY2sgdG8gb2J0YWluIHRoZSBgYXV0aFZhbHVlYCB0byB1c2UgaW4gdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqXG4gICAqIFRoaXMgaXMgd2hhdCAuZmV0Y2goKSBkb2VzIE9OIFRPUCBvZiB0aGF0OiAgIPCfkYggVGhpcyBtZXRob2QhXG4gICAqICAgNC4gUGFyc2UgcmVzcG9uc2UgYm9keSBhcyBKc29uXG4gICAqICAgNS4gLi4uYnV0IHNpbGVudGx5IHJldHVybiBge31gIGlmIHRoYXQgcGFyc2luZyBmYWlscyAo8J+klClcbiAgICogICA2LiBUaHJvdyBIdHRwRXJyb3IgaWYgcmVzcG9uc2UgaXMgYW4gZXJyb3JcbiAgICovXG4gIGFzeW5jIGZldGNoKGVuZHBvaW50LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmF3RmV0Y2goZW5kcG9pbnQsIG9wdGlvbnMsIHBhcmFtcyk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9yMztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgZXJyb3IzID0gbmV3IEh0dHBFcnJvcihlcnJvckJvZHkubWVzc2FnZSwgcmVzcG9uc2Uuc3RhdHVzLCBlcnJvckJvZHkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGVycm9yMyA9IG5ldyBIdHRwRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yMztcbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIEdFVCByZXF1ZXN0IGFuZCByZXR1cm5zIHRoZSByYXcgcmVzcG9uc2UuXG4gICAqIFdvbid0IHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICogQGRlcHJlY2F0ZWQgSWRlYWxseSwgdXNlIC5nZXQoKSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgcmF3R2V0KGVuZHBvaW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yYXdGZXRjaChlbmRwb2ludCwgb3B0aW9ucywgcGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBQT1NUIHJlcXVlc3QgYW5kIHJldHVybnMgdGhlIHJhdyByZXNwb25zZS5cbiAgICogV29uJ3QgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKiBAZGVwcmVjYXRlZCBJZGVhbGx5LCB1c2UgLnBvc3QoKSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgcmF3UG9zdChlbmRwb2ludCwgYm9keSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJhd0ZldGNoKGVuZHBvaW50LCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBERUxFVEUgcmVxdWVzdCBhbmQgcmV0dXJucyB0aGUgcmF3IHJlc3BvbnNlLlxuICAgKiBXb24ndCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqIEBkZXByZWNhdGVkIElkZWFsbHksIHVzZSAuZGVsZXRlKCkgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIHJhd0RlbGV0ZShlbmRwb2ludCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJhd0ZldGNoKGVuZHBvaW50LCB7IG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBHRVQgcmVxdWVzdCwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBnZXQoZW5kcG9pbnQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoKGVuZHBvaW50LCBvcHRpb25zLCBwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIFBPU1QgcmVxdWVzdCwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBwb3N0KGVuZHBvaW50LCBib2R5LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaChcbiAgICAgIGVuZHBvaW50LFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgICAgfSxcbiAgICAgIHBhcmFtc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgREVMRVRFIHJlcXVlc3QsIGFuZCByZXR1cm4gdGhlIEpTT04gcmVzcG9uc2UuXG4gICAqIFdpbGwgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKGVuZHBvaW50KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2goZW5kcG9pbnQsIHsgbWV0aG9kOiBcIkRFTEVURVwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIFBVVCByZXF1ZXN0IGZvciBhIEJsb2IgYm9keSwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBwdXRCbG9iKGVuZHBvaW50LCBibG9iLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaChcbiAgICAgIGVuZHBvaW50LFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGJsb2JcbiAgICAgIH0sXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvbm90aWZpY2F0aW9ucy50c1xuZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uc0FwaSh7XG4gIGJhc2VVcmwsXG4gIGF1dGhNYW5hZ2VyLFxuICBjdXJyZW50VXNlcklkU3RvcmUsXG4gIGZldGNoUG9seWZpbGxcbn0pIHtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFZhbHVlKCkge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCJcbiAgICB9KTtcbiAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIgJiYgYXV0aFZhbHVlLnRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgY29uc3QgdXNlcklkID0gYXV0aFZhbHVlLnRva2VuLnBhcnNlZC51aWQ7XG4gICAgICBjdXJyZW50VXNlcklkU3RvcmUuc2V0KCgpID0+IHVzZXJJZCk7XG4gICAgfVxuICAgIHJldHVybiBhdXRoVmFsdWU7XG4gIH1cbiAgY29uc3QgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50KGJhc2VVcmwsIGZldGNoUG9seWZpbGwsIGdldEF1dGhWYWx1ZSk7XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zYCwge1xuICAgICAgY3Vyc29yOiBvcHRpb25zPy5jdXJzb3IsXG4gICAgICBsaW1pdDogUEFHRV9TSVpFXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGFcbiAgICAgICksXG4gICAgICB0aHJlYWRzOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgbmV4dEN1cnNvcjoganNvbi5tZXRhLm5leHRDdXJzb3IsXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2Uob3B0aW9ucykge1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL2RlbHRhYCxcbiAgICAgIHsgc2luY2U6IG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKSB9LFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mb1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgdGhyZWFkczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCgpIHtcbiAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL2NvdW50YFxuICAgICk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRgLCB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbklkczogXCJhbGxcIlxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZHMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnBvc3QodXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRzXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiA1MCB9XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQuZ2V0KGluYm94Tm90aWZpY2F0aW9uSWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LmRlbGV0ZSh1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9uc2ApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LmRlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zLyR7aW5ib3hOb3RpZmljYXRpb25JZH1gXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucykge1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KHVybGAvdjIvYy90aHJlYWRzYCwge1xuICAgICAgY3Vyc29yOiBvcHRpb25zLmN1cnNvcixcbiAgICAgIHF1ZXJ5LFxuICAgICAgbGltaXQ6IFBBR0VfU0laRVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0aHJlYWRzOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YVxuICAgICAgKSxcbiAgICAgIG5leHRDdXJzb3I6IGpzb24ubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvdGhyZWFkcy9kZWx0YWAsXG4gICAgICB7IHNpbmNlOiBvcHRpb25zLnNpbmNlLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhyZWFkczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKVxuICAgICAgfSxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm9cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZSxcbiAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb24sXG4gICAgZ2V0VXNlclRocmVhZHNfZXhwZXJpbWVudGFsLFxuICAgIGdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsXG4gIH07XG59XG5cbi8vIHNyYy9saWIvcG9zaXRpb24udHNcbnZhciBNSU5fQ09ERSA9IDMyO1xudmFyIE1BWF9DT0RFID0gMTI2O1xudmFyIE5VTV9ESUdJVFMgPSBNQVhfQ09ERSAtIE1JTl9DT0RFICsgMTtcbnZhciBaRVJPID0gbnRoRGlnaXQoMCk7XG52YXIgT05FID0gbnRoRGlnaXQoMSk7XG52YXIgWkVST19OSU5FID0gWkVSTyArIG50aERpZ2l0KC0xKTtcbmZ1bmN0aW9uIG50aERpZ2l0KG4pIHtcbiAgY29uc3QgY29kZSA9IE1JTl9DT0RFICsgKG4gPCAwID8gTlVNX0RJR0lUUyArIG4gOiBuKTtcbiAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbiB2YWx1ZTogJHtufWApO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xufVxuZnVuY3Rpb24gbWFrZVBvc2l0aW9uKHgsIHkpIHtcbiAgaWYgKHggIT09IHZvaWQgMCAmJiB5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmV0d2Vlbih4LCB5KTtcbiAgfSBlbHNlIGlmICh4ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYWZ0ZXIoeCk7XG4gIH0gZWxzZSBpZiAoeSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJlZm9yZSh5KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT05FO1xuICB9XG59XG5mdW5jdGlvbiBiZWZvcmUocG9zKSB7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHBvcy5sZW5ndGggLSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBsYXN0SW5kZXg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBwb3MuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8PSBNSU5fQ09ERSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpID09PSBsYXN0SW5kZXgpIHtcbiAgICAgIGlmIChjb2RlID09PSBNSU5fQ09ERSArIDEpIHtcbiAgICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBaRVJPX05JTkU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpICsgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPTkU7XG59XG5mdW5jdGlvbiBhZnRlcihwb3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcG9zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBwb3MuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA+PSBNQVhfQ09ERSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlICsgMSk7XG4gIH1cbiAgcmV0dXJuIHBvcyArIE9ORTtcbn1cbmZ1bmN0aW9uIGJldHdlZW4obG8sIGhpKSB7XG4gIGlmIChsbyA8IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGxvLCBoaSk7XG4gIH0gZWxzZSBpZiAobG8gPiBoaSkge1xuICAgIHJldHVybiBfYmV0d2VlbihoaSwgbG8pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIHZhbHVlIGJldHdlZW4gdHdvIGVxdWFsIHBvc2l0aW9uc1wiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2JldHdlZW4obG8sIGhpKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IGxvTGVuID0gbG8ubGVuZ3RoO1xuICBjb25zdCBoaUxlbiA9IGhpLmxlbmd0aDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBsb0NvZGUgPSBpbmRleCA8IGxvTGVuID8gbG8uY2hhckNvZGVBdChpbmRleCkgOiBNSU5fQ09ERTtcbiAgICBjb25zdCBoaUNvZGUgPSBpbmRleCA8IGhpTGVuID8gaGkuY2hhckNvZGVBdChpbmRleCkgOiBNQVhfQ09ERTtcbiAgICBpZiAobG9Db2RlID09PSBoaUNvZGUpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGhpQ29kZSAtIGxvQ29kZSA9PT0gMSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IGluZGV4ICsgMTtcbiAgICAgIGxldCBwcmVmaXggPSBsby5zdWJzdHJpbmcoMCwgc2l6ZSk7XG4gICAgICBpZiAocHJlZml4Lmxlbmd0aCA8IHNpemUpIHtcbiAgICAgICAgcHJlZml4ICs9IFpFUk8ucmVwZWF0KHNpemUgLSBwcmVmaXgubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1ZmZpeCA9IGxvLnN1YnN0cmluZyhzaXplKTtcbiAgICAgIGNvbnN0IG5pbmVzID0gXCJcIjtcbiAgICAgIHJldHVybiBwcmVmaXggKyBfYmV0d2VlbihzdWZmaXgsIG5pbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRha2VOKGxvLCBpbmRleCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpQ29kZSArIGxvQ29kZSA+PiAxKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRha2VOKHBvcywgbikge1xuICByZXR1cm4gbiA8IHBvcy5sZW5ndGggPyBwb3Muc3Vic3RyaW5nKDAsIG4pIDogcG9zICsgWkVSTy5yZXBlYXQobiAtIHBvcy5sZW5ndGgpO1xufVxudmFyIE1JTl9OT05fWkVST19DT0RFID0gTUlOX0NPREUgKyAxO1xuZnVuY3Rpb24gaXNQb3Moc3RyKSB7XG4gIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGFzdElkeCA9IHN0ci5sZW5ndGggLSAxO1xuICBjb25zdCBsYXN0ID0gc3RyLmNoYXJDb2RlQXQobGFzdElkeCk7XG4gIGlmIChsYXN0IDwgTUlOX05PTl9aRVJPX0NPREUgfHwgbGFzdCA+IE1BWF9DT0RFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdElkeDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDwgTUlOX0NPREUgfHwgY29kZSA+IE1BWF9DT0RFKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY29udmVydFRvUG9zKHN0cikge1xuICBjb25zdCBjb2RlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBjb2Rlcy5wdXNoKGNvZGUgPCBNSU5fQ09ERSA/IE1JTl9DT0RFIDogY29kZSA+IE1BWF9DT0RFID8gTUFYX0NPREUgOiBjb2RlKTtcbiAgfVxuICB3aGlsZSAoY29kZXMubGVuZ3RoID4gMCAmJiBjb2Rlc1tjb2Rlcy5sZW5ndGggLSAxXSA9PT0gTUlOX0NPREUpIHtcbiAgICBjb2Rlcy5sZW5ndGgtLTtcbiAgfVxuICByZXR1cm4gY29kZXMubGVuZ3RoID4gMCA/IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uY29kZXMpIDogKFxuICAgIC8vIEVkZ2UgY2FzZTogdGhlIHN0ciB3YXMgYSAwLW9ubHkgc3RyaW5nLCB3aGljaCBpcyBpbnZhbGlkLiBEZWZhdWx0IGJhY2sgdG8gLjFcbiAgICBPTkVcbiAgKTtcbn1cbmZ1bmN0aW9uIGFzUG9zKHN0cikge1xuICByZXR1cm4gaXNQb3Moc3RyKSA/IHN0ciA6IGNvbnZlcnRUb1BvcyhzdHIpO1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvT3AudHNcbnZhciBPcENvZGUgPSAvKiBAX19QVVJFX18gKi8gKChPcENvZGUyKSA9PiB7XG4gIE9wQ29kZTJbT3BDb2RlMltcIklOSVRcIl0gPSAwXSA9IFwiSU5JVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJTRVRfUEFSRU5UX0tFWVwiXSA9IDFdID0gXCJTRVRfUEFSRU5UX0tFWVwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfTElTVFwiXSA9IDJdID0gXCJDUkVBVEVfTElTVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJVUERBVEVfT0JKRUNUXCJdID0gM10gPSBcIlVQREFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX09CSkVDVFwiXSA9IDRdID0gXCJDUkVBVEVfT0JKRUNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkRFTEVURV9DUkRUXCJdID0gNV0gPSBcIkRFTEVURV9DUkRUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkRFTEVURV9PQkpFQ1RfS0VZXCJdID0gNl0gPSBcIkRFTEVURV9PQkpFQ1RfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9NQVBcIl0gPSA3XSA9IFwiQ1JFQVRFX01BUFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfUkVHSVNURVJcIl0gPSA4XSA9IFwiQ1JFQVRFX1JFR0lTVEVSXCI7XG4gIHJldHVybiBPcENvZGUyO1xufSkoT3BDb2RlIHx8IHt9KTtcbmZ1bmN0aW9uIGFja09wKG9wSWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgIGlkOiBcIkFDS1wiLFxuICAgIC8vIChIKUFDS1xuICAgIG9wSWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWNrT3Aob3ApIHtcbiAgcmV0dXJuIG9wLnR5cGUgPT09IDUgLyogREVMRVRFX0NSRFQgKi8gJiYgb3AuaWQgPT09IFwiQUNLXCI7XG59XG5cbi8vIHNyYy9jcmR0cy9BYnN0cmFjdENyZHQudHNcbmZ1bmN0aW9uIGNyZHRBc0xpdmVOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIEhhc1BhcmVudChub2RlLCBrZXksIHBvcyA9IGFzUG9zKGtleSkpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyB0eXBlOiBcIkhhc1BhcmVudFwiLCBub2RlLCBrZXksIHBvcyB9KTtcbn1cbnZhciBOb1BhcmVudCA9IE9iamVjdC5mcmVlemUoeyB0eXBlOiBcIk5vUGFyZW50XCIgfSk7XG5mdW5jdGlvbiBPcnBoYW5lZChvbGRLZXksIG9sZFBvcyA9IGFzUG9zKG9sZEtleSkpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyB0eXBlOiBcIk9ycGhhbmVkXCIsIG9sZEtleSwgb2xkUG9zIH0pO1xufVxudmFyIEFic3RyYWN0Q3JkdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3BhcmVudCA9IE5vUGFyZW50O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFBhcmVudEtleU9yVGhyb3coKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5rZXk7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3BhcmVudFBvcygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnBvcztcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZFBvcztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcG9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3Bvb2w7XG4gIH1cbiAgZ2V0IHJvb21JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3Bvb2wgPyB0aGlzLl9fcG9vbC5yb29tSWQgOiBudWxsO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9pZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2lkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRLZXkoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5rZXk7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgX2lzTG9jYWwpIHtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2RlLl9kZXRhY2hDaGlsZChjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldFBhcmVudExpbmsobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5ub2RlICE9PSBuZXdQYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwYXJlbnQ6IG5vZGUgYWxyZWFkeSBoYXMgYSBwYXJlbnRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX19pZCB8fCB0aGlzLl9fcG9vbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGF0dGFjaCBub2RlOiBhbHJlYWR5IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBwb29sLmFkZE5vZGUoaWQsIGNyZHRBc0xpdmVOb2RlKHRoaXMpKTtcbiAgICB0aGlzLl9faWQgPSBpZDtcbiAgICB0aGlzLl9fcG9vbCA9IHBvb2w7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIGlmICh0aGlzLl9fcG9vbCAmJiB0aGlzLl9faWQpIHtcbiAgICAgIHRoaXMuX19wb29sLmRlbGV0ZU5vZGUodGhpcy5fX2lkKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gT3JwaGFuZWQodGhpcy5wYXJlbnQua2V5LCB0aGlzLnBhcmVudC5wb3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IE5vUGFyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5fX3Bvb2wgPSB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBDbGVhciB0aGUgSW1tdXRhYmxlIGNhY2hlLCBzbyB0aGF0IHRoZSBuZXh0IGNhbGwgdG8gYC50b0ltbXV0YWJsZSgpYCB3aWxsXG4gICAqIHJlY29tcHV0ZSB0aGUgZXF1aXZhbGVudCBJbW11dGFibGUgdmFsdWUgYWdhaW4uICBDYWxsIHRoaXMgYWZ0ZXIgZXZlcnlcbiAgICogbXV0YXRpb24gdG8gdGhlIExpdmUgbm9kZS5cbiAgICovXG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZEltbXV0YWJsZSAhPT0gdm9pZCAwIHx8IHRoaXMuX2NhY2hlZFRyZWVOb2RlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlZEltbXV0YWJsZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2NhY2hlZFRyZWVOb2RlID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm9kZS5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogUmV0dXJuIGFuIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSB0cmVlIGZvciB1c2UgaW4gRGV2VG9vbHMuXG4gICAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRUcmVlTm9kZSA9PT0gdm9pZCAwIHx8IHRoaXMuX2NhY2hlZFRyZWVOb2RlS2V5ICE9PSBrZXkpIHtcbiAgICAgIHRoaXMuX2NhY2hlZFRyZWVOb2RlS2V5ID0ga2V5O1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGUgPSB0aGlzLl90b1RyZWVOb2RlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRUcmVlTm9kZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIGltbXV0YWJsZSBzbmFwc2hvdCBvZiB0aGlzIExpdmUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZEltbXV0YWJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZWRJbW11dGFibGUgPSB0aGlzLl90b0ltbXV0YWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkSW1tdXRhYmxlO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvU2VyaWFsaXplZENyZHQudHNcbnZhciBDcmR0VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENyZHRUeXBlMikgPT4ge1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiT0JKRUNUXCJdID0gMF0gPSBcIk9CSkVDVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTElTVFwiXSA9IDFdID0gXCJMSVNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJNQVBcIl0gPSAyXSA9IFwiTUFQXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJSRUdJU1RFUlwiXSA9IDNdID0gXCJSRUdJU1RFUlwiO1xuICByZXR1cm4gQ3JkdFR5cGUyO1xufSkoQ3JkdFR5cGUgfHwge30pO1xuZnVuY3Rpb24gaXNSb290Q3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnR5cGUgPT09IDAgLyogT0JKRUNUICovICYmICFpc0NoaWxkQ3JkdChjcmR0KTtcbn1cbmZ1bmN0aW9uIGlzQ2hpbGRDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQucGFyZW50SWQgIT09IHZvaWQgMCAmJiBjcmR0LnBhcmVudEtleSAhPT0gdm9pZCAwO1xufVxuXG4vLyBzcmMvbGliL25hbm9pZC50c1xudmFyIG5hbm9pZCA9ICh0ID0gMjEpID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkodCkpLnJlZHVjZShcbiAgKHQyLCBlKSA9PiB0MiArPSAoZSAmPSA2MykgPCAzNiA/IGUudG9TdHJpbmcoMzYpIDogZSA8IDYyID8gKGUgLSAyNikudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCkgOiBlIDwgNjMgPyBcIl9cIiA6IFwiLVwiLFxuICBcIlwiXG4pO1xuXG4vLyBzcmMvY3JkdHMvTGl2ZVJlZ2lzdGVyLnRzXG52YXIgTGl2ZVJlZ2lzdGVyID0gY2xhc3MgX0xpdmVSZWdpc3RlciBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBfcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gbmV3IF9MaXZlUmVnaXN0ZXIoaXRlbS5kYXRhKTtcbiAgICByZWdpc3Rlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICByZXR1cm4gcmVnaXN0ZXI7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHNlcmlhbGl6ZSByZWdpc3RlciBpZiBwYXJlbnRJZCBvciBwYXJlbnRLZXkgaXMgdW5kZWZpbmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IDggLyogQ1JFQVRFX1JFR0lTVEVSICovLFxuICAgICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlUmVnaXN0ZXIgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAzIC8qIFJFR0lTVEVSICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQoX29wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoX2NyZHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSnNvblwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy5fZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGlzLmRhdGEpO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvTGl2ZUxpc3QudHNcbmZ1bmN0aW9uIGNvbXBhcmVOb2RlUG9zaXRpb24oaXRlbUEsIGl0ZW1CKSB7XG4gIGNvbnN0IHBvc0EgPSBpdGVtQS5fcGFyZW50UG9zO1xuICBjb25zdCBwb3NCID0gaXRlbUIuX3BhcmVudFBvcztcbiAgcmV0dXJuIHBvc0EgPT09IHBvc0IgPyAwIDogcG9zQSA8IHBvc0IgPyAtMSA6IDE7XG59XG52YXIgTGl2ZUxpc3QgPSBjbGFzcyBfTGl2ZUxpc3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcG9zaXRpb24gPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld1Bvc2l0aW9uKTtcbiAgICAgIHRoaXMuX2l0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpc3QgPSBuZXcgX0xpdmVMaXN0KFtdKTtcbiAgICBsaXN0Ll9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXN0LCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBsaXN0Ll9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgcmVzdWx0aW5nIG9wcyB3aWxsIGJlIHNlbnQgdG8gdGhlIHNlcnZlciBpZiB0aGV5IGhhdmUgYW4gJ29wSWQnXG4gICAqIHNvIHdlIG11dGF0ZSBfdW5hY2tub3dsZWRnZWRTZXRzIHRvIGF2b2lkIHBvdGVudGlhbCBmbGlja2VyaW5nXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZlYmxvY2tzL2xpdmVibG9ja3MvcHVsbC8xMTc3XG4gICAqXG4gICAqIFRoaXMgaXMgcXVpdGUgdW5pbnR1aXRpdmUgYW5kIHNob3VsZCBkaXNhcHBlYXIgYXMgc29vbiBhc1xuICAgKiB3ZSBpbnRyb2R1Y2UgYW4gZXhwbGljaXQgTGl2ZUxpc3QuU2V0IG9wZXJhdGlvblxuICAgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgY29uc3QgcGFyZW50S2V5MiA9IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICAgIGNvbnN0IGNoaWxkT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIHBhcmVudEtleTIsIHBvb2wpLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBjb25zdCBjaGlsZE9wSWQgPSBjaGlsZE9wc1swXS5vcElkO1xuICAgICAgaWYgKGNoaWxkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocGFyZW50S2V5MiwgY2hpbGRPcElkKTtcbiAgICAgIH1cbiAgICAgIG9wcy5wdXNoKC4uLmNoaWxkT3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEFkZHMgYSBuZXcgaXRlbSBpbnRvIHRoZSBzb3J0ZWQgbGlzdCwgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24uXG4gICAqL1xuICBfaW5zZXJ0QW5kU29ydChpdGVtKSB7XG4gICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zb3J0SXRlbXMoKSB7XG4gICAgdGhpcy5faXRlbXMuc29ydChjb21wYXJlTm9kZVBvc2l0aW9uKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9pbmRleE9mUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMuZmluZEluZGV4KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSA9PT0gcG9zaXRpb25cbiAgICApO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgaXRlbS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldFJlbW90ZShvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IGRlbGV0ZWRJZCA9IG9wLmRlbGV0ZWRJZDtcbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgY29uc3QgaXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dO1xuICAgICAgaWYgKGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9pZCA9PT0gZGVsZXRlZElkKSB7XG4gICAgICAgIGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9kZXRhY2goKTtcbiAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIHNldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuYWRkKGl0ZW1XaXRoU2FtZVBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICBjb25zdCBkZWx0YSA9IFtcbiAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRlbGV0ZURlbHRhMiA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChkZWxldGVEZWx0YTIpIHtcbiAgICAgICAgdXBkYXRlcy5wdXNoKGRlbGV0ZURlbHRhMik7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHVwZGF0ZXMucHVzaChpbnNlcnREZWx0YSh0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KSwgY2hpbGQpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldmVyc2U6IFtdLFxuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVzKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRBY2sob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgfVxuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BJZCA9IHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5nZXQob3AucGFyZW50S2V5KTtcbiAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh1bmFja25vd2xlZGdlZE9wSWQgIT09IG9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmxlbmd0aCA9PT0gMCA/IHsgbW9kaWZpZWQ6IGZhbHNlIH0gOiB7IG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSwgcmV2ZXJzZTogW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5kZWxldGUob3AucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5faXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0gb3AucGFyZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChcbiAgICAgICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IFtwcmV2Tm9kZV0gPSB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIHByZXZOb2RlKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZJbmRleCkge1xuICAgICAgICBkZWx0YS5wdXNoKG1vdmVEZWx0YShwcmV2SW5kZXgsIG5ld0luZGV4LCBleGlzdGluZ0l0ZW0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9ycGhhbiA9IHRoaXMuX3Bvb2wuZ2V0Tm9kZShvcC5pZCk7XG4gICAgICBpZiAob3JwaGFuICYmIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKG9ycGhhbikpIHtcbiAgICAgICAgb3JwaGFuLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG9wLnBhcmVudEtleSk7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKG9ycGhhbik7XG4gICAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQob3JwaGFuKTtcbiAgICAgICAgY29uc3QgcmVjcmVhdGVkSXRlbUluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihvcnBoYW4pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEocmVjcmVhdGVkSXRlbUluZGV4LCBvcnBoYW4pIDogc2V0RGVsdGEocmVjcmVhdGVkSXRlbUluZGV4LCBvcnBoYW4pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLl9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChcbiAgICAgICAgICBvcCxcbiAgICAgICAgICBvcC5wYXJlbnRLZXlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIGF0IHRoaXMgcG9zaXRpb24sIHVwZGF0ZSBpcyBhIHNldCwgZWxzZSBpdCdzIGFuIGluc2VydFxuICAgICAgICAgICAgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID09PSAtMSA/IGluc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKSA6IHNldERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKSxcbiAgICAgICAgICAgIC4uLmRlbHRhXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVwZGF0ZSBkZWx0YSBvZiB0aGUgZGVsZXRpb24gb3IgbnVsbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKGRlbGV0ZWRJZCkge1xuICAgIGlmIChkZWxldGVkSWQgPT09IHZvaWQgMCB8fCB0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZWxldGVkSXRlbSA9IHRoaXMuX3Bvb2wuZ2V0Tm9kZShkZWxldGVkSWQpO1xuICAgIGlmIChkZWxldGVkSXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGV0YWNoQ2hpbGQoZGVsZXRlZEl0ZW0pO1xuICAgIGlmIChyZXN1bHQubW9kaWZpZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5tb2RpZmllZC51cGRhdGVzWzBdO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5UmVtb3RlSW5zZXJ0KG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYXNQb3Mob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX3NoaWZ0SXRlbVBvc2l0aW9uKGV4aXN0aW5nSXRlbUluZGV4LCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLl9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKV0pLFxuICAgICAgcmV2ZXJzZTogW11cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5SW5zZXJ0QWNrKG9wKSB7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5faXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGl0ZW1JbmRleEF0UG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2xkUG9zaXRpb25JbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgICAgaWYgKGl0ZW1JbmRleEF0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oaXRlbUluZGV4QXRQb3NpdGlvbiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gb2xkUG9zaXRpb25JbmRleCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgbW92ZURlbHRhKG9sZFBvc2l0aW9uSW5kZXgsIG5ld0luZGV4LCBleGlzdGluZ0l0ZW0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gbm4odGhpcy5fcG9vbCkuZ2V0Tm9kZShvcC5pZCk7XG4gICAgICBpZiAob3JwaGFuICYmIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKG9ycGhhbikpIHtcbiAgICAgICAgb3JwaGFuLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKG9ycGhhbik7XG4gICAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQob3JwaGFuKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG9ycGhhbildKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW1JbmRleEF0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oaXRlbUluZGV4QXRQb3NpdGlvbiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLl9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlJbnNlcnRVbmRvUmVkbyhvcCkge1xuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbD8uZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNoaWxkLl9hdHRhY2goaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgbGV0IG5ld0tleSA9IGtleTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBiZWZvcmUyID0gdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdPy5fcGFyZW50UG9zO1xuICAgICAgY29uc3QgYWZ0ZXIyID0gdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcztcbiAgICAgIG5ld0tleSA9IG1ha2VQb3NpdGlvbihiZWZvcmUyLCBhZnRlcjIpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICB9XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lS2V5ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lS2V5ICE9PSAtMSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZUtleV07XG4gICAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZUtleV0gPSBjaGlsZDtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb3AuaWRcbiAgICAgICk7XG4gICAgICBjb25zdCBkZWx0YSA9IFtzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lS2V5LCBjaGlsZCldO1xuICAgICAgY29uc3QgZGVsZXRlZERlbHRhID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICApO1xuICAgICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihvcC5kZWxldGVkSWQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldmVyc2U6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAob3AuaW50ZW50ID09PSBcInNldFwiKSB7XG4gICAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldFJlbW90ZShvcCk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlTZXRBY2sob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlTZXRVbmRvUmVkbyhvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5UmVtb3RlSW5zZXJ0KG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseUluc2VydEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseUluc2VydFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMobm4odGhpcy5faWQpLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgY29uc3QgaW5kZXhUb0RlbGV0ZSA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKGluZGV4VG9EZWxldGUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBbcHJldmlvdXNOb2RlXSA9IHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUsIHByZXZpb3VzTm9kZSldKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKSB7XG4gICAgaWYgKHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0tleSA9IGNoaWxkLl9wYXJlbnRLZXk7XG4gICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlBY2sobmV3S2V5LCBjaGlsZCkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgaWYgKHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgfVxuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICBpZDogbm4oY2hpbGQuX2lkKSxcbiAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzS2V5XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldENoaWxkS2V5KG5ld0tleSwgY2hpbGQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTGlzdCBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMuXG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHB1c2goZWxlbWVudCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGVsZW1lbnQsIHRoaXMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBvbmUgZWxlbWVudCBhdCBhIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHlvdSB3YW50IHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICovXG4gIGluc2VydChlbGVtZW50LCBpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGluc2VydCBsaXN0IGl0ZW0gYXQgaW5kZXggXCJcdTAwMWQke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuX2l0ZW1zLmxlbmd0aH1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmUyID0gdGhpcy5faXRlbXNbaW5kZXggLSAxXSA/IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tpbmRleF0gPyB0aGlzLl9pdGVtc1tpbmRleF0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmUyLCBhZnRlcjIpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoZWxlbWVudCk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2luc2VydEFuZFNvcnQodmFsdWUpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKGluZGV4LCB2YWx1ZSldKV1cbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNb3ZlIG9uZSBlbGVtZW50IGZyb20gb25lIGluZGV4IHRvIGFub3RoZXIuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gbW92ZVxuICAgKiBAcGFyYW0gdGFyZ2V0SW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZnRlciBtb3ZpbmcuXG4gICAqL1xuICBtb3ZlKGluZGV4LCB0YXJnZXRJbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBjYW5ub3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBsaXN0IGxlbmd0aFwiKTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZVBvc2l0aW9uID0gbnVsbDtcbiAgICBsZXQgYWZ0ZXJQb3NpdGlvbiA9IG51bGw7XG4gICAgaWYgKGluZGV4IDwgdGFyZ2V0SW5kZXgpIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0YXJnZXRJbmRleCA9PT0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSA/IHZvaWQgMCA6IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4ICsgMV0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleF0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IDAgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCAtIDFdLl9wYXJlbnRQb3M7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKGJlZm9yZVBvc2l0aW9uLCBhZnRlclBvc2l0aW9uKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IHByZXZpb3VzUG9zaXRpb24gPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShpbmRleCwgdGFyZ2V0SW5kZXgsIGl0ZW0pXSldXG4gICAgICBdKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgICAgaWQ6IG5uKGl0ZW0uX2lkKSxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHBvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzUG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBkZWxldGUgbGlzdCBpdGVtIGF0IGluZGV4IFwiJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgY29uc3QgW3ByZXZdID0gdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgY29uc3QgY2hpbGRSZWNvcmRJZCA9IGl0ZW0uX2lkO1xuICAgICAgaWYgKGNoaWxkUmVjb3JkSWQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBzdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgbm4odGhpcy5faWQpLFxuICAgICAgICAgIG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4LCBwcmV2KV0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDogY2hpbGRSZWNvcmRJZCxcbiAgICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpLFxuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgICAgY29uc3QgdXBkYXRlRGVsdGEgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICAgICAgY29uc3QgY2hpbGRJZCA9IGl0ZW0uX2lkO1xuICAgICAgICBpZiAoY2hpbGRJZCkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogY2hpbGRJZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXZlcnNlT3BzLnB1c2goXG4gICAgICAgICAgICAuLi5pdGVtLl90b09wcyhubih0aGlzLl9pZCksIGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHVwZGF0ZURlbHRhLnB1c2goZGVsZXRlRGVsdGEoMCwgaXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQobm4odGhpcy5faWQpLCBtYWtlVXBkYXRlKHRoaXMsIHVwZGF0ZURlbHRhKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG4gIHNldChpbmRleCwgaXRlbSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGV4aXN0aW5nSXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGNvbnN0IGV4aXN0aW5nSWQgPSBleGlzdGluZ0l0ZW0uX2lkO1xuICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgY29uc3QgdmFsdWUgPSBsc29uVG9MaXZlTm9kZShpdGVtKTtcbiAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5faXRlbXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICB2YWx1ZS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbc2V0RGVsdGEoaW5kZXgsIHZhbHVlKV0pKTtcbiAgICAgIGNvbnN0IG9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIHZhbHVlLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHRoaXMuX3Bvb2wpLFxuICAgICAgICBleGlzdGluZ0lkXG4gICAgICApO1xuICAgICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzLnNldChwb3NpdGlvbiwgbm4ob3BzWzBdLm9wSWQpKTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdm9pZCAwKSxcbiAgICAgICAgaWRcbiAgICAgICk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgIChlbnRyeSkgPT4gbGl2ZU5vZGVUb0xzb24oZW50cnkpXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGFsbCBlbGVtZW50cyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGVsZW1lbnQsIHRha2luZyB0d28gYXJndW1lbnRzICh0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4KS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGV2ZXJ5IGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBldmVyeShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZXZlcnkocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IG9mIHRoZSBMaXZlTGlzdC4gUmV0dXJuIGEgdmFsdWUgdGhhdCBjb2VyY2VzIHRvIHRydWUgdG8ga2VlcCB0aGUgZWxlbWVudCwgb3IgdG8gZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gICAqL1xuICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbHRlcihwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZS5cbiAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBmaW5kKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kKHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgcGFzc2VzIHRoZSB0ZXN0LiBPdGhlcndpc2UsIC0xLlxuICAgKi9cbiAgZmluZEluZGV4KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kSW5kZXgocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFja2ZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2tmbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9uIHRoZSBlbGVtZW50IHRvIGdldC5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIExpdmVMaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuXG4gICAqIEByZXR1cm5zIFRoZSBmaXJzdCBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3Q7IC0xIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuIFRoZSBMaXZlTHNpdCBpcyBzZWFyY2hlZCBiYWNrd2FyZHMsIHN0YXJ0aW5nIGF0IGZyb21JbmRleC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBiYWNrd2FyZHMuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnkgZWxlbWVudC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBldmVyeSBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIG1hcChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnksIGkpID0+IGNhbGxiYWNrKFxuICAgICAgICBsaXZlTm9kZVRvTHNvbihlbnRyeSksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICAgICAgaVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHBhc3NlcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIHNvbWUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLnNvbWUocHJlZGljYXRlKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0SXRlcmF0b3IodGhpcy5faXRlbXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpIHtcbiAgICBjb25zdCBuZXdJdGVtID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIG5ld0l0ZW0uX2F0dGFjaChvcC5pZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIG5ld0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG5ld0l0ZW0pO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgcmV0dXJuIHsgbmV3SXRlbSwgbmV3SW5kZXggfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zaGlmdEl0ZW1Qb3NpdGlvbihpbmRleCwga2V5KSB7XG4gICAgY29uc3Qgc2hpZnRlZFBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKFxuICAgICAga2V5LFxuICAgICAgdGhpcy5faXRlbXMubGVuZ3RoID4gaW5kZXggKyAxID8gdGhpcy5faXRlbXNbaW5kZXggKyAxXT8uX3BhcmVudFBvcyA6IHZvaWQgMFxuICAgICk7XG4gICAgdGhpcy5faXRlbXNbaW5kZXhdLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHNoaWZ0ZWRQb3NpdGlvbik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy5faXRlbXMubWFwKFxuICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGl0ZW0udG9UcmVlTm9kZShpbmRleC50b1N0cmluZygpKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faXRlbXMubWFwKChub2RlKSA9PiBub2RlLnRvSW1tdXRhYmxlKCkpO1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZUxpc3QodGhpcy5faXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLmNsb25lKCkpKTtcbiAgfVxufTtcbnZhciBMaXZlTGlzdEl0ZXJhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHRoaXMuX2lubmVySXRlcmF0b3IgPSBpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9pbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24ocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4geyB2YWx1ZSB9O1xuICB9XG59O1xuZnVuY3Rpb24gbWFrZVVwZGF0ZShsaXZlTGlzdCwgZGVsdGFVcGRhdGVzKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbGl2ZUxpc3QsXG4gICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgIHVwZGF0ZXM6IGRlbHRhVXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gc2V0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVEZWx0YShpbmRleCwgZGVsZXRlZE5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgIGluZGV4LFxuICAgIGRlbGV0ZWRJdGVtOiBkZWxldGVkTm9kZSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGRlbGV0ZWROb2RlLmRhdGEgOiBkZWxldGVkTm9kZVxuICB9O1xufVxuZnVuY3Rpb24gaW5zZXJ0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImluc2VydFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1vdmVcIixcbiAgICBpbmRleCxcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbSxcbiAgICBwcmV2aW91c0luZGV4XG4gIH07XG59XG5mdW5jdGlvbiBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKG9wcywgZGVsZXRlZElkKSB7XG4gIHJldHVybiBvcHMubWFwKChvcCwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0T3AgPSBvcDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmZpcnN0T3AsXG4gICAgICAgIGludGVudDogXCJzZXRcIixcbiAgICAgICAgZGVsZXRlZElkXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3A7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2xpYi9mcmVlemUudHNcbnZhciBmcmVlemUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyAoXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICh4KSA9PiB4XG4pIDogT2JqZWN0LmZyZWV6ZTtcblxuLy8gc3JjL2NyZHRzL0xpdmVNYXAudHNcbnZhciBMaXZlTWFwID0gY2xhc3MgX0xpdmVNYXAgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihlbnRyaWVzMikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51bmFja25vd2xlZGdlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKGVudHJpZXMyKSB7XG4gICAgICBjb25zdCBtYXBwZWRFbnRyaWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzMikge1xuICAgICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUodmFsdWUpO1xuICAgICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG1hcHBlZEVudHJpZXMucHVzaChba2V5LCBub2RlXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKG1hcHBlZEVudHJpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBvcCA9IHtcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIG9wSWQ6IHBvb2w/LmdlbmVyYXRlT3BJZCgpLFxuICAgICAgdHlwZTogNyAvKiBDUkVBVEVfTUFQICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIF9pdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBfTGl2ZU1hcCgpO1xuICAgIG1hcC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhtYXAsIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIG1hcC5fbWFwLnNldChjcmR0LnBhcmVudEtleSwgY2hpbGQpO1xuICAgICAgbWFwLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleSwgb3BJZCB9ID0gb3A7XG4gICAgY29uc3Qga2V5ID0gcGFyZW50S2V5O1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sLmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgY29uc3QgbGFzdFVwZGF0ZU9wSWQgPSB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmdldChrZXkpO1xuICAgICAgaWYgKGxhc3RVcGRhdGVPcElkID09PSBvcElkKSB7XG4gICAgICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZGVsZXRlKGtleSk7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfSBlbHNlIGlmIChsYXN0VXBkYXRlT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBsZXQgcmV2ZXJzZTtcbiAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgcmV2ZXJzZSA9IHByZXZpb3VzVmFsdWUuX3RvT3BzKHRoaXNJZCwga2V5KTtcbiAgICAgIHByZXZpb3VzVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXZlcnNlID0gW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV07XG4gICAgfVxuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5fbWFwLnZhbHVlcygpKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhpZCwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hpbGQuX2RldGFjaCgpO1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGUgPSB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICB1cGRhdGVzOiB7IFtwYXJlbnRLZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfTtcbiAgICByZXR1cm4geyBtb2RpZmllZDogc3RvcmFnZVVwZGF0ZSwgcmV2ZXJzZSB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZU1hcCBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDIgLyogTUFQICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoZSBMaXZlTWFwLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIG9yIHVuZGVmaW5lZCBpZiB0aGUga2V5IGNhbid0IGJlIGZvdW5kIGluIHRoZSBMaXZlTWFwLlxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZU5vZGVUb0xzb24odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIGFkZC4gU2hvdWxkIGJlIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZC4gU2hvdWxkIGJlIHNlcmlhbGl6YWJsZSB0byBKU09OLlxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gbHNvblRvTGl2ZU5vZGUodmFsdWUpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgaXRlbSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICBpdGVtLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9wcyA9IGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBrZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5zZXQoa2V5LCBubihvcHNbMF0ub3BJZCkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCksXG4gICAgICAgIG9sZFZhbHVlID8gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpIDogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBMaXZlTWFwLlxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byB0ZXN0IGZvciBwcmVzZW5jZS5cbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBieSBrZXkuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCBleGlzdGVkIGFuZCBoYXMgYmVlbiByZW1vdmVkLCBvciBmYWxzZSBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKGl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgaXRlbS5faWQpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzSWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogaXRlbS5faWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzSWQsIGtleSksXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgW2tleSwgdmFsdWVdIHBhaXJzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBlbnRyaWVzKCkge1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0aGlzLl9tYXAuZW50cmllcygpO1xuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3JWYWx1ZSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlcmF0b3JWYWx1ZS5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXJhdG9yVmFsdWUudmFsdWU7XG4gICAgICAgIGNvbnN0IGtleSA9IGVudHJ5WzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKGl0ZXJhdG9yVmFsdWUudmFsdWVbMV0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBba2V5LCB2YWx1ZV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW1lIGZ1bmN0aW9uIG9iamVjdCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZW50cmllcyBtZXRob2QuXG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGtleXMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgdmFsdWVzKCkge1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0aGlzLl9tYXAudmFsdWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBNYXAgb2JqZWN0LCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVudHJ5IGluIHRoZSBtYXAuXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzKSB7XG4gICAgICBjYWxsYmFjayhlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IEFycmF5LmZyb20odGhpcy5fbWFwLmVudHJpZXMoKSkubWFwKFxuICAgICAgICAoW2tleTIsIHZhbF0pID0+IHZhbC50b1RyZWVOb2RlKGtleTIpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvSW1tdXRhYmxlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU1hcChcbiAgICAgIEFycmF5LmZyb20odGhpcy5fbWFwKS5tYXAoKFtrZXksIG5vZGVdKSA9PiBba2V5LCBub2RlLmNsb25lKCldKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9MaXZlT2JqZWN0LnRzXG52YXIgTGl2ZU9iamVjdCA9IGNsYXNzIF9MaXZlT2JqZWN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4oaXRlbXMpIHtcbiAgICBjb25zdCBwYXJlbnRUb0NoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcm9vdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBbaWQsIGNyZHRdIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXNSb290Q3JkdChjcmR0KSkge1xuICAgICAgICByb290ID0gW2lkLCBjcmR0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gW2lkLCBjcmR0XTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChjcmR0LnBhcmVudElkKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHR1cGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRUb0NoaWxkcmVuLnNldChjcmR0LnBhcmVudElkLCBbdHVwbGVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBjYW4ndCBiZSBudWxsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jvb3QsIHBhcmVudFRvQ2hpbGRyZW5dO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9mcm9tSXRlbXMoaXRlbXMsIHBvb2wpIHtcbiAgICBjb25zdCBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl0gPSBfTGl2ZU9iamVjdC5fYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcyk7XG4gICAgcmV0dXJuIF9MaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShcbiAgICAgIHJvb3QsXG4gICAgICBwYXJlbnRUb0NoaWxkcmVuLFxuICAgICAgcG9vbFxuICAgICk7XG4gIH1cbiAgY29uc3RydWN0b3Iob2JqID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG8gPSBjb21wYWN0T2JqZWN0KG9iaik7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobykpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb1trZXldO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMobykpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BJZCA9IHBvb2w/LmdlbmVyYXRlT3BJZCgpO1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgdHlwZTogNCAvKiBDUkVBVEVfT0JKRUNUICovLFxuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZCxcbiAgICAgIHBhcmVudElkLFxuICAgICAgcGFyZW50S2V5LFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICBvcHMucHVzaCguLi52YWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgcG9vbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3AuZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgaXRlbV0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBsaXZlT2JqID0gbmV3IF9MaXZlT2JqZWN0KGl0ZW0uZGF0YSk7XG4gICAgbGl2ZU9iai5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVDaGlsZHJlbihsaXZlT2JqLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemVDaGlsZHJlbihsaXZlT2JqLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChubihsaXZlT2JqLl9pZCkpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGl2ZU9iajtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgaWYgKGlzTGl2ZVN0cnVjdHVyZShjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGl2ZU9iaiwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgfVxuICAgICAgbGl2ZU9iai5fbWFwLnNldChjcmR0LnBhcmVudEtleSwgY2hpbGQpO1xuICAgICAgbGl2ZU9iai5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBsaXZlT2JqO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgW19rZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIG9wSWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xzb24ob3ApO1xuICAgIGlmICh0aGlzLl9wb29sLmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcElkKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZSA9PT0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi8pIHtcbiAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4ob3BJZCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcElkKSB7XG4gICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBsZXQgcmV2ZXJzZTtcbiAgICBpZiAoaXNMaXZlTm9kZShwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgcmV2ZXJzZSA9IHByZXZpb3VzVmFsdWUuX3RvT3BzKHRoaXNJZCwga2V5KTtcbiAgICAgIHByZXZpb3VzVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAocHJldmlvdXNWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXZlcnNlID0gW3sgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLywgaWQ6IHRoaXNJZCwga2V5IH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXZlcnNlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgIGlkOiB0aGlzSWQsXG4gICAgICAgICAgZGF0YTogeyBba2V5XTogcHJldmlvdXNWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBjaGlsZCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKGlzTGl2ZVN0cnVjdHVyZShjaGlsZCkpIHtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJldmVyc2UsXG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gY2hpbGQpIHtcbiAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkLl9kZXRhY2goKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGUgPSB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7XG4gICAgICAgICAgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogc3RvcmFnZVVwZGF0ZSwgcmV2ZXJzZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX21hcC52YWx1ZXMoKSkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICBpZiAob3AudHlwZSA9PT0gMyAvKiBVUERBVEVfT0JKRUNUICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpO1xuICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLl9hcHBseShvcCwgaXNMb2NhbCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoIWlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiB0aGlzLnBhcmVudC5ub2RlLl9pZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIHBhcmVudElkOiB0aGlzLnBhcmVudC5ub2RlLl9pZCxcbiAgICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogT0JKRUNUICovLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVVwZGF0ZShvcCwgaXNMb2NhbCkge1xuICAgIGxldCBpc01vZGlmaWVkID0gZmFsc2U7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgY29uc3QgcmV2ZXJzZSA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VVcGRhdGUgPSB7XG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBpZCxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKGlkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VVcGRhdGUuZGF0YVtrZXldID0gb2xkVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKHsgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLywgaWQsIGtleSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wLmRhdGFba2V5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcC5vcElkKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3Aub3BJZCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgICB0aGlzLl9tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlLmRhdGEpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV2ZXJzZS51bnNoaWZ0KHJldmVyc2VVcGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gaXNNb2RpZmllZCA/IHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9IDogeyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseURlbGV0ZU9iamVjdEtleShvcCwgaXNMb2NhbCkge1xuICAgIGNvbnN0IGtleSA9IG9wLmtleTtcbiAgICBpZiAodGhpcy5fbWFwLmhhcyhrZXkpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmICghaXNMb2NhbCAmJiB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBsZXQgcmV2ZXJzZSA9IFtdO1xuICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgcmV2ZXJzZSA9IG9sZFZhbHVlLl90b09wcyhpZCwgb3Aua2V5KTtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZGF0YTogeyBba2V5XTogb2xkVmFsdWUgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtvcC5rZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgTGl2ZU9iamVjdCBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3RcbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5fbWFwKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGEgcHJvcGVydHkgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIGEgdmFsdWUuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIGFkZFxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHRoaXMudXBkYXRlKHsgW2tleV06IHZhbHVlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gdGhlIExpdmVPYmplY3QuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0XG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoZSBMaXZlT2JqZWN0XG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBrZXlBc1N0cmluZyA9IGtleTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5QXNTdHJpbmcpO1xuICAgIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDAgfHwgdGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5QXNTdHJpbmcpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgcmV2ZXJzZSA9IG9sZFZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5QXNTdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXZlcnNlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgIGRhdGE6IHsgW2tleUFzU3RyaW5nXTogb2xkVmFsdWUgfSxcbiAgICAgICAgICBpZDogdGhpcy5faWRcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLFxuICAgICAgICAgIGtleToga2V5QXNTdHJpbmcsXG4gICAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHJldmVyc2UsXG4gICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2Ugd2l0aCBhbiBvYmplY3QuXG4gICAqIEBwYXJhbSBwYXRjaCBUaGUgb2JqZWN0IHVzZWQgdG8gb3ZlcnJpZGVzIHByb3BlcnRpZXNcbiAgICovXG4gIHVwZGF0ZShwYXRjaCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhdGNoW2tleV07XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaXZlTm9kZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlT3BzID0gW107XG4gICAgY29uc3Qgb3BJZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3QgdXBkYXRlZFByb3BzID0ge307XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZU9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpcy5faWQsIGtleSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldmVyc2VVcGRhdGVPcC5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICBuZXdWYWx1ZS5fYXR0YWNoKHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpLCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgbmV3QXR0YWNoQ2hpbGRPcHMgPSBuZXdWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUNyZHRPcCA9IG5ld0F0dGFjaENoaWxkT3BzLmZpbmQoXG4gICAgICAgICAgKG9wKSA9PiBvcC5wYXJlbnRJZCA9PT0gdGhpcy5faWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGNyZWF0ZUNyZHRPcCkge1xuICAgICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4oY3JlYXRlQ3JkdE9wLm9wSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBvcHMucHVzaCguLi5uZXdBdHRhY2hDaGlsZE9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVkUHJvcHNba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG9wSWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZU9wLmRhdGEpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV2ZXJzZU9wcy51bnNoaWZ0KHJldmVyc2VVcGRhdGVPcCk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh1cGRhdGVkUHJvcHMpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgb3BzLnVuc2hpZnQoe1xuICAgICAgICBvcElkLFxuICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgZGF0YTogdXBkYXRlZFByb3BzXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICB9KTtcbiAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4gc3VwZXIudG9UcmVlTm9kZShrZXkpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgY29uc3Qgbm9kZUlkID0gdGhpcy5faWQgPz8gbmFub2lkKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IEFycmF5LmZyb20odGhpcy5fbWFwLmVudHJpZXMoKSkubWFwKFxuICAgICAgICAoW2tleTIsIHZhbHVlXSkgPT4gaXNMaXZlTm9kZSh2YWx1ZSkgPyB2YWx1ZS50b1RyZWVOb2RlKGtleTIpIDogeyB0eXBlOiBcIkpzb25cIiwgaWQ6IGAke25vZGVJZH06JHtrZXkyfWAsIGtleToga2V5MiwgcGF5bG9hZDogdmFsdWUgfVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuX21hcCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBpc0xpdmVTdHJ1Y3R1cmUodmFsKSA/IHZhbC50b0ltbXV0YWJsZSgpIDogdmFsO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVPYmplY3QoXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fbWFwKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSlcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvbGl2ZWJsb2Nrcy1oZWxwZXJzLnRzXG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCkge1xuICByZXR1cm4gbHNvblRvTGl2ZU5vZGUoY3JlYXRpb25PcFRvTHNvbihvcCkpO1xufVxuZnVuY3Rpb24gY3JlYXRpb25PcFRvTHNvbihvcCkge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOlxuICAgICAgcmV0dXJuIG9wLmRhdGE7XG4gICAgY2FzZSA0IC8qIENSRUFURV9PQkpFQ1QgKi86XG4gICAgICByZXR1cm4gbmV3IExpdmVPYmplY3Qob3AuZGF0YSk7XG4gICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICByZXR1cm4gbmV3IExpdmVNYXAoKTtcbiAgICBjYXNlIDIgLyogQ1JFQVRFX0xJU1QgKi86XG4gICAgICByZXR1cm4gbmV3IExpdmVMaXN0KFtdKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKG9wLCBcIlVua25vd24gY3JlYXRpb24gT3BcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZSwgcGFyZW50KSB7XG4gIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgIHJldHVybiBpc1NhbWVOb2RlT3JDaGlsZE9mKG5vZGUucGFyZW50Lm5vZGUsIHBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgIGNhc2UgMCAvKiBPQkpFQ1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAxIC8qIExJU1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTGlzdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMiAvKiBNQVAgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTWFwLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAzIC8qIFJFR0lTVEVSICovOiB7XG4gICAgICByZXR1cm4gTGl2ZVJlZ2lzdGVyLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvTHNvbihbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBjcmR0LmRhdGE7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgQ1JEVCB0eXBlXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXZlU3RydWN0dXJlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVMaXN0KHZhbHVlKSB8fCBpc0xpdmVNYXAodmFsdWUpIHx8IGlzTGl2ZU9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0xpdmVOb2RlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHx8IGlzTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZUxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVNYXAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0O1xufVxuZnVuY3Rpb24gaXNMaXZlUmVnaXN0ZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyO1xufVxuZnVuY3Rpb24gY2xvbmVMc29uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNMaXZlU3RydWN0dXJlKHZhbHVlKSA/IHZhbHVlLmNsb25lKCkgOiBkZWVwQ2xvbmUodmFsdWUpO1xufVxuZnVuY3Rpb24gbGl2ZU5vZGVUb0xzb24ob2JqKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGl2ZUxpc3QgfHwgb2JqIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob2JqLCBcIlVua25vd24gQWJzdHJhY3RDcmR0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBsc29uVG9MaXZlTm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0IHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ld0l0ZW1zKSB7XG4gIGNvbnN0IG9wcyA9IFtdO1xuICBjdXJyZW50SXRlbXMuZm9yRWFjaCgoXywgaWQpID0+IHtcbiAgICBpZiAoIW5ld0l0ZW1zLmdldChpZCkpIHtcbiAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIG5ld0l0ZW1zLmZvckVhY2goKGNyZHQsIGlkKSA9PiB7XG4gICAgY29uc3QgY3VycmVudENyZHQgPSBjdXJyZW50SXRlbXMuZ2V0KGlkKTtcbiAgICBpZiAoY3VycmVudENyZHQpIHtcbiAgICAgIGlmIChjcmR0LnR5cGUgPT09IDAgLyogT0JKRUNUICovKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q3JkdC50eXBlICE9PSAwIC8qIE9CSkVDVCAqLyB8fCBKU09OLnN0cmluZ2lmeShjcmR0LmRhdGEpICE9PSBKU09OLnN0cmluZ2lmeShjdXJyZW50Q3JkdC5kYXRhKSkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjcmR0LnBhcmVudEtleSAhPT0gY3VycmVudENyZHQucGFyZW50S2V5KSB7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhcmVudEtleTogbm4oY3JkdC5wYXJlbnRLZXksIFwiUGFyZW50IGtleSBtdXN0IG5vdCBiZSBtaXNzaW5nXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgICAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogOCAvKiBDUkVBVEVfUkVHSVNURVIgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTElTVCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwIC8qIE9CSkVDVCAqLzpcbiAgICAgICAgICBpZiAoY3JkdC5wYXJlbnRJZCA9PT0gdm9pZCAwIHx8IGNyZHQucGFyZW50S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnRlcm5hbCBlcnJvci4gQ2Fubm90IHNlcmlhbGl6ZSBzdG9yYWdlIHJvb3QgaW50byBhbiBvcGVyYXRpb25cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNCAvKiBDUkVBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXksXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIE1BUCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBmaXJzdC51cGRhdGVzO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKHNlY29uZC51cGRhdGVzKSkge1xuICAgIHVwZGF0ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTGlzdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXM6IHVwZGF0ZXMuY29uY2F0KHNlY29uZC51cGRhdGVzKVxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHNlY29uZDtcbiAgfVxuICBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTWFwXCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU1hcFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlTWFwU3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTGlzdFwiICYmIHNlY29uZC50eXBlID09PSBcIkxpdmVMaXN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSB7XG4gIH1cbiAgcmV0dXJuIHNlY29uZDtcbn1cbmZ1bmN0aW9uIGlzUGxhaW4odmFsdWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoID0gXCJcIikge1xuICBpZiAoIWlzUGxhaW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCB8fCBcInJvb3RcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmICghaXNQbGFpbihuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qgbm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoXG4gICAgICAgIG5lc3RlZFZhbHVlLFxuICAgICAgICBuZXN0ZWRQYXRoXG4gICAgICApO1xuICAgICAgaWYgKG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvbGliL2NodW5rLnRzXG5mdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSkge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpICs9IHNpemUpIHtcbiAgICBjaHVua3MucHVzaChhcnJheS5zbGljZShpLCBpICsgc2l6ZSkpO1xuICB9XG4gIHJldHVybiBjaHVua3M7XG59XG5cbi8vIHNyYy9saWIvY3JlYXRlSWRzLnRzXG52YXIgVEhSRUFEX0lEX1BSRUZJWCA9IFwidGhcIjtcbnZhciBDT01NRU5UX0lEX1BSRUZJWCA9IFwiY21cIjtcbnZhciBDT01NRU5UX0FUVEFDSE1FTlRfSURfUFJFRklYID0gXCJhdFwiO1xudmFyIElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVggPSBcImluXCI7XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljSWQocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7bmFub2lkKCl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRocmVhZElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKFRIUkVBRF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoQ09NTUVOVF9BVFRBQ0hNRU5UX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmJveE5vdGlmaWNhdGlvbklkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVgpO1xufVxuXG4vLyBzcmMvbGliL2RlYnVnLnRzXG5mdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShtc2csIHRyYWNlUm9vdCkge1xuICBjb25zdCBlcnJvckxpa2UgPSB7IG5hbWU6IG1zZyB9O1xuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yTGlrZSwgdHJhY2VSb290KTtcbiAgcmV0dXJuIGVycm9yTGlrZS5zdGFjaztcbn1cblxuLy8gc3JjL2xpYi9Kc29uLnRzXG5mdW5jdGlvbiBpc0pzb25TY2FsYXIoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBpc0pzb25BcnJheShkYXRhKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpO1xufVxuZnVuY3Rpb24gaXNKc29uT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuICFpc0pzb25TY2FsYXIoZGF0YSkgJiYgIWlzSnNvbkFycmF5KGRhdGEpO1xufVxuXG4vLyBzcmMvbGliL29iamVjdFRvUXVlcnkudHNcbnZhciBpZGVudGlmaWVyUmVnZXggPSAvXlthLXpBLVpfXVthLXpBLVowLTlfXSokLztcbmZ1bmN0aW9uIG9iamVjdFRvUXVlcnkob2JqKSB7XG4gIGxldCBmaWx0ZXJMaXN0ID0gW107XG4gIGNvbnN0IGVudHJpZXMyID0gT2JqZWN0LmVudHJpZXMob2JqKTtcbiAgY29uc3Qga2V5VmFsdWVQYWlycyA9IFtdO1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gIGNvbnN0IGluZGV4ZWRLZXlzID0gW107XG4gIGVudHJpZXMyLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICghaWRlbnRpZmllclJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IG11c3Qgb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIF9cIik7XG4gICAgfVxuICAgIGlmIChpc1NpbXBsZVZhbHVlKHZhbHVlKSkge1xuICAgICAga2V5VmFsdWVQYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmIChpc1ZhbHVlV2l0aE9wZXJhdG9yKHZhbHVlKSkge1xuICAgICAga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIShcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSkpIHtcbiAgICAgIGluZGV4ZWRLZXlzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9XG4gIH0pO1xuICBmaWx0ZXJMaXN0ID0gW1xuICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhrZXlWYWx1ZVBhaXJzKSxcbiAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3Ioa2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcilcbiAgXTtcbiAgaW5kZXhlZEtleXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbmVzdGVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgICBjb25zdCBuS2V5VmFsdWVQYWlycyA9IFtdO1xuICAgIGNvbnN0IG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gICAgbmVzdGVkRW50cmllcy5mb3JFYWNoKChbbmVzdGVkS2V5LCBuZXN0ZWRWYWx1ZV0pID0+IHtcbiAgICAgIGlmIChpc1N0cmluZ0VtcHR5KG5lc3RlZEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NpbXBsZVZhbHVlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgICBuS2V5VmFsdWVQYWlycy5wdXNoKFtmb3JtYXRGaWx0ZXJLZXkoa2V5LCBuZXN0ZWRLZXkpLCBuZXN0ZWRWYWx1ZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlV2l0aE9wZXJhdG9yKG5lc3RlZFZhbHVlKSkge1xuICAgICAgICBuS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5wdXNoKFtcbiAgICAgICAgICBmb3JtYXRGaWx0ZXJLZXkoa2V5LCBuZXN0ZWRLZXkpLFxuICAgICAgICAgIG5lc3RlZFZhbHVlXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZpbHRlckxpc3QgPSBbXG4gICAgICAuLi5maWx0ZXJMaXN0LFxuICAgICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzKG5LZXlWYWx1ZVBhaXJzKSxcbiAgICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcihuS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcilcbiAgICBdO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlckxpc3QubWFwKFxuICAgICh7IGtleSwgb3BlcmF0b3IsIHZhbHVlIH0pID0+IGZvcm1hdEZpbHRlcihrZXksIG9wZXJhdG9yLCBmb3JtYXRGaWx0ZXJWYWx1ZSh2YWx1ZSkpXG4gICkuam9pbihcIiBBTkQgXCIpO1xufVxudmFyIGdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyA9IChrZXlWYWx1ZVBhaXJzKSA9PiB7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAga2V5VmFsdWVQYWlycy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAga2V5LFxuICAgICAgb3BlcmF0b3I6IFwiOlwiLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJzO1xufTtcbnZhciBnZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IgPSAoa2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcikgPT4ge1xuICBjb25zdCBmaWx0ZXJzID0gW107XG4gIGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKFwic3RhcnRzV2l0aFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdGFydHNXaXRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIG9wZXJhdG9yOiBcIl5cIixcbiAgICAgICAgdmFsdWU6IHZhbHVlLnN0YXJ0c1dpdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJzO1xufTtcbnZhciBpc1NpbXBsZVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGlzVmFsdWVXaXRoT3BlcmF0b3IgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgZm9ybWF0RmlsdGVyID0gKGtleSwgb3BlcmF0b3IsIHZhbHVlKSA9PiB7XG4gIHJldHVybiBgJHtrZXl9JHtvcGVyYXRvcn0ke3ZhbHVlfWA7XG59O1xudmFyIGZvcm1hdEZpbHRlcktleSA9IChrZXksIG5lc3RlZEtleSkgPT4ge1xuICBpZiAobmVzdGVkS2V5KSB7XG4gICAgcmV0dXJuIGAke2tleX1bJHtKU09OLnN0cmluZ2lmeShuZXN0ZWRLZXkpfV1gO1xuICB9XG4gIHJldHVybiBrZXk7XG59O1xudmFyIGZvcm1hdEZpbHRlclZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNTdHJpbmdFbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn07XG52YXIgaXNTdHJpbmdFbXB0eSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlLnRvU3RyaW5nKCkudHJpbSgpID09PSBcIlwiO1xufTtcblxuLy8gc3JjL3Byb3RvY29sL0NsaWVudE1zZy50c1xudmFyIENsaWVudE1zZ0NvZGUgPSAvKiBAX19QVVJFX18gKi8gKChDbGllbnRNc2dDb2RlMikgPT4ge1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9QUkVTRU5DRVwiXSA9IDEwMF0gPSBcIlVQREFURV9QUkVTRU5DRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkJST0FEQ0FTVF9FVkVOVFwiXSA9IDEwM10gPSBcIkJST0FEQ0FTVF9FVkVOVFwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkZFVENIX1NUT1JBR0VcIl0gPSAyMDBdID0gXCJGRVRDSF9TVE9SQUdFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIkZFVENIX1lET0NcIl0gPSAzMDBdID0gXCJGRVRDSF9ZRE9DXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDFdID0gXCJVUERBVEVfWURPQ1wiO1xuICByZXR1cm4gQ2xpZW50TXNnQ29kZTI7XG59KShDbGllbnRNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3JlZnMvSW1tdXRhYmxlUmVmLnRzXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gIGNvbnN0IG5ld1ZhbHVlID0geyAuLi50YXJnZXQgfTtcbiAgT2JqZWN0LmtleXMocGF0Y2gpLmZvckVhY2goKGspID0+IHtcbiAgICBjb25zdCBrZXkgPSBrO1xuICAgIGNvbnN0IHZhbCA9IHBhdGNoW2tleV07XG4gICAgaWYgKG5ld1ZhbHVlW2tleV0gIT09IHZhbCkge1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdWYWx1ZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWVba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB1cGRhdGVkID8gbmV3VmFsdWUgOiB0YXJnZXQ7XG59XG52YXIgSW1tdXRhYmxlUmVmID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ldiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICB9XG4gIGdldCBkaWRJbnZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9ldi5vYnNlcnZhYmxlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fZXYubm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZSA/PyAodGhpcy5fY2FjaGUgPSB0aGlzLl90b0ltbXV0YWJsZSgpKTtcbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvT3RoZXJzUmVmLnRzXG5mdW5jdGlvbiBtYWtlVXNlcihjb25uLCBwcmVzZW5jZSkge1xuICBjb25zdCB7IGNvbm5lY3Rpb25JZCwgaWQsIGluZm8gfSA9IGNvbm47XG4gIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKGNvbm4uc2NvcGVzKTtcbiAgcmV0dXJuIGZyZWV6ZShcbiAgICBjb21wYWN0T2JqZWN0KHtcbiAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgIGlkLFxuICAgICAgaW5mbyxcbiAgICAgIGNhbldyaXRlLFxuICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChjb25uLnNjb3BlcyksXG4gICAgICBpc1JlYWRPbmx5OiAhY2FuV3JpdGUsXG4gICAgICAvLyBEZXByZWNhdGVkLCBrZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5XG4gICAgICBwcmVzZW5jZVxuICAgIH0pXG4gICk7XG59XG52YXIgT3RoZXJzUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICAvL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBjb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9ucy5rZXlzKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgdXNlcnMgPSBjb21wYWN0KFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9wcmVzZW5jZXMua2V5cygpKS5tYXAoXG4gICAgICAgIChjb25uZWN0aW9uSWQpID0+IHRoaXMuZ2V0VXNlcihOdW1iZXIoY29ubmVjdGlvbklkKSlcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiB1c2VycztcbiAgfVxuICBjbGVhck90aGVycygpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl91c2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0VXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBjb25zdCBjb25uID0gdGhpcy5fY29ubmVjdGlvbnMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgY29uc3QgcHJlc2VuY2UgPSB0aGlzLl9wcmVzZW5jZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNvbm4gIT09IHZvaWQgMCAmJiBwcmVzZW5jZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFrZVVzZXIoY29ubiwgcHJlc2VuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGdldFVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgY29uc3QgY2FjaGVkVXNlciA9IHRoaXMuX3VzZXJzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjYWNoZWRVc2VyKSB7XG4gICAgICByZXR1cm4gY2FjaGVkVXNlcjtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWRVc2VyID0gdGhpcy5fZ2V0VXNlcihjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb21wdXRlZFVzZXIpIHtcbiAgICAgIHRoaXMuX3VzZXJzLnNldChjb25uZWN0aW9uSWQsIGNvbXB1dGVkVXNlcik7XG4gICAgICByZXR1cm4gY29tcHV0ZWRVc2VyO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGlmICh0aGlzLl91c2Vycy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5fdXNlcnMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEga25vd24gY29ubmVjdGlvbi4gVGhpcyByZWNvcmRzIHRoZSBjb25uZWN0aW9uIElEIGFuZCB0aGVcbiAgICogYXNzb2NpYXRlZCBtZXRhZGF0YS5cbiAgICovXG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBtZXRhVXNlcklkLCBtZXRhVXNlckluZm8sIHNjb3Blcykge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zLnNldChcbiAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgIGZyZWV6ZSh7XG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgaWQ6IG1ldGFVc2VySWQsXG4gICAgICAgIGluZm86IG1ldGFVc2VySW5mbyxcbiAgICAgICAgc2NvcGVzXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHRoaXMuX3ByZXNlbmNlcy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBrbm93biBjb25uZWN0aW9uSWQuIFJlbW92ZXMgYm90aCB0aGUgY29ubmVjdGlvbidzIG1ldGFkYXRhIGFuZFxuICAgKiB0aGUgcHJlc2VuY2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX3ByZXNlbmNlcy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICB9XG4gIC8qKlxuICAgKiBTdG9yZXMgYSBuZXcgdXNlciBmcm9tIGEgZnVsbCBwcmVzZW5jZSB1cGRhdGUuIElmIHRoZSB1c2VyIGFscmVhZHkgZXhpc3RzLFxuICAgKiBpdHMga25vd24gcHJlc2VuY2UgZGF0YSBpcyBvdmVyd3JpdHRlbi5cbiAgICovXG4gIHNldE90aGVyKGNvbm5lY3Rpb25JZCwgcHJlc2VuY2UpIHtcbiAgICB0aGlzLl9wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKGNvbXBhY3RPYmplY3QocHJlc2VuY2UpKSk7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25zLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcHJlc2VuY2UgZGF0YSBmb3IgYW4gZXhpc3RpbmcgXCJvdGhlclwiLiBJZiB3ZSBkb24ndCBrbm93IHRoZVxuICAgKiBpbml0aWFsIHByZXNlbmNlIGRhdGEgZm9yIHRoaXMgdXNlciB5ZXQsIGRpc2NhcmQgdGhpcyBwYXRjaCBhbmQgYXdhaXQgdGhlXG4gICAqIGZ1bGwgLnNldE90aGVyKCkgY2FsbCBmaXJzdC5cbiAgICovXG4gIHBhdGNoT3RoZXIoY29ubmVjdGlvbklkLCBwYXRjaCkge1xuICAgIGNvbnN0IG9sZFByZXNlbmNlID0gdGhpcy5fcHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChvbGRQcmVzZW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1ByZXNlbmNlID0gbWVyZ2Uob2xkUHJlc2VuY2UsIHBhdGNoKTtcbiAgICBpZiAob2xkUHJlc2VuY2UgIT09IG5ld1ByZXNlbmNlKSB7XG4gICAgICB0aGlzLl9wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKG5ld1ByZXNlbmNlKSk7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvUGF0Y2hhYmxlUmVmLnRzXG52YXIgUGF0Y2hhYmxlUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZnJlZXplKGNvbXBhY3RPYmplY3QoZGF0YSkpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICovXG4gIHBhdGNoKHBhdGNoKSB7XG4gICAgY29uc3Qgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgbmV3RGF0YSA9IG1lcmdlKG9sZERhdGEsIHBhdGNoKTtcbiAgICBpZiAob2xkRGF0YSAhPT0gbmV3RGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGZyZWV6ZShuZXdEYXRhKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlZnMvVmFsdWVSZWYudHNcbnZhciBWYWx1ZVJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbFZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl92YWx1ZSA9IGZyZWV6ZShpbml0aWFsVmFsdWUpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQobmV3VmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IGZyZWV6ZShuZXdWYWx1ZSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbn07XG52YXIgRGVyaXZlZFJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdHJhbnNmb3JtRm4gPSBhcmdzLnBvcCgpO1xuICAgIGNvbnN0IG90aGVyUmVmcyA9IGFyZ3M7XG4gICAgdGhpcy5fcmVmcyA9IG90aGVyUmVmcztcbiAgICB0aGlzLl9yZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgcmVmLmRpZEludmFsaWRhdGUuc3Vic2NyaWJlKCgpID0+IHRoaXMuaW52YWxpZGF0ZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1GbjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtKFxuICAgICAgLi4udGhpcy5fcmVmcy5tYXAoKHJlZikgPT4gcmVmLmN1cnJlbnQpXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL3Jvb20udHNcbnZhciBNQVhfU09DS0VUX01FU1NBR0VfU0laRSA9IDEwMjQgKiAxMDI0IC0gMTAyNDtcbmZ1bmN0aW9uIG1ha2VJZEZhY3RvcnkoY29ubmVjdGlvbklkKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIHJldHVybiAoKSA9PiBgJHtjb25uZWN0aW9uSWR9OiR7Y291bnQrK31gO1xufVxuZnVuY3Rpb24gdXNlclRvVHJlZU5vZGUoa2V5LCB1c2VyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJVc2VyXCIsXG4gICAgaWQ6IGAke3VzZXIuY29ubmVjdGlvbklkfWAsXG4gICAga2V5LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIGNvbm5lY3Rpb25JZDogdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIGluZm86IHVzZXIuaW5mbyxcbiAgICAgIHByZXNlbmNlOiB1c2VyLnByZXNlbmNlLFxuICAgICAgaXNSZWFkT25seTogIXVzZXIuY2FuV3JpdGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IGluQmFja2dyb3VuZFNpbmNlID0geyBjdXJyZW50OiBudWxsIH07XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID8/IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgIGRvYz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfTtcbiAgcmV0dXJuIFtpbkJhY2tncm91bmRTaW5jZSwgdW5zdWJdO1xufVxudmFyIEdFVF9BVFRBQ0hNRU5UX1VSTFNfQkFUQ0hfREVMQVkgPSA1MDtcbnZhciBBVFRBQ0hNRU5UX1BBUlRfU0laRSA9IDUgKiAxMDI0ICogMTAyNDtcbnZhciBBVFRBQ0hNRU5UX1BBUlRfQkFUQ0hfU0laRSA9IDU7XG52YXIgUkVUUllfQVRURU1QVFMgPSAxMDtcbnZhciBSRVRSWV9ERUxBWVMgPSBbXG4gIDJlMyxcbiAgMmUzLFxuICAyZTMsXG4gIDJlMyxcbiAgMmUzLFxuICAyZTMsXG4gIDJlMyxcbiAgMmUzLFxuICAyZTMsXG4gIDJlM1xuXTtcbmZ1bmN0aW9uIHNwbGl0RmlsZUludG9QYXJ0cyhmaWxlKSB7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGxldCBzdGFydCA9IDA7XG4gIHdoaWxlIChzdGFydCA8IGZpbGUuc2l6ZSkge1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgQVRUQUNITUVOVF9QQVJUX1NJWkUsIGZpbGUuc2l6ZSk7XG4gICAgcGFydHMucHVzaCh7XG4gICAgICBwYXJ0TnVtYmVyOiBwYXJ0cy5sZW5ndGggKyAxLFxuICAgICAgcGFydDogZmlsZS5zbGljZShzdGFydCwgZW5kKVxuICAgIH0pO1xuICAgIHN0YXJ0ID0gZW5kO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb20ob3B0aW9ucywgY29uZmlnKSB7XG4gIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9IG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlO1xuICBjb25zdCBpbml0aWFsU3RvcmFnZSA9IG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2U7XG4gIGNvbnN0IFtpbkJhY2tncm91bmRTaW5jZSwgdW5pbnN0YWxsQmdUYWJTcHldID0gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKTtcbiAgY29uc3QgZGVsZWdhdGVzID0ge1xuICAgIC4uLmNvbmZpZy5kZWxlZ2F0ZXMsXG4gICAgLy8gQSBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gZ28gaW50byBcInpvbWJpZSBzdGF0ZVwiIG9ubHkgaWYgYWxsIG9mIHRoZVxuICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zIGFwcGx5OlxuICAgIC8vXG4gICAgLy8gLSBUaGUgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBjbGllbnQgb3B0aW9uIGlzIGNvbmZpZ3VyZWRcbiAgICAvLyAtIFRoZSBicm93c2VyIHdpbmRvdyBoYXMgYmVlbiBpbiB0aGUgYmFja2dyb3VuZCBmb3IgYXQgbGVhc3RcbiAgICAvLyAgIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgbWlsbGlzZWNvbmRzXG4gICAgLy8gLSBUaGVyZSBhcmUgbm8gcGVuZGluZyBjaGFuZ2VzXG4gICAgLy9cbiAgICBjYW5ab21iaWUoKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICE9PSB2b2lkIDAgJiYgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCAhPT0gbnVsbCAmJiBEYXRlLm5vdygpID4gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCArIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAmJiBnZXRTdG9yYWdlU3RhdHVzKCkgIT09IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWFuYWdlZFNvY2tldCA9IG5ldyBNYW5hZ2VkU29ja2V0KFxuICAgIGRlbGVnYXRlcyxcbiAgICBjb25maWcuZW5hYmxlRGVidWdMb2dnaW5nXG4gICk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgYnVmZmVyOiB7XG4gICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgIGxhc3RGbHVzaGVkQXQ6IDAsXG4gICAgICBwcmVzZW5jZVVwZGF0ZXM6IChcbiAgICAgICAgLy8gUXVldWUgdXAgdGhlIGluaXRpYWwgcHJlc2VuY2UgbWVzc2FnZSBhcyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgICAgICBkYXRhOiBpbml0aWFsUHJlc2VuY2VcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXVxuICAgIH0sXG4gICAgc3RhdGljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBteVByZXNlbmNlOiBuZXcgUGF0Y2hhYmxlUmVmKGluaXRpYWxQcmVzZW5jZSksXG4gICAgb3RoZXJzOiBuZXcgT3RoZXJzUmVmKCksXG4gICAgaW5pdGlhbFN0b3JhZ2UsXG4gICAgaWRGYWN0b3J5OiBudWxsLFxuICAgIC8vIFkuanNcbiAgICBwcm92aWRlcjogdm9pZCAwLFxuICAgIG9uUHJvdmlkZXJVcGRhdGU6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIFN0b3JhZ2VcbiAgICBjbG9jazogMCxcbiAgICBvcENsb2NrOiAwLFxuICAgIG5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICB1bmRvU3RhY2s6IFtdLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgcGF1c2VkSGlzdG9yeTogbnVsbCxcbiAgICBhY3RpdmVCYXRjaDogbnVsbCxcbiAgICB1bmFja25vd2xlZGdlZE9wczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAvLyBEZWJ1Z1xuICAgIG9wU3RhY2tUcmFjZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgOiB2b2lkIDBcbiAgfTtcbiAgY29uc3QgZG9Ob3RCYXRjaFVwZGF0ZXMgPSAoY2IpID0+IGNiKCk7XG4gIGNvbnN0IGJhdGNoVXBkYXRlcyA9IGNvbmZpZy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA/PyBkb05vdEJhdGNoVXBkYXRlcztcbiAgbGV0IGxhc3RUb2tlbktleTtcbiAgZnVuY3Rpb24gb25TdGF0dXNEaWRDaGFuZ2UobmV3U3RhdHVzKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWU7XG4gICAgaWYgKGF1dGhWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdG9rZW5LZXkgPSBnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKTtcbiAgICAgIGlmICh0b2tlbktleSAhPT0gbGFzdFRva2VuS2V5KSB7XG4gICAgICAgIGxhc3RUb2tlbktleSA9IHRva2VuS2V5O1xuICAgICAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQ7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQsXG4gICAgICAgICAgICB1c2VySW5mbzogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmluZm8gOiB0b2tlbi51aVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdm9pZCAwLFxuICAgICAgICAgICAgdXNlckluZm86IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IF9jb25uZWN0aW9uTG9zc1RpbWVySWQ7XG4gIGxldCBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudChuZXdTdGF0dXMpIHtcbiAgICBpZiAobmV3U3RhdHVzID09PSBcInJlY29ubmVjdGluZ1wiKSB7XG4gICAgICBfY29ubmVjdGlvbkxvc3NUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbnRleHQub3RoZXJzLmNsZWFyT3RoZXJzKCk7XG4gICAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGNvbmZpZy5sb3N0Q29ubmVjdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCk7XG4gICAgICBpZiAoX2hhc0xvc3RDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJyZXN0b3JlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25EaWRDb25uZWN0KCkge1xuICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgZGF0YTogKFxuICAgICAgICAvLyBCZWNhdXNlIGNvbnRleHQubWUuY3VycmVudCBpcyBhIHJlYWRvbmx5IG9iamVjdCwgd2UnbGwgaGF2ZSB0b1xuICAgICAgICAvLyBtYWtlIGEgY29weSBoZXJlLiBPdGhlcndpc2UsIHR5cGUgZXJyb3JzIGhhcHBlbiBsYXRlciB3aGVuXG4gICAgICAgIC8vIFwicGF0Y2hpbmdcIiBteSBwcmVzZW5jZS5cbiAgICAgICAgeyAuLi5jb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTGl2ZWJsb2Nrc0Vycm9yLnN1YnNjcmliZSgoZXJyKSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3IyKFxuICAgICAgICAgIGBDb25uZWN0aW9uIHRvIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkLiBSZWFzb246ICR7ZXJyLm1lc3NhZ2V9IChjb2RlOiAke2Vyci5jb2RlfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZXZlbnRIdWIuZXJyb3Iubm90aWZ5KGVycik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBwb29sID0ge1xuICAgIHJvb21JZDogY29uZmlnLnJvb21JZCxcbiAgICBnZXROb2RlOiAoaWQpID0+IGNvbnRleHQubm9kZXMuZ2V0KGlkKSxcbiAgICBhZGROb2RlOiAoaWQsIG5vZGUpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5jbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0Lm9wQ2xvY2srK31gLFxuICAgIGRpc3BhdGNoKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCB0aGlzLmRpc3BhdGNoKTtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5zZXQob3Aub3BJZCwgc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQmF0Y2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC5vcHMucHVzaChvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoLi4ucmV2ZXJzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKHJldmVyc2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICAgICAgbm90aWZ5KHsgc3RvcmFnZVVwZGF0ZXMgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlOiAoKSA9PiB7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5zY29wZXM7XG4gICAgICBpZiAoc2NvcGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKTtcbiAgICAgIGlmICghY2FuV3JpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHdyaXRlIHRvIHN0b3JhZ2Ugd2l0aCBhIHJlYWQgb25seSB1c2VyLCBwbGVhc2UgZW5zdXJlIHRoZSB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uc1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBldmVudEh1YiA9IHtcbiAgICBzdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE5ldy9yZWNvbW1lbmRlZCBBUElcbiAgICBsb3N0Q29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY3VzdG9tRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHNlbGY6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG15UHJlc2VuY2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG90aGVyczogbWFrZUV2ZW50U291cmNlKCksXG4gICAgZXJyb3I6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VCYXRjaDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgaGlzdG9yeTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZURpZExvYWQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VTdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHlkb2M6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGNvbW1lbnRzOiBtYWtlRXZlbnRTb3VyY2UoKVxuICB9O1xuICBjb25zdCBmZXRjaFBvbHlmaWxsID0gY29uZmlnLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2xvYmFsVGhpcy5mZXRjaD8uYmluZChnbG9iYWxUaGlzKTtcbiAgY29uc3QgaHR0cENsaWVudDEgPSBuZXcgSHR0cENsaWVudChcbiAgICBjb25maWcuYmFzZVVybCxcbiAgICBmZXRjaFBvbHlmaWxsLFxuICAgICgpID0+IFByb21pc2UucmVzb2x2ZShtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSA/PyByYWlzZShcIk5vdCBhdXRob3JpemVkXCIpKVxuICApO1xuICBjb25zdCBodHRwQ2xpZW50MiA9IG5ldyBIdHRwQ2xpZW50KFxuICAgIGNvbmZpZy5iYXNlVXJsLFxuICAgIGZldGNoUG9seWZpbGwsXG4gICAgKCkgPT4gKFxuICAgICAgLy8gVE9ETzogVXNlIHRoZSByaWdodCBzY29wZVxuICAgICAgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpXG4gICAgKVxuICApO1xuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUZXh0TWVudGlvbih1c2VySWQsIG1lbnRpb25JZCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQxLnJhd1Bvc3QodXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGV4dC1tZW50aW9uc2AsIHtcbiAgICAgIHVzZXJJZCxcbiAgICAgIG1lbnRpb25JZFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRleHRNZW50aW9uKG1lbnRpb25JZCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQxLnJhd0RlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RleHQtbWVudGlvbnMvJHttZW50aW9uSWR9YFxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVwb3J0VGV4dEVkaXRvcih0eXBlLCByb290S2V5KSB7XG4gICAgYXdhaXQgaHR0cENsaWVudDIucmF3UG9zdCh1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90ZXh0LW1ldGFkYXRhYCwge1xuICAgICAgdHlwZSxcbiAgICAgIHJvb3RLZXlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsaXN0VGV4dFZlcnNpb25zKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQyLmdldCh1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS92ZXJzaW9uc2ApO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uczogcmVzdWx0LnZlcnNpb25zLm1hcCgoeyBjcmVhdGVkQXQsIC4uLnZlcnNpb24gfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY3JlYXRlZEF0KSxcbiAgICAgICAgICAuLi52ZXJzaW9uXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnNTaW5jZShvcHRpb25zMikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQyLmdldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3ZlcnNpb25zL2RlbHRhYCxcbiAgICAgIHsgc2luY2U6IG9wdGlvbnMyLnNpbmNlLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zMi5zaWduYWwgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb25zOiByZXN1bHQudmVyc2lvbnMubWFwKCh7IGNyZWF0ZWRBdCwgLi4udmVyc2lvbiB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShjcmVhdGVkQXQpLFxuICAgICAgICAgIC4uLnZlcnNpb25cbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGV4dFZlcnNpb24odmVyc2lvbklkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQyLnJhd0dldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3ktdmVyc2lvbi8ke3ZlcnNpb25JZH1gXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUZXh0VmVyc2lvbigpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50Mi5yYXdQb3N0KHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3ZlcnNpb25gKTtcbiAgfVxuICBmdW5jdGlvbiBzZW5kTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VzKTtcbiAgICBjb25zdCBub25jZSA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ/Lm5vbmNlO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAgJiYgbm9uY2UpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VyaWFsaXplZFBheWxvYWQpLmxlbmd0aDtcbiAgICAgIGlmIChzaXplID4gTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUpIHtcbiAgICAgICAgdm9pZCBodHRwQ2xpZW50MS5yYXdQb3N0KHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3NlbmQtbWVzc2FnZWAsIHtcbiAgICAgICAgICBub25jZSxcbiAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICB9KS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwLm9rICYmIHJlc3Auc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgIG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1lc3NhZ2Ugd2FzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cyBhbmQgc2VudCBvdmVyIEhUVFAgaW5zdGVhZFwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFuYWdlZFNvY2tldC5zZW5kKHNlcmlhbGl6ZWRQYXlsb2FkKTtcbiAgfVxuICBjb25zdCBzZWxmID0gbmV3IERlcml2ZWRSZWYoXG4gICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mbyxcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mbyxcbiAgICBjb250ZXh0Lm15UHJlc2VuY2UsXG4gICAgKHN0YXRpY1Nlc3Npb24sIGR5bmFtaWNTZXNzaW9uLCBteVByZXNlbmNlKSA9PiB7XG4gICAgICBpZiAoc3RhdGljU2Vzc2lvbiA9PT0gbnVsbCB8fCBkeW5hbWljU2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKGR5bmFtaWNTZXNzaW9uLnNjb3Blcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29ubmVjdGlvbklkOiBkeW5hbWljU2Vzc2lvbi5hY3RvcixcbiAgICAgICAgICBpZDogc3RhdGljU2Vzc2lvbi51c2VySWQsXG4gICAgICAgICAgaW5mbzogc3RhdGljU2Vzc2lvbi51c2VySW5mbyxcbiAgICAgICAgICBwcmVzZW5jZTogbXlQcmVzZW5jZSxcbiAgICAgICAgICBjYW5Xcml0ZSxcbiAgICAgICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGR5bmFtaWNTZXNzaW9uLnNjb3BlcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGxldCBfbGFzdFNlbGY7XG4gIGZ1bmN0aW9uIG5vdGlmeVNlbGZDaGFuZ2VkKGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnN0IGN1cnJTZWxmID0gc2VsZi5jdXJyZW50O1xuICAgIGlmIChjdXJyU2VsZiAhPT0gbnVsbCAmJiBjdXJyU2VsZiAhPT0gX2xhc3RTZWxmKSB7XG4gICAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICBldmVudEh1Yi5zZWxmLm5vdGlmeShjdXJyU2VsZik7XG4gICAgICB9KTtcbiAgICAgIF9sYXN0U2VsZiA9IGN1cnJTZWxmO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWxmQXNUcmVlTm9kZSA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIHNlbGYsXG4gICAgKG1lKSA9PiBtZSAhPT0gbnVsbCA/IHVzZXJUb1RyZWVOb2RlKFwiTWVcIiwgbWUpIDogbnVsbFxuICApO1xuICBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAobWVzc2FnZS5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBjYW5ub3QgbG9hZCBzdG9yYWdlIHdpdGhvdXQgaXRlbXNcIik7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LnJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgdXBkYXRlUm9vdChtZXNzYWdlLml0ZW1zLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnJvb3QgPSBMaXZlT2JqZWN0Ll9mcm9tSXRlbXMobWVzc2FnZS5pdGVtcywgcG9vbCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbldyaXRlID0gc2VsZi5jdXJyZW50Py5jYW5Xcml0ZSA/PyB0cnVlO1xuICAgIGNvbnN0IHN0YWNrU2l6ZUJlZm9yZSA9IGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0LmluaXRpYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoY29udGV4dC5yb290LmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNhbldyaXRlKSB7XG4gICAgICAgICAgY29udGV4dC5yb290LnNldChrZXksIGNsb25lTHNvbihjb250ZXh0LmluaXRpYWxTdG9yYWdlW2tleV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEF0dGVtcHRlZCB0byBwb3B1bGF0ZSBtaXNzaW5nIHN0b3JhZ2Uga2V5ICcke2tleX0nLCBidXQgY3VycmVudCB1c2VyIGhhcyBubyB3cml0ZSBhY2Nlc3NgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSBzdGFja1NpemVCZWZvcmU7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUm9vdChpdGVtcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbaWQsIG5vZGVdIG9mIGNvbnRleHQubm9kZXMpIHtcbiAgICAgIGN1cnJlbnRJdGVtcy5zZXQoaWQsIG5vZGUuX3NlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ldyBNYXAoaXRlbXMpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhvcHMsIGZhbHNlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gIH1cbiAgZnVuY3Rpb24gX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC51bmRvU3RhY2subGVuZ3RoID49IDUwKSB7XG4gICAgICBjb250ZXh0LnVuZG9TdGFjay5zaGlmdCgpO1xuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5wdXNoKGhpc3RvcnlPcHMpO1xuICAgIG9uSGlzdG9yeUNoYW5nZShiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnBhdXNlZEhpc3RvcnkgIT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeS51bnNoaWZ0KC4uLmhpc3RvcnlPcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeSh1cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXM7XG4gICAgY29uc3Qgb3RoZXJzVXBkYXRlcyA9IHVwZGF0ZXMub3RoZXJzO1xuICAgIGJhdGNoZWRVcGRhdGVzV3JhcHBlcigoKSA9PiB7XG4gICAgICBpZiAob3RoZXJzVXBkYXRlcyAhPT0gdm9pZCAwICYmIG90aGVyc1VwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5jdXJyZW50O1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIG90aGVyc1VwZGF0ZXMpIHtcbiAgICAgICAgICBldmVudEh1Yi5vdGhlcnMubm90aWZ5KHsgLi4uZXZlbnQsIG90aGVycyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMucHJlc2VuY2UgPz8gZmFsc2UpIHtcbiAgICAgICAgbm90aWZ5U2VsZkNoYW5nZWQoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICBldmVudEh1Yi5teVByZXNlbmNlLm5vdGlmeShjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcmFnZVVwZGF0ZXMgIT09IHZvaWQgMCAmJiBzdG9yYWdlVXBkYXRlcy5zaXplID4gMCkge1xuICAgICAgICBjb25zdCB1cGRhdGVzMiA9IEFycmF5LmZyb20oc3RvcmFnZVVwZGF0ZXMudmFsdWVzKCkpO1xuICAgICAgICBldmVudEh1Yi5zdG9yYWdlQmF0Y2gubm90aWZ5KHVwZGF0ZXMyKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDb25uZWN0aW9uSWQoKSB7XG4gICAgY29uc3QgaW5mbyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmFjdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludGVybmFsLiBUcmllZCB0byBnZXQgY29ubmVjdGlvbiBpZCBidXQgY29ubmVjdGlvbiB3YXMgbmV2ZXIgb3BlblwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wcyhyYXdPcHMsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICByZXZlcnNlOiBbXSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJlc2VuY2U6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb3BzID0gcmF3T3BzLm1hcCgob3ApID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIgJiYgIW9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3AsIG9wSWQ6IHBvb2wuZ2VuZXJhdGVPcElkKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb25zdCByZXZlcnNlID0ge1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgcmV2ZXJzZS5kYXRhW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChvcC5kYXRhKTtcbiAgICAgICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHsgdHlwZTogXCJwYXJ0aWFsXCIsIGRhdGE6IG9wLmRhdGEgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3AuZGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucmV2ZXJzZS51bnNoaWZ0KHJldmVyc2UpO1xuICAgICAgICBvdXRwdXQucHJlc2VuY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgICAgICBzb3VyY2UgPSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvcElkID0gbm4ob3Aub3BJZCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5kZWxldGUob3BJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICBzb3VyY2UgPSBkZWxldGVkID8gMiAvKiBBQ0sgKi8gOiAxIC8qIFJFTU9URSAqLztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBseU9wUmVzdWx0ID0gYXBwbHlPcChvcCwgc291cmNlKTtcbiAgICAgICAgaWYgKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQpIHtcbiAgICAgICAgICBjb25zdCBub2RlSWQgPSBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkO1xuICAgICAgICAgIGlmICghKG5vZGVJZCAmJiBjcmVhdGVkTm9kZUlkcy5oYXMobm9kZUlkKSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgIG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpLFxuICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5nZXQobm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCkpLFxuICAgICAgICAgICAgICAgIGFwcGx5T3BSZXN1bHQubW9kaWZpZWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG91dHB1dC5yZXZlcnNlLnVuc2hpZnQoLi4uYXBwbHlPcFJlc3VsdC5yZXZlcnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IDIgLyogQ1JFQVRFX0xJU1QgKi8gfHwgb3AudHlwZSA9PT0gNyAvKiBDUkVBVEVfTUFQICovIHx8IG9wLnR5cGUgPT09IDQgLyogQ1JFQVRFX09CSkVDVCAqLykge1xuICAgICAgICAgICAgY3JlYXRlZE5vZGVJZHMuYWRkKG5uKG9wLmlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvcHMsXG4gICAgICByZXZlcnNlOiBvdXRwdXQucmV2ZXJzZSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IG91dHB1dC5zdG9yYWdlVXBkYXRlcyxcbiAgICAgICAgcHJlc2VuY2U6IG91dHB1dC5wcmVzZW5jZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcChvcCwgc291cmNlKSB7XG4gICAgaWYgKGlzQWNrT3Aob3ApKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi86XG4gICAgICBjYXNlIDMgLyogVVBEQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuX2FwcGx5KG9wLCBzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgMSAvKiBTRVRfUEFSRU5UX0tFWSAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLnBhcmVudElkKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnROb2RlLl9hdHRhY2hDaGlsZChvcCwgc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUHJlc2VuY2UocGF0Y2gsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qgb2xkVmFsdWVzID0ge307XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgICB0eXBlOiBcInBhcnRpYWxcIixcbiAgICAgICAgZGF0YToge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBvdmVycmlkZVZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3ZlcnJpZGVWYWx1ZTtcbiAgICAgIG9sZFZhbHVlc1trZXldID0gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnRba2V5XTtcbiAgICB9XG4gICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKHBhdGNoKTtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiBvbGRWYWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnVwZGF0ZXMucHJlc2VuY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhcbiAgICAgICAgICAgIFt7IHR5cGU6IFwicHJlc2VuY2VcIiwgZGF0YTogb2xkVmFsdWVzIH1dLFxuICAgICAgICAgICAgZG9Ob3RCYXRjaFVwZGF0ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeSh7IHByZXNlbmNlOiB0cnVlIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudGFyZ2V0QWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgb2xkVXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgY29uc3QgbmV3VXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBpZiAob2xkVXNlciA9PT0gdm9pZCAwICYmIG5ld1VzZXIgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVudGVyXCIsIHVzZXI6IG5ld1VzZXIgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5vdGhlcnMucGF0Y2hPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpLCBtZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgdXBkYXRlczogbWVzc2FnZS5kYXRhLFxuICAgICAgICB1c2VyXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24obWVzc2FnZS5hY3Rvcik7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxlYXZlXCIsIHVzZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gb25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICBhY3RvcjogbWVzc2FnZS5hY3RvcixcbiAgICAgIG5vbmNlOiBtZXNzYWdlLm5vbmNlLFxuICAgICAgc2NvcGVzOiBtZXNzYWdlLnNjb3Blc1xuICAgIH0pO1xuICAgIGNvbnRleHQuaWRGYWN0b3J5ID0gbWFrZUlkRmFjdG9yeShtZXNzYWdlLmFjdG9yKTtcbiAgICBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIGZvciAoY29uc3QgY29ubmVjdGlvbklkIG9mIGNvbnRleHQub3RoZXJzLmNvbm5lY3Rpb25JZHMoKSkge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNbY29ubmVjdGlvbklkXTtcbiAgICAgIGlmICh1c2VyID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dC5vdGhlcnMucmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXNzYWdlLnVzZXJzKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1trZXldO1xuICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gTnVtYmVyKGtleSk7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRDb25uZWN0aW9uKFxuICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgIHVzZXIuaWQsXG4gICAgICAgIHVzZXIuaW5mbyxcbiAgICAgICAgdXNlci5zY29wZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwicmVzZXRcIiB9O1xuICB9XG4gIGZ1bmN0aW9uIGNhblVuZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gY2FuUmVkbygpIHtcbiAgICByZXR1cm4gY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBvbkhpc3RvcnlDaGFuZ2UoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGV2ZW50SHViLmhpc3Rvcnkubm90aWZ5KHsgY2FuVW5kbzogY2FuVW5kbygpLCBjYW5SZWRvOiBjYW5SZWRvKCkgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgIG1lc3NhZ2UuYWN0b3IsXG4gICAgICBtZXNzYWdlLmlkLFxuICAgICAgbWVzc2FnZS5pbmZvLFxuICAgICAgbWVzc2FnZS5zY29wZXNcbiAgICApO1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgIGRhdGE6IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgdGFyZ2V0QWN0b3I6IG1lc3NhZ2UuYWN0b3JcbiAgICB9KTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIHJldHVybiB1c2VyID8geyB0eXBlOiBcImVudGVyXCIsIHVzZXIgfSA6IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICghaXNKc29uT2JqZWN0KGRhdGEpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlcyh0ZXh0KSB7XG4gICAgY29uc3QgZGF0YSA9IHRyeVBhcnNlSnNvbih0ZXh0KTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGlzSnNvbkFycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gY29tcGFjdChkYXRhLm1hcCgoaXRlbSkgPT4gcGFyc2VTZXJ2ZXJNZXNzYWdlKGl0ZW0pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21wYWN0KFtwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSldKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlBbmRTZW5kT3BzKG9mZmxpbmVPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChvZmZsaW5lT3BzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBjb25zdCBvcHMgPSBBcnJheS5mcm9tKG9mZmxpbmVPcHMudmFsdWVzKCkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgdHJ1ZSk7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICBvcHM6IHJlc3VsdC5vcHNcbiAgICB9KTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTZXJ2ZXJNZXNzYWdlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gcGFyc2VTZXJ2ZXJNZXNzYWdlcyhldmVudC5kYXRhKTtcbiAgICBpZiAobWVzc2FnZXMgPT09IG51bGwgfHwgbWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZXMgPSB7XG4gICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIG90aGVyczogW11cbiAgICB9O1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIDEwMSAvKiBVU0VSX0pPSU5FRCAqLzoge1xuICAgICAgICAgICAgY29uc3QgdXNlckpvaW5lZFVwZGF0ZSA9IG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodXNlckpvaW5lZFVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKHVzZXJKb2luZWRVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzUHJlc2VuY2VVcGRhdGUgPSBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChvdGhlcnNQcmVzZW5jZVVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG90aGVyc1ByZXNlbmNlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMyAvKiBCUk9BRENBU1RFRF9FVkVOVCAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuY3VycmVudDtcbiAgICAgICAgICAgIGV2ZW50SHViLmN1c3RvbUV2ZW50Lm5vdGlmeSh7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogbWVzc2FnZS5hY3RvcixcbiAgICAgICAgICAgICAgdXNlcjogbWVzc2FnZS5hY3RvciA8IDAgPyBudWxsIDogb3RoZXJzLmZpbmQoKHUpID0+IHUuY29ubmVjdGlvbklkID09PSBtZXNzYWdlLmFjdG9yKSA/PyBudWxsLFxuICAgICAgICAgICAgICBldmVudDogbWVzc2FnZS5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDIgLyogVVNFUl9MRUZUICovOiB7XG4gICAgICAgICAgICBjb25zdCBldmVudDIgPSBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChldmVudDIpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChldmVudDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMzAwIC8qIFVQREFURV9ZRE9DICovOiB7XG4gICAgICAgICAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwNCAvKiBST09NX1NUQVRFICovOiB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLzoge1xuICAgICAgICAgICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAxIC8qIFVQREFURV9TVE9SQUdFICovOiB7XG4gICAgICAgICAgICBjb25zdCBhcHBseVJlc3VsdCA9IGFwcGx5T3BzKG1lc3NhZ2Uub3BzLCBmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhcHBseVJlc3VsdC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksIHZhbHVlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjk5IC8qIFJFSkVDVF9TVE9SQUdFX09QICovOiB7XG4gICAgICAgICAgICBlcnJvcldpdGhUaXRsZShcbiAgICAgICAgICAgICAgXCJTdG9yYWdlIG11dGF0aW9uIHJlamVjdGlvbiBlcnJvclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlLnJlYXNvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBvcElkIG9mIG1lc3NhZ2Uub3BJZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZSA9IGNvbnRleHQub3BTdGFja1RyYWNlcz8uZ2V0KG9wSWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgICAgdHJhY2VzLmFkZCh0cmFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB3YXJuV2l0aFRpdGxlKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGNhbGxzIGNhdXNlZCB0aGUgcmVqZWN0ZWQgc3RvcmFnZSBtdXRhdGlvbnM6XCIsXG4gICAgICAgICAgICAgICAgICBgXG5cbiR7QXJyYXkuZnJvbSh0cmFjZXMpLmpvaW4oXCJcXG5cXG5cIil9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBTdG9yYWdlIG11dGF0aW9ucyByZWplY3RlZCBieSBzZXJ2ZXI6ICR7bWVzc2FnZS5yZWFzb259YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNDAwIC8qIFRIUkVBRF9DUkVBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA3IC8qIFRIUkVBRF9ERUxFVEVEICovOlxuICAgICAgICAgIGNhc2UgNDAxIC8qIFRIUkVBRF9NRVRBREFUQV9VUERBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA4IC8qIFRIUkVBRF9VUERBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA1IC8qIENPTU1FTlRfUkVBQ1RJT05fQURERUQgKi86XG4gICAgICAgICAgY2FzZSA0MDYgLyogQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEICovOlxuICAgICAgICAgIGNhc2UgNDAyIC8qIENPTU1FTlRfQ1JFQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMyAvKiBDT01NRU5UX0VESVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNCAvKiBDT01NRU5UX0RFTEVURUQgKi86IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmNvbW1lbnRzLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm90aWZ5KHVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmbHVzaE5vd09yU29vbigpIHtcbiAgICBjb25zdCBzdG9yYWdlT3BzID0gY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnM7XG4gICAgaWYgKHN0b3JhZ2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBzdG9yYWdlT3BzKSB7XG4gICAgICAgIGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuc2V0KG5uKG9wLm9wSWQpLCBvcCk7XG4gICAgICB9XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucyA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRNaWxsaXMgPSBub3cgLSBjb250ZXh0LmJ1ZmZlci5sYXN0Rmx1c2hlZEF0O1xuICAgIGlmIChlbGFwc2VkTWlsbGlzID49IGNvbmZpZy50aHJvdHRsZURlbGF5KSB7XG4gICAgICBjb25zdCBtZXNzYWdlc1RvRmx1c2ggPSBzZXJpYWxpemVCdWZmZXIoKTtcbiAgICAgIGlmIChtZXNzYWdlc1RvRmx1c2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlc1RvRmx1c2gpO1xuICAgICAgY29udGV4dC5idWZmZXIgPSB7XG4gICAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgICBsYXN0Rmx1c2hlZEF0OiBub3csXG4gICAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdLFxuICAgICAgICBwcmVzZW5jZVVwZGF0ZXM6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQpO1xuICAgICAgY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEID0gc2V0VGltZW91dChcbiAgICAgICAgZmx1c2hOb3dPclNvb24sXG4gICAgICAgIGNvbmZpZy50aHJvdHRsZURlbGF5IC0gZWxhcHNlZE1pbGxpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKCkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChcbiAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLnR5cGUgPT09IFwiZnVsbFwiID8ge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgLy8gUG9wdWxhdGluZyB0aGUgYHRhcmdldEFjdG9yYCBmaWVsZCB0dXJucyB0aGlzIG1lc3NhZ2UgaW50b1xuICAgICAgICAgIC8vIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGUgbWVzc2FnZSAobm90IGEgcGF0Y2gpLCB3aGljaCB3aWxsIGdldFxuICAgICAgICAgIC8vIGludGVycHJldGVkIGJ5IG90aGVyIGNsaWVudHMgYXMgc3VjaC5cbiAgICAgICAgICB0YXJnZXRBY3RvcjogLTEsXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgY29udGV4dC5idWZmZXIubWVzc2FnZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLyxcbiAgICAgICAgb3BzOiBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVZRG9jKHVwZGF0ZSwgZ3VpZCkge1xuICAgIGNvbnN0IGNsaWVudE1zZyA9IHtcbiAgICAgIHR5cGU6IDMwMSAvKiBVUERBVEVfWURPQyAqLyxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIGd1aWRcbiAgICB9O1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goY2xpZW50TXNnKTtcbiAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShjbGllbnRNc2cpO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyID0ge1xuICAgIHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIgJiYgIW9wdGlvbnMyLnNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAzIC8qIEJST0FEQ0FTVF9FVkVOVCAqLyxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaE9wcyhvcHMpIHtcbiAgICBjb25zdCB7IHN0b3JhZ2VPcGVyYXRpb25zIH0gPSBjb250ZXh0LmJ1ZmZlcjtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgbGV0IF9nZXRTdG9yYWdlJCA9IG51bGw7XG4gIGxldCBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wcyA9IG5ldyBNYXAoY29udGV4dC51bmFja25vd2xlZGdlZE9wcyk7XG4gICAgY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIGFwcGx5QW5kU2VuZE9wcyh1bmFja25vd2xlZGdlZE9wcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2U/LigpO1xuICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5ub3RpZnkoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdHJlYW1TdG9yYWdlKCkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHJldHVybjtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50MS5yYXdHZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9zdG9yYWdlYFxuICAgICk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZSh7IHR5cGU6IDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi8sIGl0ZW1zIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2hTdG9yYWdlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcztcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX3N0cmVhbURhdGEpIHtcbiAgICAgIHZvaWQgc3RyZWFtU3RvcmFnZSgpO1xuICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2VzLnNvbWUoKG1zZykgPT4gbXNnLnR5cGUgPT09IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovKSkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IHR5cGU6IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9uczIuZmx1c2gpIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKSB7XG4gICAgaWYgKF9nZXRTdG9yYWdlJCA9PT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogdHJ1ZSB9KTtcbiAgICAgIF9nZXRTdG9yYWdlJCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0U3RvcmFnZSQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVNuYXBzaG90KCkge1xuICAgIGNvbnN0IHJvb3QgPSBjb250ZXh0LnJvb3Q7XG4gICAgaWYgKHJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcm9vdDogY29udGV4dC5yb290XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiBubihjb250ZXh0LnJvb3QpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaFlEb2ModmVjdG9yLCBndWlkKSB7XG4gICAgaWYgKCFjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5maW5kKChtKSA9PiB7XG4gICAgICByZXR1cm4gbS50eXBlID09PSAzMDAgLyogRkVUQ0hfWURPQyAqLyAmJiBtLnZlY3RvciA9PT0gdmVjdG9yICYmIG0uZ3VpZCA9PT0gZ3VpZDtcbiAgICB9KSkge1xuICAgICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDMwMCAvKiBGRVRDSF9ZRE9DICovLFxuICAgICAgICB2ZWN0b3IsXG4gICAgICAgIGd1aWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC5yZWRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiByZWRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5yZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgICAgb25IaXN0b3J5Q2hhbmdlKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gMDtcbiAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSB7XG4gICAgICAgIG9wczogW10sXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgICBwcmVzZW5jZTogZmFsc2UsXG4gICAgICAgICAgb3RoZXJzOiBbXVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlT3BzOiBbXVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXRjaCA9IGNvbnRleHQuYWN0aXZlQmF0Y2g7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSBudWxsO1xuICAgICAgICBpZiAoY3VycmVudEJhdGNoLnJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRpc3BhdGNoT3BzKGN1cnJlbnRCYXRjaC5vcHMpO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeShjdXJyZW50QmF0Y2gudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZUhpc3RvcnkoKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gW107XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhpc3RvcnkoKSB7XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucGF1c2VkSGlzdG9yeTtcbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGlmIChoaXN0b3J5T3BzICE9PSBudWxsICYmIGhpc3RvcnlPcHMubGVuZ3RoID4gMCkge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaFVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHVzKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIF9nZXRTdG9yYWdlJCA9PT0gbnVsbCA/IFwibm90LWxvYWRlZFwiIDogXCJsb2FkaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNpemUgPT09IDAgPyBcInN5bmNocm9uaXplZFwiIDogXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9XG4gIGxldCBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgICBpZiAoX2xhc3RTdG9yYWdlU3RhdHVzICE9PSBzdG9yYWdlU3RhdHVzKSB7XG4gICAgICBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBzdG9yYWdlU3RhdHVzO1xuICAgICAgZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5ub3RpZnkoc3RvcmFnZVN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzUHJlc2VuY2VSZWFkeSgpIHtcbiAgICByZXR1cm4gc2VsZi5jdXJyZW50ICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSB7XG4gICAgd2hpbGUgKCFpc1ByZXNlbmNlUmVhZHkoKSkge1xuICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGNvbnN0IHVuc3ViMSA9IGV2ZW50cy5zZWxmLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBjb25zdCB1bnN1YjIgPSBldmVudHMuc3RhdHVzLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgdW5zdWIxKCk7XG4gICAgICB1bnN1YjIoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdG9yYWdlUmVhZHkoKSB7XG4gICAgcmV0dXJuIGdldFN0b3JhZ2VTbmFwc2hvdCgpICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgICB3aGlsZSAoIWlzU3RvcmFnZVJlYWR5KCkpIHtcbiAgICAgIGF3YWl0IGdldFN0b3JhZ2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3RoZXJzX2ZvckRldlRvb2xzID0gbmV3IERlcml2ZWRSZWYoXG4gICAgY29udGV4dC5vdGhlcnMsXG4gICAgKG90aGVycykgPT4gb3RoZXJzLm1hcCgob3RoZXIsIGluZGV4KSA9PiB1c2VyVG9UcmVlTm9kZShgT3RoZXIgJHtpbmRleH1gLCBvdGhlcikpXG4gICk7XG4gIGNvbnN0IGV2ZW50cyA9IHtcbiAgICBzdGF0dXM6IGV2ZW50SHViLnN0YXR1cy5vYnNlcnZhYmxlLFxuICAgIGxvc3RDb25uZWN0aW9uOiBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5vYnNlcnZhYmxlLFxuICAgIGN1c3RvbUV2ZW50OiBldmVudEh1Yi5jdXN0b21FdmVudC5vYnNlcnZhYmxlLFxuICAgIG90aGVyczogZXZlbnRIdWIub3RoZXJzLm9ic2VydmFibGUsXG4gICAgc2VsZjogZXZlbnRIdWIuc2VsZi5vYnNlcnZhYmxlLFxuICAgIG15UHJlc2VuY2U6IGV2ZW50SHViLm15UHJlc2VuY2Uub2JzZXJ2YWJsZSxcbiAgICBlcnJvcjogZXZlbnRIdWIuZXJyb3Iub2JzZXJ2YWJsZSxcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBzdG9yYWdlOiBldmVudEh1Yi5zdG9yYWdlQmF0Y2gub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlQmF0Y2g6IGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5vYnNlcnZhYmxlLFxuICAgIGhpc3Rvcnk6IGV2ZW50SHViLmhpc3Rvcnkub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlRGlkTG9hZDogZXZlbnRIdWIuc3RvcmFnZURpZExvYWQub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlU3RhdHVzOiBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm9ic2VydmFibGUsXG4gICAgeWRvYzogZXZlbnRIdWIueWRvYy5vYnNlcnZhYmxlLFxuICAgIGNvbW1lbnRzOiBldmVudEh1Yi5jb21tZW50cy5vYnNlcnZhYmxlXG4gIH07XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZHNTaW5jZShvcHRpb25zMikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQyLmdldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHMvZGVsdGFgLFxuICAgICAgeyBzaW5jZTogb3B0aW9uczI/LnNpbmNlPy50b0lTT1N0cmluZygpIH0sXG4gICAgICB7IHNpZ25hbDogb3B0aW9uczIuc2lnbmFsIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0aHJlYWRzOiB7XG4gICAgICAgIHVwZGF0ZWQ6IHJlc3VsdC5kYXRhLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgZGVsZXRlZDogcmVzdWx0LmRlbGV0ZWRUaHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKVxuICAgICAgfSxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICB1cGRhdGVkOiByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLm1hcChjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEpLFxuICAgICAgICBkZWxldGVkOiByZXN1bHQuZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUocmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMyKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zMj8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zMi5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IFBBR0VfU0laRSA9IDUwO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50Mi5nZXQodXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkc2AsIHtcbiAgICAgICAgY3Vyc29yOiBvcHRpb25zMj8uY3Vyc29yLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgbGltaXQ6IFBBR0VfU0laRVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiByZXN1bHQuZGF0YS5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhXG4gICAgICAgICksXG4gICAgICAgIG5leHRDdXJzb3I6IHJlc3VsdC5tZXRhLm5leHRDdXJzb3IsXG4gICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSHR0cEVycm9yICYmIGVyci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRocmVhZHM6IFtdLFxuICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogW10sXG4gICAgICAgICAgbmV4dEN1cnNvcjogbnVsbCxcbiAgICAgICAgICByZXF1ZXN0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkKHRocmVhZElkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50Mi5yYXdHZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWQtd2l0aC1ub3RpZmljYXRpb24vJHt0aHJlYWRJZH1gXG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWQ6IGNvbnZlcnRUb1RocmVhZERhdGEoanNvbi50aHJlYWQpLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbjoganNvbi5pbmJveE5vdGlmaWNhdGlvbiA/IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShqc29uLmluYm94Tm90aWZpY2F0aW9uKSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWQ6IHZvaWQgMCxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb246IHZvaWQgMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aHJlYWQgJHt0aHJlYWRJZH0uYCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRocmVhZCh7XG4gICAgbWV0YWRhdGEsXG4gICAgYm9keSxcbiAgICBjb21tZW50SWQgPSBjcmVhdGVDb21tZW50SWQoKSxcbiAgICB0aHJlYWRJZCA9IGNyZWF0ZVRocmVhZElkKCksXG4gICAgYXR0YWNobWVudElkc1xuICB9KSB7XG4gICAgY29uc3QgdGhyZWFkID0gYXdhaXQgaHR0cENsaWVudDIucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHNgLFxuICAgICAge1xuICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgYXR0YWNobWVudElkc1xuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVUaHJlYWQodGhyZWFkSWQpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50Mi5kZWxldGUoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9YFxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdFRocmVhZE1ldGFkYXRhKHtcbiAgICBtZXRhZGF0YSxcbiAgICB0aHJlYWRJZFxuICB9KSB7XG4gICAgcmV0dXJuIGF3YWl0IGh0dHBDbGllbnQyLnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L21ldGFkYXRhYCxcbiAgICAgIG1ldGFkYXRhXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNSZXNvbHZlZCh0aHJlYWRJZCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQyLnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L21hcmstYXMtcmVzb2x2ZWRgXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNVbnJlc29sdmVkKHRocmVhZElkKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudDIucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vbWFyay1hcy11bnJlc29sdmVkYFxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCksXG4gICAgYm9keSxcbiAgICBhdHRhY2htZW50SWRzXG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgaHR0cENsaWVudDIucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHNgLFxuICAgICAge1xuICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICBib2R5LFxuICAgICAgICBhdHRhY2htZW50SWRzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdENvbW1lbnQoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBib2R5LFxuICAgIGF0dGFjaG1lbnRJZHNcbiAgfSkge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBodHRwQ2xpZW50Mi5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH1gLFxuICAgICAge1xuICAgICAgICBib2R5LFxuICAgICAgICBhdHRhY2htZW50SWRzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkXG4gIH0pIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50Mi5kZWxldGUoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWBcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgaHR0cENsaWVudDIucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHMvJHtjb21tZW50SWR9L3JlYWN0aW9uc2AsXG4gICAgICB7IGVtb2ppIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKHJlYWN0aW9uKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW1vdmVSZWFjdGlvbih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50Mi5kZWxldGUoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfS9yZWFjdGlvbnMvJHtlbW9qaX1gXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwYXJlQXR0YWNobWVudChmaWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibG9jYWxBdHRhY2htZW50XCIsXG4gICAgICBzdGF0dXM6IFwiaWRsZVwiLFxuICAgICAgaWQ6IGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQoKSxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICBmaWxlXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRBdHRhY2htZW50KGF0dGFjaG1lbnQsIG9wdGlvbnMyID0ge30pIHtcbiAgICBjb25zdCBhYm9ydFNpZ25hbCA9IG9wdGlvbnMyLnNpZ25hbDtcbiAgICBjb25zdCBhYm9ydEVycm9yID0gYWJvcnRTaWduYWwgPyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgYFVwbG9hZCBvZiBhdHRhY2htZW50ICR7YXR0YWNobWVudC5pZH0gd2FzIGFib3J0ZWQuYCxcbiAgICAgIFwiQWJvcnRFcnJvclwiXG4gICAgKSA6IHZvaWQgMDtcbiAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVJldHJ5RXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBIdHRwRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDEzKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChhdHRhY2htZW50LnNpemUgPD0gQVRUQUNITUVOVF9QQVJUX1NJWkUpIHtcbiAgICAgIHJldHVybiBhdXRvUmV0cnkoXG4gICAgICAgICgpID0+IGh0dHBDbGllbnQyLnB1dEJsb2IoXG4gICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS91cGxvYWQvJHtlbmNvZGVVUklDb21wb25lbnQoYXR0YWNobWVudC5uYW1lKX1gLFxuICAgICAgICAgIGF0dGFjaG1lbnQuZmlsZSxcbiAgICAgICAgICB7IGZpbGVTaXplOiBhdHRhY2htZW50LnNpemUgfSxcbiAgICAgICAgICB7IHNpZ25hbDogYWJvcnRTaWduYWwgfVxuICAgICAgICApLFxuICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgUkVUUllfREVMQVlTLFxuICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdXBsb2FkSWQ7XG4gICAgICBjb25zdCB1cGxvYWRlZFBhcnRzID0gW107XG4gICAgICBjb25zdCBjcmVhdGVNdWx0aVBhcnRVcGxvYWQgPSBhd2FpdCBhdXRvUmV0cnkoXG4gICAgICAgICgpID0+IGh0dHBDbGllbnQyLnBvc3QoXG4gICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHtlbmNvZGVVUklDb21wb25lbnQoYXR0YWNobWVudC5uYW1lKX1gLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICB7IHNpZ25hbDogYWJvcnRTaWduYWwgfSxcbiAgICAgICAgICB7IGZpbGVTaXplOiBhdHRhY2htZW50LnNpemUgfVxuICAgICAgICApLFxuICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgUkVUUllfREVMQVlTLFxuICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXBsb2FkSWQgPSBjcmVhdGVNdWx0aVBhcnRVcGxvYWQudXBsb2FkSWQ7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gc3BsaXRGaWxlSW50b1BhcnRzKGF0dGFjaG1lbnQuZmlsZSk7XG4gICAgICAgIGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IGNodW5rKHBhcnRzLCBBVFRBQ0hNRU5UX1BBUlRfQkFUQ0hfU0laRSk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydHMyIG9mIGJhdGNoZXMpIHtcbiAgICAgICAgICBjb25zdCB1cGxvYWRlZFBhcnRzUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgcGFydCwgcGFydE51bWJlciB9IG9mIHBhcnRzMikge1xuICAgICAgICAgICAgdXBsb2FkZWRQYXJ0c1Byb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIGF1dG9SZXRyeShcbiAgICAgICAgICAgICAgICAoKSA9PiBodHRwQ2xpZW50Mi5wdXRCbG9iKFxuICAgICAgICAgICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7Y29uZmlnLnJvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHtjcmVhdGVNdWx0aVBhcnRVcGxvYWQudXBsb2FkSWR9LyR7U3RyaW5nKHBhcnROdW1iZXIpfWAsXG4gICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJFVFJZX0FUVEVNUFRTLFxuICAgICAgICAgICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwbG9hZGVkUGFydHMucHVzaCguLi5hd2FpdCBQcm9taXNlLmFsbCh1cGxvYWRlZFBhcnRzUHJvbWlzZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvcnRlZFVwbG9hZGVkUGFydHMgPSB1cGxvYWRlZFBhcnRzLnNvcnQoXG4gICAgICAgICAgKGEsIGIpID0+IGEucGFydE51bWJlciAtIGIucGFydE51bWJlclxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaHR0cENsaWVudDIucG9zdChcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9hdHRhY2htZW50cy8ke2F0dGFjaG1lbnQuaWR9L211bHRpcGFydC8ke3VwbG9hZElkfS9jb21wbGV0ZWAsXG4gICAgICAgICAgeyBwYXJ0czogc29ydGVkVXBsb2FkZWRQYXJ0cyB9LFxuICAgICAgICAgIHsgc2lnbmFsOiBhYm9ydFNpZ25hbCB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgICAgaWYgKHVwbG9hZElkICYmIGVycm9yMz8ubmFtZSAmJiAoZXJyb3IzLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yMy5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBodHRwQ2xpZW50Mi5yYXdEZWxldGUoXG4gICAgICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7dXBsb2FkSWR9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjQpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRBdHRhY2htZW50VXJscyhhdHRhY2htZW50SWRzKSB7XG4gICAgY29uc3QgeyB1cmxzIH0gPSBhd2FpdCBodHRwQ2xpZW50Mi5wb3N0KHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L2F0dGFjaG1lbnRzL3ByZXNpZ25lZC11cmxzYCwge1xuICAgICAgYXR0YWNobWVudElkc1xuICAgIH0pO1xuICAgIHJldHVybiB1cmxzO1xuICB9XG4gIGNvbnN0IGJhdGNoZWRHZXRBdHRhY2htZW50VXJscyA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEF0dGFjaG1lbnRJZHMpID0+IHtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBiYXRjaGVkQXR0YWNobWVudElkcy5mbGF0KCk7XG4gICAgICBjb25zdCBhdHRhY2htZW50VXJscyA9IGF3YWl0IGdldEF0dGFjaG1lbnRVcmxzKGF0dGFjaG1lbnRJZHMpO1xuICAgICAgcmV0dXJuIGF0dGFjaG1lbnRVcmxzLm1hcChcbiAgICAgICAgKHVybDIpID0+IHVybDIgPz8gbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhpcyBhdHRhY2htZW50J3MgVVJMXCIpXG4gICAgICApO1xuICAgIH0sXG4gICAgeyBkZWxheTogR0VUX0FUVEFDSE1FTlRfVVJMU19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IGF0dGFjaG1lbnRVcmxzU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoZWRHZXRBdHRhY2htZW50VXJscyk7XG4gIGZ1bmN0aW9uIGdldEF0dGFjaG1lbnRVcmwoYXR0YWNobWVudElkKSB7XG4gICAgcmV0dXJuIGJhdGNoZWRHZXRBdHRhY2htZW50VXJscy5nZXQoYXR0YWNobWVudElkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmZXRjaE5vdGlmaWNhdGlvbnNKc29uKGVuZHBvaW50LCBvcHRpb25zMikge1xuICAgIHJldHVybiBhd2FpdCBodHRwQ2xpZW50Mi5nZXQoZW5kcG9pbnQsIHZvaWQgMCwgb3B0aW9uczIpO1xuICB9XG4gIGZ1bmN0aW9uIGdldE5vdGlmaWNhdGlvblNldHRpbmdzKG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgLFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnMyPy5zaWduYWwgfVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke2NvbmZpZy5yb29tSWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcykge1xuICAgIGF3YWl0IGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtjb25maWcucm9vbUlkfS9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGluYm94Tm90aWZpY2F0aW9uSWRzIH0pXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBjb25zdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZCA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICBhd2FpdCBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICB9LFxuICAgIHsgZGVsYXk6IDUwIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBba0ludGVybmFsXToge1xuICAgICAgICBnZXQgcHJlc2VuY2VCdWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXM/LmRhdGEgPz8gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgdW5kb1N0YWNrKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC51bmRvU3RhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IG5vZGVDb3VudCgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5ub2Rlcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0UHJvdmlkZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQucHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgIGNvbnRleHQub25Qcm92aWRlclVwZGF0ZS5ub3RpZnkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qcm92aWRlclVwZGF0ZTogY29udGV4dC5vblByb3ZpZGVyVXBkYXRlLm9ic2VydmFibGUsXG4gICAgICAgIC8vIHNlbmQgbWV0YWRhdGEgd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIHJlcG9ydFRleHRFZGl0b3IsXG4gICAgICAgIC8vIGNyZWF0ZSBhIHRleHQgbWVudGlvbiB3aGVuIHVzaW5nIGEgdGV4dCBlZGl0b3JcbiAgICAgICAgY3JlYXRlVGV4dE1lbnRpb24sXG4gICAgICAgIC8vIGRlbGV0ZSBhIHRleHQgbWVudGlvbiB3aGVuIHVzaW5nIGEgdGV4dCBlZGl0b3JcbiAgICAgICAgZGVsZXRlVGV4dE1lbnRpb24sXG4gICAgICAgIC8vIGxpc3QgdmVyc2lvbnMgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGxpc3RUZXh0VmVyc2lvbnMsXG4gICAgICAgIC8vIExpc3QgdmVyc2lvbnMgb2YgdGhlIGRvY3VtZW50IHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZVxuICAgICAgICBsaXN0VGV4dFZlcnNpb25zU2luY2UsXG4gICAgICAgIC8vIGdldCBhIHNwZWNpZmljIHZlcnNpb25cbiAgICAgICAgZ2V0VGV4dFZlcnNpb24sXG4gICAgICAgIC8vIGNyZWF0ZSBhIHZlcnNpb25cbiAgICAgICAgY3JlYXRlVGV4dFZlcnNpb24sXG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHRoZSBMaXZlYmxvY2tzIGJyb3dzZXIgZXh0ZW5zaW9uXG4gICAgICAgIGdldFNlbGZfZm9yRGV2VG9vbHM6ICgpID0+IHNlbGZBc1RyZWVOb2RlLmN1cnJlbnQsXG4gICAgICAgIGdldE90aGVyc19mb3JEZXZUb29sczogKCkgPT4gb3RoZXJzX2ZvckRldlRvb2xzLmN1cnJlbnQsXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBzaW11bGF0ZToge1xuICAgICAgICAgIC8vIFRoZXNlIGV4aXN0IG9ubHkgZm9yIG91ciBFMkUgdGVzdGluZyBhcHBcbiAgICAgICAgICBleHBsaWNpdENsb3NlOiAoZXZlbnQpID0+IG1hbmFnZWRTb2NrZXQuX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSksXG4gICAgICAgICAgcmF3U2VuZDogKGRhdGEpID0+IG1hbmFnZWRTb2NrZXQuc2VuZChkYXRhKVxuICAgICAgICB9LFxuICAgICAgICBhdHRhY2htZW50VXJsc1N0b3JlXG4gICAgICB9LFxuICAgICAgaWQ6IGNvbmZpZy5yb29tSWQsXG4gICAgICBzdWJzY3JpYmU6IG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4oZXZlbnRzKSxcbiAgICAgIGNvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuY29ubmVjdCgpLFxuICAgICAgcmVjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LnJlY29ubmVjdCgpLFxuICAgICAgZGlzY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5kaXNjb25uZWN0KCksXG4gICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgIHVuaW5zdGFsbEJnVGFiU3B5KCk7XG4gICAgICAgIG1hbmFnZWRTb2NrZXQuZGVzdHJveSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFByZXNlbmNlXG4gICAgICB1cGRhdGVQcmVzZW5jZSxcbiAgICAgIHVwZGF0ZVlEb2MsXG4gICAgICBicm9hZGNhc3RFdmVudCxcbiAgICAgIC8vIFN0b3JhZ2VcbiAgICAgIGJhdGNoLFxuICAgICAgaGlzdG9yeToge1xuICAgICAgICB1bmRvLFxuICAgICAgICByZWRvLFxuICAgICAgICBjYW5VbmRvLFxuICAgICAgICBjYW5SZWRvLFxuICAgICAgICBjbGVhcixcbiAgICAgICAgcGF1c2U6IHBhdXNlSGlzdG9yeSxcbiAgICAgICAgcmVzdW1lOiByZXN1bWVIaXN0b3J5XG4gICAgICB9LFxuICAgICAgZmV0Y2hZRG9jLFxuICAgICAgZ2V0U3RvcmFnZSxcbiAgICAgIGdldFN0b3JhZ2VTbmFwc2hvdCxcbiAgICAgIGdldFN0b3JhZ2VTdGF0dXMsXG4gICAgICBpc1ByZXNlbmNlUmVhZHksXG4gICAgICBpc1N0b3JhZ2VSZWFkeSxcbiAgICAgIHdhaXRVbnRpbFByZXNlbmNlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsUHJlc2VuY2VSZWFkeSksXG4gICAgICB3YWl0VW50aWxTdG9yYWdlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsU3RvcmFnZVJlYWR5KSxcbiAgICAgIGV2ZW50cyxcbiAgICAgIC8vIENvcmVcbiAgICAgIGdldFN0YXR1czogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSxcbiAgICAgIGdldFNlbGY6ICgpID0+IHNlbGYuY3VycmVudCxcbiAgICAgIC8vIFByZXNlbmNlXG4gICAgICBnZXRQcmVzZW5jZTogKCkgPT4gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQsXG4gICAgICBnZXRPdGhlcnM6ICgpID0+IGNvbnRleHQub3RoZXJzLmN1cnJlbnQsXG4gICAgICAvLyBDb21tZW50c1xuICAgICAgZ2V0VGhyZWFkcyxcbiAgICAgIGdldFRocmVhZHNTaW5jZSxcbiAgICAgIGdldFRocmVhZCxcbiAgICAgIGNyZWF0ZVRocmVhZCxcbiAgICAgIGRlbGV0ZVRocmVhZCxcbiAgICAgIGVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIG1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgICAgbWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgICBlZGl0Q29tbWVudCxcbiAgICAgIGRlbGV0ZUNvbW1lbnQsXG4gICAgICBhZGRSZWFjdGlvbixcbiAgICAgIHJlbW92ZVJlYWN0aW9uLFxuICAgICAgcHJlcGFyZUF0dGFjaG1lbnQsXG4gICAgICB1cGxvYWRBdHRhY2htZW50LFxuICAgICAgZ2V0QXR0YWNobWVudFVybCxcbiAgICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAgIGdldE5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgICB9LFxuICAgIC8vIEV4cGxpY3RseSBtYWtlIHRoZSBpbnRlcm5hbCBmaWVsZCBub24tZW51bWVyYWJsZSwgdG8gYXZvaWQgYWdncmVzc2l2ZVxuICAgIC8vIGZyZWV6aW5nIHdoZW4gdXNlZCB3aXRoIEltbWVyXG4gICAga0ludGVybmFsLFxuICAgIHsgZW51bWVyYWJsZTogZmFsc2UgfVxuICApO1xufVxuZnVuY3Rpb24gbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihldmVudHMpIHtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBjb25zdCByZWxhdGVkVXBkYXRlcyA9IHVwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAodXBkYXRlKSA9PiBpc1NhbWVOb2RlT3JDaGlsZE9mKHVwZGF0ZS5ub2RlLCBub2RlKVxuICAgICAgKTtcbiAgICAgIGlmIChyZWxhdGVkVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlbGF0ZWRVcGRhdGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoKHVwZGF0ZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5ub2RlLl9pZCA9PT0gbm9kZS5faWQpIHtcbiAgICAgICAgICBjYWxsYmFjayh1cGRhdGUubm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZmlyc3QsIHNlY29uZCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgaXNSb29tRXZlbnROYW1lKGZpcnN0KSkge1xuICAgICAgaWYgKHR5cGVvZiBzZWNvbmQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwibXktcHJlc2VuY2VcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm15UHJlc2VuY2Uuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcIm90aGVyc1wiOiB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG90aGVycywgLi4uaW50ZXJuYWxFdmVudCB9ID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gY2Iob3RoZXJzLCBpbnRlcm5hbEV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmVycm9yLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJzdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwibG9zdC1jb25uZWN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJoaXN0b3J5XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJzdG9yYWdlLXN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZVN0YXR1cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJjb21tZW50c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuY29tbWVudHMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBhc3NlcnROZXZlcihcbiAgICAgICAgICAgIGZpcnN0LFxuICAgICAgICAgICAgYFwiJHtTdHJpbmcoZmlyc3QpfVwiIGlzIG5vdCBhIHZhbGlkIGV2ZW50IG5hbWVgXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlY29uZCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gZmlyc3Q7XG4gICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZShzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgYSBsaXN0ZW5lciBjYWxsYmFja1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTGl2ZU5vZGUoZmlyc3QpKSB7XG4gICAgICBjb25zdCBub2RlID0gZmlyc3Q7XG4gICAgICBpZiAob3B0aW9ucz8uaXNEZWVwKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIG5vZGVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke1N0cmluZyhmaXJzdCl9IGlzIG5vdCBhIHZhbHVlIHRoYXQgY2FuIGJlIHN1YnNjcmliZWQgdG8uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN1YnNjcmliZTtcbn1cbmZ1bmN0aW9uIGlzUm9vbUV2ZW50TmFtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibXktcHJlc2VuY2VcIiB8fCB2YWx1ZSA9PT0gXCJvdGhlcnNcIiB8fCB2YWx1ZSA9PT0gXCJldmVudFwiIHx8IHZhbHVlID09PSBcImVycm9yXCIgfHwgdmFsdWUgPT09IFwiaGlzdG9yeVwiIHx8IHZhbHVlID09PSBcInN0YXR1c1wiIHx8IHZhbHVlID09PSBcInN0b3JhZ2Utc3RhdHVzXCIgfHwgdmFsdWUgPT09IFwibG9zdC1jb25uZWN0aW9uXCIgfHwgdmFsdWUgPT09IFwiY29ubmVjdGlvblwiIHx8IHZhbHVlID09PSBcImNvbW1lbnRzXCI7XG59XG5mdW5jdGlvbiBtYWtlQXV0aERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGF1dGhNYW5hZ2VyKSB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLCByb29tSWQgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYmFzZVVybCwgV2ViU29ja2V0UG9seWZpbGwpIHtcbiAgcmV0dXJuIChhdXRoVmFsdWUpID0+IHtcbiAgICBjb25zdCB3cyA9IFdlYlNvY2tldFBvbHlmaWxsID8/ICh0eXBlb2YgV2ViU29ja2V0ID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDogV2ViU29ja2V0KTtcbiAgICBpZiAod3MgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCB5b3UgbmVlZCB0byBwcm92aWRlIGEgV2ViU29ja2V0IHBvbHlmaWxsLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cmwyID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICB1cmwyLnByb3RvY29sID0gdXJsMi5wcm90b2NvbCA9PT0gXCJodHRwOlwiID8gXCJ3c1wiIDogXCJ3c3NcIjtcbiAgICB1cmwyLnBhdGhuYW1lID0gXCIvdjdcIjtcbiAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJyb29tSWRcIiwgcm9vbUlkKTtcbiAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgIHVybDIuc2VhcmNoUGFyYW1zLnNldChcInRva1wiLCBhdXRoVmFsdWUudG9rZW4ucmF3KTtcbiAgICB9IGVsc2UgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJwdWJrZXlcIiwgYXV0aFZhbHVlLnB1YmxpY0FwaUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihhdXRoVmFsdWUsIFwiVW5oYW5kbGVkIGNhc2VcIik7XG4gICAgfVxuICAgIHVybDIuc2VhcmNoUGFyYW1zLnNldChcInZlcnNpb25cIiwgUEtHX1ZFUlNJT04gfHwgXCJkZXZcIik7XG4gICAgcmV0dXJuIG5ldyB3cyh1cmwyLnRvU3RyaW5nKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTUlOX1RIUk9UVExFID0gMTY7XG52YXIgTUFYX1RIUk9UVExFID0gMWUzO1xudmFyIERFRkFVTFRfVEhST1RUTEUgPSAxMDA7XG52YXIgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUID0gMTVlMztcbnZhciBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAyMDA7XG52YXIgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMWUzO1xudmFyIE1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDNlNDtcbnZhciBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gNWUzO1xudmFyIFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgPSA1MDtcbnZhciBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgPSA1MDtcbmZ1bmN0aW9uIGdldEJhc2VVcmwoYmFzZVVybCkge1xuICBpZiAodHlwZW9mIGJhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgYmFzZVVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBiYXNlVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERUZBVUxUX0JBU0VfVVJMO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnQob3B0aW9ucykge1xuICBjb25zdCBjbGllbnRPcHRpb25zID0gb3B0aW9ucztcbiAgY29uc3QgdGhyb3R0bGVEZWxheSA9IGdldFRocm90dGxlKGNsaWVudE9wdGlvbnMudGhyb3R0bGUgPz8gREVGQVVMVF9USFJPVFRMRSk7XG4gIGNvbnN0IGxvc3RDb25uZWN0aW9uVGltZW91dCA9IGdldExvc3RDb25uZWN0aW9uVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmxvc3RDb25uZWN0aW9uVGltZW91dCA/PyBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG4gIGNvbnN0IGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ID0gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFxuICApO1xuICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybChjbGllbnRPcHRpb25zLmJhc2VVcmwpO1xuICBjb25zdCBhdXRoTWFuYWdlciA9IGNyZWF0ZUF1dGhNYW5hZ2VyKG9wdGlvbnMpO1xuICBjb25zdCByb29tc0J5SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiB0ZWFyZG93blJvb20ocm9vbSkge1xuICAgIHVubGlua0RldlRvb2xzKHJvb20uaWQpO1xuICAgIHJvb21zQnlJZC5kZWxldGUocm9vbS5pZCk7XG4gICAgcm9vbS5kZXN0cm95KCk7XG4gIH1cbiAgZnVuY3Rpb24gbGVhc2VSb29tKGRldGFpbHMpIHtcbiAgICBjb25zdCBsZWF2ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGYgPSBsZWF2ZTtcbiAgICAgIGlmICghZGV0YWlscy51bnN1YnMuZGVsZXRlKHNlbGYpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGlzIGxlYXZlIGZ1bmN0aW9uIHdhcyBhbHJlYWR5IGNhbGxlZC4gQ2FsbGluZyBpdCBtb3JlIHRoYW4gb25jZSBoYXMgbm8gZWZmZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGV0YWlscy51bnN1YnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRlYXJkb3duUm9vbShkZXRhaWxzLnJvb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBkZXRhaWxzLnVuc3Vicy5hZGQobGVhdmUpO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiBkZXRhaWxzLnJvb20sXG4gICAgICBsZWF2ZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXJSb29tKHJvb21JZCwgLi4uYXJncykge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcm9vbXNCeUlkLmdldChyb29tSWQpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVhc2VSb29tKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uczIgPSBhcmdzWzBdID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9ICh0eXBlb2Ygb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSkgPz8ge307XG4gICAgY29uc3QgaW5pdGlhbFN0b3JhZ2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsU3RvcmFnZShyb29tSWQpIDogb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2UpID8/IHt9O1xuICAgIGNvbnN0IG5ld1Jvb20gPSBjcmVhdGVSb29tKFxuICAgICAgeyBpbml0aWFsUHJlc2VuY2UsIGluaXRpYWxTdG9yYWdlIH0sXG4gICAgICB7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgdGhyb3R0bGVEZWxheSxcbiAgICAgICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgcG9seWZpbGxzOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscyxcbiAgICAgICAgZGVsZWdhdGVzOiBjbGllbnRPcHRpb25zLm1vY2tlZERlbGVnYXRlcyA/PyB7XG4gICAgICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5XZWJTb2NrZXRcbiAgICAgICAgICApLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcilcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2dnaW5nOiBjbGllbnRPcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IG9wdGlvbnMyPy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgdW5zdGFibGVfZmFsbGJhY2tUb0hUVFA6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCxcbiAgICAgICAgdW5zdGFibGVfc3RyZWFtRGF0YTogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX3N0cmVhbURhdGFcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IG5ld1Jvb21EZXRhaWxzID0ge1xuICAgICAgcm9vbTogbmV3Um9vbSxcbiAgICAgIHVuc3ViczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgcm9vbXNCeUlkLnNldChyb29tSWQsIG5ld1Jvb21EZXRhaWxzKTtcbiAgICBzZXR1cERldlRvb2xzKCgpID0+IEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSkpO1xuICAgIGxpbmtEZXZUb29scyhyb29tSWQsIG5ld1Jvb20pO1xuICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSBvcHRpb25zMi5hdXRvQ29ubmVjdCA/PyB0cnVlO1xuICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGF0b2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5hdG9iID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIllvdSBuZWVkIHRvIHBvbHlmaWxsIGF0b2IgdG8gdXNlIHRoZSBjbGllbnQgaW4geW91ciBlbnZpcm9ubWVudC4gUGxlYXNlIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGF0IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLWNsaWVudC9hdG9iLXBvbHlmaWxsXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbC5hdG9iID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMuYXRvYjtcbiAgICAgIH1cbiAgICAgIG5ld1Jvb20uY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhc2VSb29tKG5ld1Jvb21EZXRhaWxzKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJvb20gPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnJvb207XG4gICAgcmV0dXJuIHJvb20gPyByb29tIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgYXV0aE1hbmFnZXIucmVzZXQoKTtcbiAgICBmb3IgKGNvbnN0IHsgcm9vbSB9IG9mIHJvb21zQnlJZC52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFpc0lkbGUocm9vbS5nZXRTdGF0dXMoKSkpIHtcbiAgICAgICAgcm9vbS5yZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY3VycmVudFVzZXJJZFN0b3JlID0gY3JlYXRlU3RvcmUobnVsbCk7XG4gIGNvbnN0IGZldGNoUG9seWZpbGwgPSBjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2xvYmFsVGhpcy5mZXRjaD8uYmluZChnbG9iYWxUaGlzKTtcbiAgY29uc3Qgbm90aWZpY2F0aW9uc0FQSSA9IGNyZWF0ZU5vdGlmaWNhdGlvbnNBcGkoe1xuICAgIGJhc2VVcmwsXG4gICAgZmV0Y2hQb2x5ZmlsbCxcbiAgICBhdXRoTWFuYWdlcixcbiAgICBjdXJyZW50VXNlcklkU3RvcmVcbiAgfSk7XG4gIGNvbnN0IHJlc29sdmVVc2VycyA9IGNsaWVudE9wdGlvbnMucmVzb2x2ZVVzZXJzO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVVc2VycyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVVzZXJzLFxuICAgIFwiU2V0IHRoZSByZXNvbHZlVXNlcnMgb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHVzZXIgaW5mby5cIlxuICApO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVVzZXJzID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkVXNlcklkcykgPT4ge1xuICAgICAgY29uc3QgdXNlcklkcyA9IGJhdGNoZWRVc2VySWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzPy4oeyB1c2VySWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlVXNlcnMoKTtcbiAgICAgIHJldHVybiB1c2VycyA/PyB1c2VySWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoZWRSZXNvbHZlVXNlcnMpO1xuICBmdW5jdGlvbiBpbnZhbGlkYXRlUmVzb2x2ZWRVc2Vycyh1c2VySWRzKSB7XG4gICAgdXNlcnNTdG9yZS5pbnZhbGlkYXRlKHVzZXJJZHMpO1xuICB9XG4gIGNvbnN0IHJlc29sdmVSb29tc0luZm8gPSBjbGllbnRPcHRpb25zLnJlc29sdmVSb29tc0luZm87XG4gIGNvbnN0IHdhcm5JZk5vUmVzb2x2ZVJvb21zSW5mbyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVJvb21zSW5mbyxcbiAgICBcIlNldCB0aGUgcmVzb2x2ZVJvb21zSW5mbyBvcHRpb24gaW4gY3JlYXRlQ2xpZW50IHRvIHNwZWNpZnkgcm9vbSBpbmZvLlwiXG4gICk7XG4gIGNvbnN0IGJhdGNoZWRSZXNvbHZlUm9vbXNJbmZvID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkUm9vbUlkcykgPT4ge1xuICAgICAgY29uc3Qgcm9vbUlkcyA9IGJhdGNoZWRSb29tSWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHJvb21zSW5mbyA9IGF3YWl0IHJlc29sdmVSb29tc0luZm8/Lih7IHJvb21JZHMgfSk7XG4gICAgICB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8oKTtcbiAgICAgIHJldHVybiByb29tc0luZm8gPz8gcm9vbUlkcy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICB9LFxuICAgIHsgZGVsYXk6IFJFU09MVkVfUk9PTVNfSU5GT19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaGVkUmVzb2x2ZVJvb21zSW5mbyk7XG4gIGZ1bmN0aW9uIGludmFsaWRhdGVSZXNvbHZlZFJvb21zSW5mbyhyb29tSWRzKSB7XG4gICAgcm9vbXNJbmZvU3RvcmUuaW52YWxpZGF0ZShyb29tSWRzKTtcbiAgfVxuICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGludmFsaWRhdGVSZXNvbHZlZE1lbnRpb25TdWdnZXN0aW9ucygpIHtcbiAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZS5jbGVhcigpO1xuICB9XG4gIGNvbnN0IGNsaWVudCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBlbnRlclJvb20sXG4gICAgICBnZXRSb29tLFxuICAgICAgbG9nb3V0LFxuICAgICAgLi4ubm90aWZpY2F0aW9uc0FQSSxcbiAgICAgIC8vIEFkdmFuY2VkIHJlc29sdmVycyBBUElzXG4gICAgICByZXNvbHZlcnM6IHtcbiAgICAgICAgaW52YWxpZGF0ZVVzZXJzOiBpbnZhbGlkYXRlUmVzb2x2ZWRVc2VycyxcbiAgICAgICAgaW52YWxpZGF0ZVJvb21zSW5mbzogaW52YWxpZGF0ZVJlc29sdmVkUm9vbXNJbmZvLFxuICAgICAgICBpbnZhbGlkYXRlTWVudGlvblN1Z2dlc3Rpb25zOiBpbnZhbGlkYXRlUmVzb2x2ZWRNZW50aW9uU3VnZ2VzdGlvbnNcbiAgICAgIH0sXG4gICAgICAvLyBJbnRlcm5hbFxuICAgICAgW2tJbnRlcm5hbF06IHtcbiAgICAgICAgY3VycmVudFVzZXJJZFN0b3JlLFxuICAgICAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSxcbiAgICAgICAgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uczogY2xpZW50T3B0aW9ucy5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zLFxuICAgICAgICB1c2Vyc1N0b3JlLFxuICAgICAgICByb29tc0luZm9TdG9yZSxcbiAgICAgICAgZ2V0Um9vbUlkcygpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyb29tc0J5SWQua2V5cygpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gXCJBbGxcIiB0aHJlYWRzICg9IFwidXNlclwiIHRocmVhZHMpXG4gICAgICAgIGdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbDogbm90aWZpY2F0aW9uc0FQSS5nZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwsXG4gICAgICAgIGdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsOiBub3RpZmljYXRpb25zQVBJLmdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsLFxuICAgICAgICAvLyBUeXBlLWxldmVsIGhlbHBlciBvbmx5LCBpdCdzIGVmZmVjdGl2ZWx5IG9ubHkgYW4gaWRlbnRpdHktZnVuY3Rpb24gYXQgcnVudGltZVxuICAgICAgICBhczogKCkgPT4gY2xpZW50XG4gICAgICB9XG4gICAgfSxcbiAgICBrSW50ZXJuYWwsXG4gICAge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG4gIHJldHVybiBjbGllbnQ7XG59XG5mdW5jdGlvbiBjaGVja0JvdW5kcyhvcHRpb24sIHZhbHVlLCBtaW4sIG1heCwgcmVjb21tZW5kZWRNaW4pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIG1heCAhPT0gdm9pZCAwID8gYCR7b3B0aW9ufSBzaG91bGQgYmUgYmV0d2VlbiAke3JlY29tbWVuZGVkTWluID8/IG1pbn0gYW5kICR7bWF4fS5gIDogYCR7b3B0aW9ufSBzaG91bGQgYmUgYXQgbGVhc3QgJHtyZWNvbW1lbmRlZE1pbiA/PyBtaW59LmBcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gZ2V0VGhyb3R0bGUodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFwidGhyb3R0bGVcIiwgdmFsdWUsIE1JTl9USFJPVFRMRSwgTUFYX1RIUk9UVExFKTtcbn1cbmZ1bmN0aW9uIGdldExvc3RDb25uZWN0aW9uVGltZW91dCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJsb3N0Q29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKGNvbmRpdGlvbiwgLi4uYXJncykge1xuICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFoYXNXYXJuZWQgJiYgKHR5cGVvZiBjb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGNvbmRpdGlvbigpIDogY29uZGl0aW9uKSkge1xuICAgICAgICB3YXJuKC4uLmFyZ3MpO1xuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9jb21tZW50cy9jb21tZW50LWJvZHkudHNcbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwicGFyYWdyYXBoXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5VGV4dChlbGVtZW50KSB7XG4gIHJldHVybiAhKFwidHlwZVwiIGluIGVsZW1lbnQpICYmIFwidGV4dFwiIGluIGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQudGV4dCA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlNZW50aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlMaW5rKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcImxpbmtcIjtcbn1cbnZhciBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzID0ge1xuICBwYXJhZ3JhcGg6IGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgsXG4gIHRleHQ6IGlzQ29tbWVudEJvZHlUZXh0LFxuICBsaW5rOiBpc0NvbW1lbnRCb2R5TGluayxcbiAgbWVudGlvbjogaXNDb21tZW50Qm9keU1lbnRpb25cbn07XG52YXIgY29tbWVudEJvZHlFbGVtZW50c1R5cGVzID0ge1xuICBwYXJhZ3JhcGg6IFwiYmxvY2tcIixcbiAgdGV4dDogXCJpbmxpbmVcIixcbiAgbGluazogXCJpbmxpbmVcIixcbiAgbWVudGlvbjogXCJpbmxpbmVcIlxufTtcbmZ1bmN0aW9uIHRyYXZlcnNlQ29tbWVudEJvZHkoYm9keSwgZWxlbWVudE9yVmlzaXRvciwgcG9zc2libHlWaXNpdG9yKSB7XG4gIGlmICghYm9keSB8fCAhYm9keT8uY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogdm9pZCAwO1xuICBjb25zdCB0eXBlID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlc1tlbGVtZW50XSA6IFwiYWxsXCI7XG4gIGNvbnN0IGd1YXJkID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHNbZWxlbWVudF0gOiAoKSA9PiB0cnVlO1xuICBjb25zdCB2aXNpdG9yID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnRPclZpc2l0b3IgOiBwb3NzaWJseVZpc2l0b3I7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgYm9keS5jb250ZW50KSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICBpZiAoZ3VhcmQoYmxvY2spKSB7XG4gICAgICAgIHZpc2l0b3I/LihibG9jayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgIGZvciAoY29uc3QgaW5saW5lIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChndWFyZChpbmxpbmUpKSB7XG4gICAgICAgICAgdmlzaXRvcj8uKGlubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KSB7XG4gIGNvbnN0IG1lbnRpb25lZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHRyYXZlcnNlQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBcIm1lbnRpb25cIixcbiAgICAobWVudGlvbikgPT4gbWVudGlvbmVkSWRzLmFkZChtZW50aW9uLmlkKVxuICApO1xuICByZXR1cm4gQXJyYXkuZnJvbShtZW50aW9uZWRJZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShib2R5LCByZXNvbHZlVXNlcnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICghcmVzb2x2ZVVzZXJzKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG4gIH1cbiAgY29uc3QgdXNlcklkcyA9IGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KTtcbiAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnMoe1xuICAgIHVzZXJJZHNcbiAgfSk7XG4gIGZvciAoY29uc3QgW2luZGV4LCB1c2VySWRdIG9mIHVzZXJJZHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgdXNlciA9IHVzZXJzPy5baW5kZXhdO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXNvbHZlZFVzZXJzLnNldCh1c2VySWQsIHVzZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRVc2Vycztcbn1cbnZhciBodG1sRXNjYXBhYmxlcyA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjMzk7XCJcbn07XG52YXIgaHRtbEVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKGh0bWxFc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBodG1sU2FmZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtTdHJpbmcodmFsdWUpXSwgW10pO1xufVxuZnVuY3Rpb24gam9pbkh0bWwoc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEh0bWxTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5IdG1sKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgaHRtbEVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBodG1sRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgSHRtbFNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlSHRtbChubih0aGlzLl92YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBodG1sKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzID0ge1xuICBfOiBcIlxcXFxfXCIsXG4gIFwiKlwiOiBcIlxcXFwqXCIsXG4gIFwiI1wiOiBcIlxcXFwjXCIsXG4gIFwiYFwiOiBcIlxcXFxgXCIsXG4gIFwiflwiOiBcIlxcXFx+XCIsXG4gIFwiIVwiOiBcIlxcXFwhXCIsXG4gIFwifFwiOiBcIlxcXFx8XCIsXG4gIFwiKFwiOiBcIlxcXFwoXCIsXG4gIFwiKVwiOiBcIlxcXFwpXCIsXG4gIFwie1wiOiBcIlxcXFx7XCIsXG4gIFwifVwiOiBcIlxcXFx9XCIsXG4gIFwiW1wiOiBcIlxcXFxbXCIsXG4gIFwiXVwiOiBcIlxcXFxdXCJcbn07XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhtYXJrZG93bkVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGpvaW5NYXJrZG93bihzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlTWFya2Rvd24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFya2Rvd25TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5NYXJrZG93bih2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IG1hcmtkb3duRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgTWFya2Rvd25TYWZlU3RyaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICB0aGlzLl9zdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZU1hcmtkb3duKG5uKHRoaXMuX3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1hcmtkb3duKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmwyKSB7XG4gIGlmICh1cmwyLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHVybDIuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHVybDI7XG4gIH0gZWxzZSBpZiAodXJsMi5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgIHJldHVybiBcImh0dHBzOi8vXCIgKyB1cmwyO1xuICB9XG4gIHJldHVybjtcbn1cbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4gY2hpbGRyZW4sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC50ZXh0LFxuICBsaW5rOiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCA/PyBlbGVtZW50LnVybCxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gaHRtbGA8cD4ke2h0bWxTYWZlKGNoaWxkcmVuKX08L3A+YCA6IGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHN0cm9uZz4ke2NoaWxkcmVufTwvc3Ryb25nPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxlbT4ke2NoaWxkcmVufTwvZW0+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzPiR7Y2hpbGRyZW59PC9zPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8Y29kZT4ke2NoaWxkcmVufTwvY29kZT5gO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxhIGhyZWY9XCIke2hyZWZ9XCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPiR7ZWxlbWVudC50ZXh0ID8/IGVsZW1lbnQudXJsfTwvYT5gO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8c3BhbiBkYXRhLW1lbnRpb24+QCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfTwvc3Bhbj5gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYCoqJHtjaGlsZHJlbn0qKmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBfJHtjaGlsZHJlbn1fYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmB+fiR7Y2hpbGRyZW59fn5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYFxcYCR7Y2hpbGRyZW59XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gWyR7ZWxlbWVudC50ZXh0ID8/IGVsZW1lbnQudXJsfV0oJHtocmVmfSlgO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzdHJpbmdpZnlDb21tZW50Qm9keShib2R5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCA/PyBcInBsYWluXCI7XG4gIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnM/LnNlcGFyYXRvciA/PyAoZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBcIlxcblxcblwiIDogXCJcXG5cIik7XG4gIGNvbnN0IGVsZW1lbnRzID0ge1xuICAgIC4uLmZvcm1hdCA9PT0gXCJodG1sXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA6IGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzIDogc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzLFxuICAgIC4uLm9wdGlvbnM/LmVsZW1lbnRzXG4gIH07XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgb3B0aW9ucz8ucmVzb2x2ZVVzZXJzXG4gICk7XG4gIGNvbnN0IGJsb2NrcyA9IGJvZHkuY29udGVudC5mbGF0TWFwKChibG9jaywgYmxvY2tJbmRleCkgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2sudHlwZSkge1xuICAgICAgY2FzZSBcInBhcmFncmFwaFwiOiB7XG4gICAgICAgIGNvbnN0IGlubGluZXMgPSBibG9jay5jaGlsZHJlbi5mbGF0TWFwKChpbmxpbmUsIGlubGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlNZW50aW9uKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmxpbmUuaWQgPyBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLm1lbnRpb24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgdXNlcjogcmVzb2x2ZWRVc2Vycy5nZXQoaW5saW5lLmlkKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubGluayhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICBocmVmOiB0b0Fic29sdXRlVXJsKGlubGluZS51cmwpID8/IGlubGluZS51cmxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5VGV4dChpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzLnRleHQoeyBlbGVtZW50OiBpbmxpbmUgfSwgaW5saW5lSW5kZXgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBlbGVtZW50cy5wYXJhZ3JhcGgoXG4gICAgICAgICAgICB7IGVsZW1lbnQ6IGJsb2NrLCBjaGlsZHJlbjogaW5saW5lcy5qb2luKFwiXCIpIH0sXG4gICAgICAgICAgICBibG9ja0luZGV4XG4gICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBibG9ja3Muam9pbihzZXBhcmF0b3IpO1xufVxuXG4vLyBzcmMvY29tbWVudHMvY29tbWVudC11cmwudHNcbnZhciBQTEFDRUhPTERFUl9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9sb2NhbGhvc3Q6OTk5OVwiO1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKj86LztcbmZ1bmN0aW9uIGdlbmVyYXRlQ29tbWVudFVybCh7XG4gIHJvb21VcmwsXG4gIGNvbW1lbnRJZFxufSkge1xuICBjb25zdCBpc0Fic29sdXRlID0gQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3Qocm9vbVVybCk7XG4gIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwoXG4gICAgcm9vbVVybCxcbiAgICBpc0Fic29sdXRlID8gdm9pZCAwIDogUExBQ0VIT0xERVJfQkFTRV9VUkxcbiAgKTtcbiAgdXJsT2JqZWN0Lmhhc2ggPSBgIyR7Y29tbWVudElkfWA7XG4gIHJldHVybiBpc0Fic29sdXRlID8gdXJsT2JqZWN0LmhyZWYgOiB1cmxPYmplY3QuaHJlZi5yZXBsYWNlKFBMQUNFSE9MREVSX0JBU0VfVVJMLCBcIlwiKTtcbn1cblxuLy8gc3JjL2NyZHRzL3V0aWxzLnRzXG5mdW5jdGlvbiB0b1BsYWluTHNvbihsc29uKSB7XG4gIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGxzb24udG9PYmplY3QoKSkuZmxhdE1hcChcbiAgICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gW1trZXksIHRvUGxhaW5Mc29uKHZhbHVlKV1dIDogW11cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBbLi4ubHNvbl0ubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHRvUGxhaW5Mc29uKHZhbHVlKV0pXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGRhdGE6IFsuLi5sc29uXS5tYXAoKGl0ZW0pID0+IHRvUGxhaW5Mc29uKGl0ZW0pKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxzb247XG4gIH1cbn1cblxuLy8gc3JjL2ltbXV0YWJsZS50c1xuZnVuY3Rpb24gbHNvbk9iamVjdFRvSnNvbihvYmopIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHZhbCA9IG9ialtrZXldO1xuICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsaXZlT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QpIHtcbiAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24obGl2ZU9iamVjdC50b09iamVjdCgpKTtcbn1cbmZ1bmN0aW9uIGxpdmVNYXBUb0pzb24obWFwKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbHNvbkxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChsc29uVG9Kc29uKTtcbn1cbmZ1bmN0aW9uIGxpdmVMaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZS50b0FycmF5KCkpO1xufVxuZnVuY3Rpb24gbHNvblRvSnNvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIGxpdmVPYmplY3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gbGl2ZUxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiBsaXZlTWFwVG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiB2YWx1ZS5kYXRhO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZGVlcExpdmVpZnkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdCh2YWx1ZS5tYXAoZGVlcExpdmVpZnkpKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IGluaXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgdmFsID0gdmFsdWVba2V5XTtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGluaXRba2V5XSA9IGRlZXBMaXZlaWZ5KHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChpbml0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZUxpc3QobGl2ZUxpc3QsIHByZXYsIG5leHQpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgcHJldkVuZCA9IHByZXYubGVuZ3RoIC0gMTtcbiAgbGV0IG5leHRFbmQgPSBuZXh0Lmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2Tm9kZSA9IHByZXZbMF07XG4gIGxldCBuZXh0Tm9kZSA9IG5leHRbMF07XG4gIG91dGVyOiB7XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgKytpO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgIH1cbiAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgIHByZXZFbmQtLTtcbiAgICAgIG5leHRFbmQtLTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB9XG4gIH1cbiAgaWYgKGkgPiBwcmV2RW5kKSB7XG4gICAgaWYgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGkgPiBuZXh0RW5kKSB7XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGkgPD0gcHJldkVuZCAmJiBpIDw9IG5leHRFbmQpIHtcbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICAgIGNvbnN0IGxpdmVMaXN0Tm9kZSA9IGxpdmVMaXN0LmdldChpKTtcbiAgICAgIGlmIChpc0xpdmVPYmplY3QobGl2ZUxpc3ROb2RlKSAmJiBpc1BsYWluT2JqZWN0KHByZXZOb2RlKSAmJiBpc1BsYWluT2JqZWN0KG5leHROb2RlKSkge1xuICAgICAgICBwYXRjaExpdmVPYmplY3QobGl2ZUxpc3ROb2RlLCBwcmV2Tm9kZSwgbmV4dE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZUxpc3Quc2V0KGksIGRlZXBMaXZlaWZ5KG5leHROb2RlKSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3RLZXkobGl2ZU9iamVjdCwga2V5LCBwcmV2LCBuZXh0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBub25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXh0KTtcbiAgICBpZiAobm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgIGVycm9yMihcbiAgICAgICAgYE5ldyBzdGF0ZSBwYXRoOiAnJHtub25TZXJpYWxpemFibGVWYWx1ZS5wYXRofScgdmFsdWU6ICcke1N0cmluZyhcbiAgICAgICAgICBub25TZXJpYWxpemFibGVWYWx1ZS52YWx1ZVxuICAgICAgICApfScgaXMgbm90IHNlcmlhbGl6YWJsZS5cbk9ubHkgc2VyaWFsaXphYmxlIHZhbHVlIGNhbiBiZSBzeW5jZWQgd2l0aCBMaXZlYmxvY2tzLmBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHZhbHVlID0gbGl2ZU9iamVjdC5nZXQoa2V5KTtcbiAgaWYgKG5leHQgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3QuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9IGVsc2UgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaXNMaXZlTGlzdCh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShwcmV2KSAmJiBBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlTGlzdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSBpZiAoaXNMaXZlT2JqZWN0KHZhbHVlKSAmJiBpc1BsYWluT2JqZWN0KHByZXYpICYmIGlzUGxhaW5PYmplY3QobmV4dCkpIHtcbiAgICBwYXRjaExpdmVPYmplY3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2Uge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3Qocm9vdCwgcHJldiwgbmV4dCkge1xuICBjb25zdCB1cGRhdGVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICBwYXRjaExpdmVPYmplY3RLZXkocm9vdCwga2V5LCBwcmV2W2tleV0sIG5leHRba2V5XSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgIGlmIChuZXh0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgcm9vdC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICByb290LnVwZGF0ZSh1cGRhdGVzKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyZW50c1BhdGgobm9kZSkge1xuICBjb25zdCBwYXRoID0gW107XG4gIHdoaWxlIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgaWYgKGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5ub2RlLl9pbmRleE9mUG9zaXRpb24obm9kZS5wYXJlbnQua2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5rZXkpO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnQubm9kZTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdChzdGF0ZSwgdXBkYXRlcykge1xuICByZXR1cm4gdXBkYXRlcy5yZWR1Y2UoXG4gICAgKHN0YXRlMiwgdXBkYXRlKSA9PiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlMiwgdXBkYXRlKSxcbiAgICBzdGF0ZVxuICApO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZSwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGggPSBnZXRQYXJlbnRzUGF0aCh1cGRhdGUubm9kZSk7XG4gIHJldHVybiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGhJdGVtID0gcGF0aC5wb3AoKTtcbiAgaWYgKHBhdGhJdGVtID09PSB2b2lkIDApIHtcbiAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiTGl2ZU9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlT2JqZWN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZUxpc3RcIjoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVMaXN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIGFycmF5XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLm1hcCgoeCkgPT4geCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdFVwZGF0ZSBvZiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUubWFwKFxuICAgICAgICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGluZGV4ID09PSBsaXN0VXBkYXRlLmluZGV4ID8gbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pIDogaXRlbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUuaW5kZXggPT09IG5ld1N0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZS5wdXNoKGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleClcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUuc3BsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCA+IGxpc3RVcGRhdGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5pbmRleCArIDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVNYXBcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU1hcCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICBjb25zdCBuZXdBcnJheSA9IFsuLi5zdGF0ZV07XG4gICAgbmV3QXJyYXlbcGF0aEl0ZW1dID0gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShcbiAgICAgIHN0YXRlW3BhdGhJdGVtXSxcbiAgICAgIHBhdGgsXG4gICAgICB1cGRhdGVcbiAgICApO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSBlbHNlIGlmIChpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN0YXRlW3BhdGhJdGVtXTtcbiAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXRlQXNPYmogPSBzdGF0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlQXNPYmosXG4gICAgICAgIFtwYXRoSXRlbV06IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUobm9kZSwgcGF0aCwgdXBkYXRlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vIHNyYy9saWIvZGVwcmVjYXRpb24udHNcbnZhciBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmhhcyhrZXkpKSB7XG4gICAgICBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuYWRkKGtleSk7XG4gICAgICBlcnJvcldpdGhUaXRsZShcIkRlcHJlY2F0aW9uIHdhcm5pbmdcIiwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXByZWNhdGVJZihjb25kaXRpb24sIG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IHVzYWdlRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgdXNhZ2VFcnJvci5uYW1lID0gXCJVc2FnZSBlcnJvclwiO1xuICAgIGVycm9yV2l0aFRpdGxlKFwiVXNhZ2UgZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgdGhyb3cgdXNhZ2VFcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JJZihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9Qb2xsZXIudHNcbnZhciBCQUNLT0ZGX0RFTEFZUzIgPSBbMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xuZnVuY3Rpb24gbWFrZVBvbGxlcihjYWxsYmFjaywgaW50ZXJ2YWxNcywgb3B0aW9ucykge1xuICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gIGNvbnN0IG1heFN0YWxlVGltZU1zID0gb3B0aW9ucz8ubWF4U3RhbGVUaW1lTXMgPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGluRm9yZWdyb3VuZDogZG9jPy52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCIsXG4gICAgbGFzdFN1Y2Nlc3NmdWxQb2xsQXQ6IHN0YXJ0VGltZSxcbiAgICBjb3VudDogMCxcbiAgICBiYWNrb2ZmOiAwXG4gIH07XG4gIGZ1bmN0aW9uIG1heVBvbGwoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY291bnQgPiAwICYmIGNvbnRleHQuaW5Gb3JlZ3JvdW5kO1xuICB9XG4gIGNvbnN0IGZzbSA9IG5ldyBGU00oe30pLmFkZFN0YXRlKFwiQGlkbGVcIikuYWRkU3RhdGUoXCJAZW5hYmxlZFwiKS5hZGRTdGF0ZShcIkBwb2xsaW5nXCIpO1xuICBmc20uYWRkVHJhbnNpdGlvbnMoXCJAaWRsZVwiLCB7IFNUQVJUOiBcIkBlbmFibGVkXCIgfSk7XG4gIGZzbS5hZGRUcmFuc2l0aW9ucyhcIkBlbmFibGVkXCIsIHsgU1RPUDogXCJAaWRsZVwiLCBQT0xMOiBcIkBwb2xsaW5nXCIgfSk7XG4gIGZzbS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAZW5hYmxlZFwiLFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IGxhc3RQb2xsID0gY29udGV4dC5sYXN0U3VjY2Vzc2Z1bFBvbGxBdDtcbiAgICAgIGNvbnN0IG5leHRQb2xsID0gbGFzdFBvbGwgKyBpbnRlcnZhbE1zO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIG5leHRQb2xsIC0gcGVyZm9ybWFuY2Uubm93KCkpICsgY29udGV4dC5iYWNrb2ZmO1xuICAgIH0sXG4gICAgXCJAcG9sbGluZ1wiXG4gICk7XG4gIGZzbS5vbkVudGVyQXN5bmMoXG4gICAgXCJAcG9sbGluZ1wiLFxuICAgIGFzeW5jIChfY3R4LCBzaWduYWwpID0+IHtcbiAgICAgIGF3YWl0IGNhbGxiYWNrKHNpZ25hbCk7XG4gICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGNvbnRleHQubGFzdFN1Y2Nlc3NmdWxQb2xsQXQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFdoZW4gT0tcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IG1heVBvbGwoKSA/IFwiQGVuYWJsZWRcIiA6IFwiQGlkbGVcIixcbiAgICAgICAgZWZmZWN0OiAoKSA9PiB7XG4gICAgICAgICAgY29udGV4dC5iYWNrb2ZmID0gMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIFdoZW4gZXJyb3JcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IG1heVBvbGwoKSA/IFwiQGVuYWJsZWRcIiA6IFwiQGlkbGVcIixcbiAgICAgICAgZWZmZWN0OiAoKSA9PiB7XG4gICAgICAgICAgY29udGV4dC5iYWNrb2ZmID0gQkFDS09GRl9ERUxBWVMyLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGNvbnRleHQuYmFja29mZikgPz8gQkFDS09GRl9ERUxBWVMyW0JBQ0tPRkZfREVMQVlTMi5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIDNlNFxuICAgIC8vIEFib3J0IHRoZSBwb2xsIGlmIHRoZSBjYWxsYmFjayB0YWtlcyBtb3JlIHRoYW4gMzAgc2Vjb25kcyB0byBjb21wbGV0ZVxuICApO1xuICBmdW5jdGlvbiBzdGFydE9yU3RvcCgpIHtcbiAgICBpZiAobWF5UG9sbCgpKSB7XG4gICAgICBmc20uc2VuZCh7IHR5cGU6IFwiU1RBUlRcIiB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnNtLnNlbmQoeyB0eXBlOiBcIlNUT1BcIiB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5jKCkge1xuICAgIGNvbnRleHQuY291bnQrKztcbiAgICBzdGFydE9yU3RvcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGRlYygpIHtcbiAgICBjb250ZXh0LmNvdW50LS07XG4gICAgaWYgKGNvbnRleHQuY291bnQgPCAwKSB7XG4gICAgICBjb250ZXh0LmNvdW50ID0gMDtcbiAgICB9XG4gICAgc3RhcnRPclN0b3AoKTtcbiAgfVxuICBmdW5jdGlvbiBwb2xsTm93SWZTdGFsZSgpIHtcbiAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBjb250ZXh0Lmxhc3RTdWNjZXNzZnVsUG9sbEF0ID4gbWF4U3RhbGVUaW1lTXMpIHtcbiAgICAgIGZzbS5zZW5kKHsgdHlwZTogXCJQT0xMXCIgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEluRm9yZWdyb3VuZChpbkZvcmVncm91bmQpIHtcbiAgICBjb250ZXh0LmluRm9yZWdyb3VuZCA9IGluRm9yZWdyb3VuZDtcbiAgICBzdGFydE9yU3RvcCgpO1xuICAgIHBvbGxOb3dJZlN0YWxlKCk7XG4gIH1cbiAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgIHNldEluRm9yZWdyb3VuZChkb2M/LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIik7XG4gIH1cbiAgZG9jPy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgZnNtLnN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgaW5jLFxuICAgIGRlYyxcbiAgICBwb2xsTm93SWZTdGFsZSxcbiAgICAvLyBJbnRlcm5hbCBBUEksIHVzZWQgYnkgdW5pdCB0ZXN0cyBvbmx5IHRvIHNpbXVsYXRlIHZpc2liaWxpdHkgZXZlbnRzXG4gICAgc2V0SW5Gb3JlZ3JvdW5kXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iakEpIHx8ICFpc1BsYWluT2JqZWN0KG9iakIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2xpYi9Tb3J0ZWRMaXN0LnRzXG5mdW5jdGlvbiBiaXNlY3RSaWdodChhcnIsIHgsIGx0KSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgY29uc3QgbWlkID0gbG8gKyAoaGkgLSBsbyA+PiAxKTtcbiAgICBpZiAobHQoeCwgYXJyW21pZF0pKSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG8gPSBtaWQgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG87XG59XG52YXIgU29ydGVkTGlzdCA9IGNsYXNzIF9Tb3J0ZWRMaXN0IHtcbiAgY29uc3RydWN0b3IoYWxyZWFkeVNvcnRlZExpc3QsIGx0KSB7XG4gICAgdGhpcy5fbHQgPSBsdDtcbiAgICB0aGlzLl9kYXRhID0gYWxyZWFkeVNvcnRlZExpc3Q7XG4gIH1cbiAgc3RhdGljIGZyb20oYXJyLCBsdCkge1xuICAgIGNvbnN0IHNvcnRlZCA9IG5ldyBfU29ydGVkTGlzdChbXSwgbHQpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIHNvcnRlZC5hZGQoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBzb3J0ZWQ7XG4gIH1cbiAgc3RhdGljIGZyb21BbHJlYWR5U29ydGVkKGFscmVhZHlTb3J0ZWQsIGx0KSB7XG4gICAgcmV0dXJuIG5ldyBfU29ydGVkTGlzdChhbHJlYWR5U29ydGVkLCBsdCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc29ydGVkIGxpc3QgdG8gYSBuZXcgaW5zdGFuY2UuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9Tb3J0ZWRMaXN0KHRoaXMuX2RhdGEuc2xpY2UoKSwgdGhpcy5fbHQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gdG8gdGhlIHNvcnRlZCBsaXN0LCBzdWNoIHRoYXQgaXQgcmVtYWlucyBzb3J0ZWQuXG4gICAqL1xuICBhZGQodmFsdWUpIHtcbiAgICBjb25zdCBpZHggPSBiaXNlY3RSaWdodCh0aGlzLl9kYXRhLCB2YWx1ZSwgdGhpcy5fbHQpO1xuICAgIHRoaXMuX2RhdGEuc3BsaWNlKGlkeCwgMCwgdmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiB2YWx1ZSBmcm9tIHRoZSBzb3J0ZWQgbGlzdCwgaWYgaXQgZXhpc3RzLiBUaGUgZ2l2ZW5cbiAgICogdmFsdWUgbXVzdCBiZSBgPT09YCB0byBvbmUgb2YgdGhlIGxpc3QgaXRlbXMuIE9ubHkgdGhlIGZpcnN0IGVudHJ5IHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpZiB0aGUgZWxlbWVudCBleGlzdHMgaW4gdGhlIHNvcnRlZCBsaXN0IG11bHRpcGxlIHRpbWVzLlxuICAgKi9cbiAgcmVtb3ZlKHZhbHVlKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5fZGF0YS5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuX2RhdGEuc3BsaWNlKGlkeCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubGVuZ3RoO1xuICB9XG4gICpmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2RhdGEpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG59O1xuXG4vLyBzcmMvdHlwZXMvT3RoZXJzLnRzXG52YXIgVGV4dEVkaXRvclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChUZXh0RWRpdG9yVHlwZTIpID0+IHtcbiAgVGV4dEVkaXRvclR5cGUyW1wiTGV4aWNhbFwiXSA9IFwibGV4aWNhbFwiO1xuICBUZXh0RWRpdG9yVHlwZTJbXCJUaXBUYXBcIl0gPSBcInRpcHRhcFwiO1xuICByZXR1cm4gVGV4dEVkaXRvclR5cGUyO1xufSkoVGV4dEVkaXRvclR5cGUgfHwge30pO1xuXG4vLyBzcmMvaW5kZXgudHNcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG52YXIgQ29tbWVudHNBcGlFcnJvciA9IEh0dHBFcnJvcjtcbnZhciBOb3RpZmljYXRpb25zQXBpRXJyb3IgPSBIdHRwRXJyb3I7XG5leHBvcnQge1xuICBDbGllbnRNc2dDb2RlLFxuICBDb21tZW50c0FwaUVycm9yLFxuICBDcmR0VHlwZSxcbiAgSHR0cEVycm9yLFxuICBMaXZlTGlzdCxcbiAgTGl2ZU1hcCxcbiAgTGl2ZU9iamVjdCxcbiAgTm90aWZpY2F0aW9uc0FwaUVycm9yLFxuICBPcENvZGUsXG4gIFByb21pc2Vfd2l0aFJlc29sdmVycyxcbiAgU2VydmVyTXNnQ29kZSxcbiAgU29ydGVkTGlzdCxcbiAgVGV4dEVkaXRvclR5cGUsXG4gIFdlYnNvY2tldENsb3NlQ29kZXMsXG4gIGFja09wLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYXV0b1JldHJ5LFxuICBiNjRkZWNvZGUsXG4gIGNodW5rLFxuICBjbG9uZUxzb24sXG4gIGNvbXBhY3RPYmplY3QsXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBjcmVhdGVDbGllbnQsXG4gIGNyZWF0ZUNvbW1lbnRJZCxcbiAgY3JlYXRlSW5ib3hOb3RpZmljYXRpb25JZCxcbiAgY3JlYXRlU3RvcmUsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBkZXByZWNhdGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBkZXRlY3REdXBlcyxcbiAgZXJyb3JJZixcbiAgZnJlZXplLFxuICBnZW5lcmF0ZUNvbW1lbnRVcmwsXG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgaHRtbCxcbiAgaHRtbFNhZmUsXG4gIGlzQ2hpbGRDcmR0LFxuICBpc0NvbW1lbnRCb2R5TGluayxcbiAgaXNDb21tZW50Qm9keU1lbnRpb24sXG4gIGlzQ29tbWVudEJvZHlUZXh0LFxuICBpc0pzb25BcnJheSxcbiAgaXNKc29uT2JqZWN0LFxuICBpc0pzb25TY2FsYXIsXG4gIGlzTGl2ZU5vZGUsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUm9vdENyZHQsXG4gIGtJbnRlcm5hbCxcbiAgbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0LFxuICBsc29uVG9Kc29uLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1ha2VQb2xsZXIsXG4gIG1ha2VQb3NpdGlvbixcbiAgbWFwVmFsdWVzLFxuICBtZW1vaXplT25TdWNjZXNzLFxuICBuYW5vaWQsXG4gIG5uLFxuICBvYmplY3RUb1F1ZXJ5LFxuICBwYXRjaExpdmVPYmplY3RLZXksXG4gIHJhaXNlLFxuICByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5LFxuICBzaGFsbG93LFxuICBzdHJpbmdpZnksXG4gIHN0cmluZ2lmeUNvbW1lbnRCb2R5LFxuICB0aHJvd1VzYWdlRXJyb3IsXG4gIHRvQWJzb2x1dGVVcmwsXG4gIHRvUGxhaW5Mc29uLFxuICB0cnlQYXJzZUpzb24sXG4gIHVybCxcbiAgdXJsam9pbixcbiAgd2FpdCxcbiAgd2l0aFRpbWVvdXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/chunk-A7GJNN4L.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-A7GJNN4L.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientContext: () => (/* binding */ ClientContext),\n/* harmony export */   CreateThreadError: () => (/* binding */ CreateThreadError),\n/* harmony export */   LiveblocksProvider: () => (/* binding */ LiveblocksProvider),\n/* harmony export */   RoomContext: () => (/* binding */ RoomContext),\n/* harmony export */   _RoomProvider: () => (/* binding */ _RoomProvider),\n/* harmony export */   _useAddReaction: () => (/* binding */ _useAddReaction),\n/* harmony export */   _useBroadcastEvent: () => (/* binding */ _useBroadcastEvent),\n/* harmony export */   _useCreateThread: () => (/* binding */ _useCreateThread),\n/* harmony export */   _useDeleteThread: () => (/* binding */ _useDeleteThread),\n/* harmony export */   _useEditThreadMetadata: () => (/* binding */ _useEditThreadMetadata),\n/* harmony export */   _useEventListener: () => (/* binding */ _useEventListener),\n/* harmony export */   _useHistoryVersions: () => (/* binding */ _useHistoryVersions),\n/* harmony export */   _useHistoryVersionsSuspense: () => (/* binding */ _useHistoryVersionsSuspense),\n/* harmony export */   _useInboxNotificationThread: () => (/* binding */ _useInboxNotificationThread),\n/* harmony export */   _useIsInsideRoom: () => (/* binding */ _useIsInsideRoom),\n/* harmony export */   _useMutation: () => (/* binding */ _useMutation),\n/* harmony export */   _useMyPresence: () => (/* binding */ _useMyPresence),\n/* harmony export */   _useOther: () => (/* binding */ _useOther),\n/* harmony export */   _useOtherSuspense: () => (/* binding */ _useOtherSuspense),\n/* harmony export */   _useOthers: () => (/* binding */ _useOthers),\n/* harmony export */   _useOthersListener: () => (/* binding */ _useOthersListener),\n/* harmony export */   _useOthersMapped: () => (/* binding */ _useOthersMapped),\n/* harmony export */   _useOthersMappedSuspense: () => (/* binding */ _useOthersMappedSuspense),\n/* harmony export */   _useOthersSuspense: () => (/* binding */ _useOthersSuspense),\n/* harmony export */   _useRoom: () => (/* binding */ _useRoom),\n/* harmony export */   _useRoomNotificationSettings: () => (/* binding */ _useRoomNotificationSettings),\n/* harmony export */   _useRoomNotificationSettingsSuspense: () => (/* binding */ _useRoomNotificationSettingsSuspense),\n/* harmony export */   _useSelf: () => (/* binding */ _useSelf),\n/* harmony export */   _useSelfSuspense: () => (/* binding */ _useSelfSuspense),\n/* harmony export */   _useStorage: () => (/* binding */ _useStorage),\n/* harmony export */   _useStorageRoot: () => (/* binding */ _useStorageRoot),\n/* harmony export */   _useStorageSuspense: () => (/* binding */ _useStorageSuspense),\n/* harmony export */   _useThreads: () => (/* binding */ _useThreads),\n/* harmony export */   _useThreadsSuspense: () => (/* binding */ _useThreadsSuspense),\n/* harmony export */   _useUpdateMyPresence: () => (/* binding */ _useUpdateMyPresence),\n/* harmony export */   _useUser: () => (/* binding */ _useUser),\n/* harmony export */   _useUserSuspense: () => (/* binding */ _useUserSuspense),\n/* harmony export */   _useUserThreadsSuspense_experimental: () => (/* binding */ _useUserThreadsSuspense_experimental),\n/* harmony export */   _useUserThreads_experimental: () => (/* binding */ _useUserThreads_experimental),\n/* harmony export */   createLiveblocksContext: () => (/* binding */ createLiveblocksContext),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   getUmbrellaStoreForClient: () => (/* binding */ getUmbrellaStoreForClient),\n/* harmony export */   useAttachmentUrl: () => (/* binding */ useAttachmentUrl),\n/* harmony export */   useAttachmentUrlSuspense: () => (/* binding */ useAttachmentUrlSuspense),\n/* harmony export */   useBatch: () => (/* binding */ useBatch),\n/* harmony export */   useCanRedo: () => (/* binding */ useCanRedo),\n/* harmony export */   useCanUndo: () => (/* binding */ useCanUndo),\n/* harmony export */   useClient: () => (/* binding */ useClient),\n/* harmony export */   useCommentsErrorListener: () => (/* binding */ useCommentsErrorListener),\n/* harmony export */   useCreateComment: () => (/* binding */ useCreateComment),\n/* harmony export */   useDeleteAllInboxNotifications: () => (/* binding */ useDeleteAllInboxNotifications),\n/* harmony export */   useDeleteComment: () => (/* binding */ useDeleteComment),\n/* harmony export */   useDeleteInboxNotification: () => (/* binding */ useDeleteInboxNotification),\n/* harmony export */   useEditComment: () => (/* binding */ useEditComment),\n/* harmony export */   useErrorListener: () => (/* binding */ useErrorListener),\n/* harmony export */   useHistory: () => (/* binding */ useHistory),\n/* harmony export */   useHistoryVersionData: () => (/* binding */ useHistoryVersionData),\n/* harmony export */   useInboxNotifications: () => (/* binding */ useInboxNotifications),\n/* harmony export */   useInboxNotificationsSuspense: () => (/* binding */ useInboxNotificationsSuspense),\n/* harmony export */   useLostConnectionListener: () => (/* binding */ useLostConnectionListener),\n/* harmony export */   useMarkAllInboxNotificationsAsRead: () => (/* binding */ useMarkAllInboxNotificationsAsRead),\n/* harmony export */   useMarkInboxNotificationAsRead: () => (/* binding */ useMarkInboxNotificationAsRead),\n/* harmony export */   useMarkThreadAsRead: () => (/* binding */ useMarkThreadAsRead),\n/* harmony export */   useMarkThreadAsResolved: () => (/* binding */ useMarkThreadAsResolved),\n/* harmony export */   useMarkThreadAsUnresolved: () => (/* binding */ useMarkThreadAsUnresolved),\n/* harmony export */   useOthersConnectionIds: () => (/* binding */ useOthersConnectionIds),\n/* harmony export */   useOthersConnectionIdsSuspense: () => (/* binding */ useOthersConnectionIdsSuspense),\n/* harmony export */   useRedo: () => (/* binding */ useRedo),\n/* harmony export */   useRemoveReaction: () => (/* binding */ useRemoveReaction),\n/* harmony export */   useRoomInfo: () => (/* binding */ useRoomInfo),\n/* harmony export */   useRoomInfoSuspense: () => (/* binding */ useRoomInfoSuspense),\n/* harmony export */   useStatus: () => (/* binding */ useStatus),\n/* harmony export */   useStorageStatus: () => (/* binding */ useStorageStatus),\n/* harmony export */   useStorageStatusSuspense: () => (/* binding */ useStorageStatusSuspense),\n/* harmony export */   useThreadSubscription: () => (/* binding */ useThreadSubscription),\n/* harmony export */   useUndo: () => (/* binding */ useUndo),\n/* harmony export */   useUnreadInboxNotificationsCount: () => (/* binding */ useUnreadInboxNotificationsCount),\n/* harmony export */   useUnreadInboxNotificationsCountSuspense: () => (/* binding */ useUnreadInboxNotificationsCountSuspense),\n/* harmony export */   useUpdateRoomNotificationSettings: () => (/* binding */ useUpdateRoomNotificationSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n// src/contexts.ts\n\nvar RoomContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useRoomOrNull() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n}\nfunction useIsInsideRoom() {\n  const room = useRoomOrNull();\n  return room !== null;\n}\n\n// src/liveblocks.tsx\n\n\n\n\n\n// src/config.ts\nvar SECONDS = 1e3;\nvar MINUTES = 60 * SECONDS;\nvar config = {\n  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,\n  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,\n  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,\n  USER_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,\n  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,\n  NOTIFICATION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS\n};\n\n// src/lib/shallow2.ts\n\nfunction shallow2(a, b) {\n  if (!(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(a) || !(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(b)) {\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow)(a, b);\n  }\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(b, key) && (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow)(a[key], b[key])\n  );\n}\n\n// src/lib/use-initial.ts\n\n\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\n// src/lib/use-initial.ts\nvar noop = (state) => state;\nfunction useInitial(value) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(noop, value)[0];\n}\nfunction useInitialUnlessFunction(latestValue) {\n  const frozenValue = useInitial(latestValue);\n  if (typeof frozenValue === \"function\") {\n    const ref = useLatest(latestValue);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args) => ref.current(...args), [\n      ref\n    ]);\n  } else {\n    return frozenValue;\n  }\n}\n\n// src/lib/use-polyfill.ts\nvar use = (\n  // React.use ||\n  (promise) => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  }\n);\n\n// src/umbrella-store.ts\n\n\n// src/lib/autobind.ts\nfunction autobind(self) {\n  const seen = /* @__PURE__ */ new Set();\n  seen.add(\"constructor\");\n  let obj = self.constructor.prototype;\n  do {\n    for (const key of Reflect.ownKeys(obj)) {\n      if (seen.has(key)) continue;\n      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n      if (typeof descriptor?.value === \"function\") {\n        seen.add(key);\n        self[key] = self[key].bind(self);\n      }\n    }\n  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);\n}\n\n// src/ThreadDB.ts\n\n\n// src/lib/guards.ts\n\nfunction isStartsWith(blob) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(blob) && isString(blob.startsWith);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\n// src/lib/querying.ts\nfunction makeThreadsFilter(query) {\n  return (thread) => matchesQuery(thread, query) && matchesMetadata(thread, query);\n}\nfunction matchesQuery(thread, q) {\n  return q.resolved === void 0 || thread.resolved === q.resolved;\n}\nfunction matchesMetadata(thread, q) {\n  const metadata = thread.metadata;\n  return q.metadata === void 0 || Object.entries(q.metadata).every(\n    ([key, op]) => (\n      // NOTE: `op` can be explicitly-`undefined` here, which ideally would not\n      // mean \"filter for absence\" like it does now, as this does not match the\n      // backend behavior at the moment. For an in-depth discussion, see\n      // https://liveblocks.slack.com/archives/C02PZL7QAAW/p1728546988505989\n      matchesOperator(metadata[key], op)\n    )\n  );\n}\nfunction matchesOperator(value, op) {\n  if (isStartsWith(op)) {\n    return isString(value) && value.startsWith(op.startsWith);\n  } else {\n    return value === op;\n  }\n}\n\n// src/ThreadDB.ts\nfunction sanitizeThread(thread) {\n  if (thread.deletedAt) {\n    if (thread.comments.length > 0) {\n      return { ...thread, comments: [] };\n    }\n  }\n  const hasComment = thread.comments.some((c) => !c.deletedAt);\n  if (!hasComment) {\n    return { ...thread, deletedAt: /* @__PURE__ */ new Date(), comments: [] };\n  }\n  return thread;\n}\nvar ThreadDB = class _ThreadDB {\n  // The version is auto-incremented on every mutation and can be used as a reliable indicator to tell if the contents of the thread pool has changed\n  constructor() {\n    this._asc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.SortedList.from([], (t1, t2) => {\n      const d1 = t1.createdAt;\n      const d2 = t2.createdAt;\n      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;\n    });\n    this._desc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.SortedList.from([], (t1, t2) => {\n      const d2 = t2.updatedAt;\n      const d1 = t1.updatedAt;\n      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;\n    });\n    this._byId = /* @__PURE__ */ new Map();\n    this._version = 0;\n  }\n  //\n  // Public APIs\n  //\n  clone() {\n    const newPool = new _ThreadDB();\n    newPool._byId = new Map(this._byId);\n    newPool._asc = this._asc.clone();\n    newPool._desc = this._desc.clone();\n    newPool._version = this._version;\n    return newPool;\n  }\n  /** Gets the transaction count for this DB. Increments any time the DB is modified. */\n  get version() {\n    return this._version;\n  }\n  /** Returns an existing thread by ID. Will never return a deleted thread. */\n  get(threadId) {\n    const thread = this.getEvenIfDeleted(threadId);\n    return thread?.deletedAt ? void 0 : thread;\n  }\n  /** Returns the (possibly deleted) thread by ID. */\n  getEvenIfDeleted(threadId) {\n    return this._byId.get(threadId);\n  }\n  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */\n  upsert(thread) {\n    thread = sanitizeThread(thread);\n    const id = thread.id;\n    const toRemove = this._byId.get(id);\n    if (toRemove) {\n      if (toRemove.deletedAt) return;\n      this._asc.remove(toRemove);\n      this._desc.remove(toRemove);\n    }\n    if (!thread.deletedAt) {\n      this._asc.add(thread);\n      this._desc.add(thread);\n    }\n    this._byId.set(id, thread);\n    this.touch();\n  }\n  /** Like .upsert(), except it won't update if a thread by this ID already exists. */\n  // TODO Consider renaming this to just .upsert(). I'm not sure if we really\n  // TODO need the raw .upsert(). Would be nice if this behavior was the default.\n  upsertIfNewer(thread) {\n    const existing = this.get(thread.id);\n    if (!existing || thread.updatedAt >= existing.updatedAt) {\n      this.upsert(thread);\n    }\n  }\n  /**\n   * Marks a thread as deleted. It will no longer pop up in .findMany()\n   * queries, but it can still be accessed via `.getEvenIfDeleted()`.\n   */\n  delete(threadId, deletedAt) {\n    const existing = this._byId.get(threadId);\n    if (existing && !existing.deletedAt) {\n      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });\n    }\n  }\n  /**\n   * Returns all threads matching a given roomId and query. If roomId is not\n   * specified, it will return all threads matching the query, across all\n   * rooms.\n   *\n   * Returns the results in the requested order. Please note:\n   *   'asc'  means by createdAt ASC\n   *   'desc' means by updatedAt DESC\n   *\n   * Will never return deleted threads in the result.\n   */\n  findMany(roomId, query, direction) {\n    const index = direction === \"desc\" ? this._desc : this._asc;\n    const crit = [];\n    if (roomId !== void 0) {\n      crit.push((t) => t.roomId === roomId);\n    }\n    crit.push(makeThreadsFilter(query));\n    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));\n  }\n  //\n  // Private APIs\n  //\n  touch() {\n    ++this._version;\n  }\n};\n\n// src/umbrella-store.ts\nfunction makeRoomThreadsQueryKey(roomId, query) {\n  return `${roomId}-${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(query ?? {})}`;\n}\nfunction makeUserThreadsQueryKey(query) {\n  return `USER_THREADS:${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(query ?? {})}`;\n}\nfunction makeNotificationSettingsQueryKey(roomId) {\n  return `${roomId}:NOTIFICATION_SETTINGS`;\n}\nfunction makeVersionsQueryKey(roomId) {\n  return `${roomId}-VERSIONS`;\n}\nfunction usify(promise) {\n  if (\"status\" in promise) {\n    return promise;\n  }\n  const usable = promise;\n  usable.status = \"pending\";\n  usable.then(\n    (value) => {\n      usable.status = \"fulfilled\";\n      usable.value = value;\n    },\n    (err) => {\n      usable.status = \"rejected\";\n      usable.reason = err;\n    }\n  );\n  return usable;\n}\nvar noop2 = Promise.resolve();\nvar ASYNC_LOADING = Object.freeze({ isLoading: true });\nvar PaginatedResource = class {\n  constructor(fetchPage) {\n    this._cachedPromise = null;\n    this._paginationState = null;\n    this._fetchPage = fetchPage;\n    this._eventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    this._pendingFetchMore = null;\n    this.observable = this._eventSource.observable;\n    autobind(this);\n  }\n  patchPaginationState(patch) {\n    const state = this._paginationState;\n    if (state === null) return;\n    this._paginationState = { ...state, ...patch };\n    this._eventSource.notify();\n  }\n  async _fetchMore() {\n    const state = this._paginationState;\n    if (!state?.cursor) {\n      return;\n    }\n    this.patchPaginationState({ isFetchingMore: true });\n    try {\n      const nextCursor = await this._fetchPage(state.cursor);\n      this.patchPaginationState({\n        cursor: nextCursor,\n        fetchMoreError: void 0,\n        isFetchingMore: false\n      });\n    } catch (err) {\n      this.patchPaginationState({\n        isFetchingMore: false,\n        fetchMoreError: err\n      });\n    }\n  }\n  fetchMore() {\n    const state = this._paginationState;\n    if (state?.cursor === null) {\n      return noop2;\n    }\n    if (!this._pendingFetchMore) {\n      this._pendingFetchMore = this._fetchMore().finally(() => {\n        this._pendingFetchMore = null;\n      });\n    }\n    return this._pendingFetchMore;\n  }\n  get() {\n    const usable = this._cachedPromise;\n    if (usable === null || usable.status === \"pending\") {\n      return ASYNC_LOADING;\n    }\n    if (usable.status === \"rejected\") {\n      return { isLoading: false, error: usable.reason };\n    }\n    const state = this._paginationState;\n    return {\n      isLoading: false,\n      data: {\n        fetchMore: this.fetchMore,\n        isFetchingMore: state.isFetchingMore,\n        fetchMoreError: state.fetchMoreError,\n        hasFetchedAll: state.cursor === null\n      }\n    };\n  }\n  waitUntilLoaded() {\n    if (this._cachedPromise) {\n      return this._cachedPromise;\n    }\n    const initialFetcher = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.autoRetry)(\n      () => this._fetchPage(\n        /* cursor */\n        void 0\n      ),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(\n      initialFetcher.then((cursor) => {\n        this._paginationState = {\n          cursor,\n          isFetchingMore: false,\n          fetchMoreError: void 0\n        };\n      })\n    );\n    promise.then(\n      () => this._eventSource.notify(),\n      () => {\n        this._eventSource.notify();\n        setTimeout(() => {\n          this._cachedPromise = null;\n          this._eventSource.notify();\n        }, 5e3);\n      }\n    );\n    this._cachedPromise = promise;\n    return promise;\n  }\n};\nvar SinglePageResource = class {\n  constructor(fetchPage) {\n    this._cachedPromise = null;\n    this._fetchPage = fetchPage;\n    this._eventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    this.observable = this._eventSource.observable;\n    autobind(this);\n  }\n  get() {\n    const usable = this._cachedPromise;\n    if (usable === null || usable.status === \"pending\") {\n      return ASYNC_LOADING;\n    }\n    if (usable.status === \"rejected\") {\n      return { isLoading: false, error: usable.reason };\n    }\n    return {\n      isLoading: false,\n      data: void 0\n    };\n  }\n  waitUntilLoaded() {\n    if (this._cachedPromise) {\n      return this._cachedPromise;\n    }\n    const initialFetcher = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.autoRetry)(\n      () => this._fetchPage(),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(initialFetcher);\n    promise.then(\n      () => this._eventSource.notify(),\n      () => {\n        this._eventSource.notify();\n        setTimeout(() => {\n          this._cachedPromise = null;\n          this._eventSource.notify();\n        }, 5e3);\n      }\n    );\n    this._cachedPromise = promise;\n    return promise;\n  }\n};\nvar UmbrellaStore = class {\n  constructor(client) {\n    this._prevVersion = -1;\n    this._prevState = null;\n    this._stateCached = null;\n    // Notifications\n    this._notificationsLastRequestedAt = null;\n    // Room Threads\n    this._roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n    this._roomThreads = /* @__PURE__ */ new Map();\n    // User Threads\n    this._userThreadsLastRequestedAt = null;\n    this._userThreads = /* @__PURE__ */ new Map();\n    // Room versions\n    this._roomVersions = /* @__PURE__ */ new Map();\n    this._roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n    // Room notification settings\n    this._roomNotificationSettings = /* @__PURE__ */ new Map();\n    this._client = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].as();\n    const inboxFetcher = async (cursor) => {\n      const result = await this._client.getInboxNotifications({ cursor });\n      this.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications\n      );\n      if (this._notificationsLastRequestedAt === null) {\n        this._notificationsLastRequestedAt = result.requestedAt;\n      }\n      const nextCursor = result.nextCursor;\n      return nextCursor;\n    };\n    this._notifications = new PaginatedResource(inboxFetcher);\n    this._notifications.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._rawThreadsDB = new ThreadDB();\n    this._store = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createStore)({\n      optimisticUpdates: [],\n      notificationsById: {},\n      settingsByRoomId: {},\n      versionsByRoomId: {}\n    });\n    autobind(this);\n  }\n  get() {\n    const rawState = this._store.get();\n    if (this._prevVersion !== this._rawThreadsDB.version || // Note: Version check is only needed temporarily, until we can get rid of the Zustand-like update model\n    this._prevState !== rawState || this._stateCached === null) {\n      this._stateCached = internalToExternalState(rawState, this._rawThreadsDB);\n      this._prevState = rawState;\n      this._prevVersion = this._rawThreadsDB.version;\n    }\n    return this._stateCached;\n  }\n  batch(callback) {\n    return this._store.batch(callback);\n  }\n  getFullState() {\n    return this.get();\n  }\n  /**\n   * Returns the async result of the given query and room id. If the query is success,\n   * then it will return the threads that match that provided query and room id.\n   *\n   */\n  getRoomThreadsLoadingState(roomId, query) {\n    const queryKey = makeRoomThreadsQueryKey(roomId, query);\n    const paginatedResource = this._roomThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = paginatedResource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    const threads = this.getFullState().threadsDB.findMany(\n      roomId,\n      query ?? {},\n      \"asc\"\n    );\n    const page = asyncResult.data;\n    return {\n      isLoading: false,\n      threads,\n      hasFetchedAll: page.hasFetchedAll,\n      isFetchingMore: page.isFetchingMore,\n      fetchMoreError: page.fetchMoreError,\n      fetchMore: page.fetchMore\n    };\n  }\n  getUserThreadsLoadingState(query) {\n    const queryKey = makeUserThreadsQueryKey(query);\n    const paginatedResource = this._userThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = paginatedResource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    const threads = this.getFullState().threadsDB.findMany(\n      void 0,\n      // Do _not_ filter by roomId\n      query ?? {},\n      \"desc\"\n    );\n    const page = asyncResult.data;\n    return {\n      isLoading: false,\n      threads,\n      hasFetchedAll: page.hasFetchedAll,\n      isFetchingMore: page.isFetchingMore,\n      fetchMoreError: page.fetchMoreError,\n      fetchMore: page.fetchMore\n    };\n  }\n  // NOTE: This will read the async result, but WILL NOT start loading at the moment!\n  getInboxNotificationsLoadingState() {\n    const asyncResult = this._notifications.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    const page = asyncResult.data;\n    return {\n      isLoading: false,\n      inboxNotifications: this.getFullState().cleanedNotifications,\n      hasFetchedAll: page.hasFetchedAll,\n      isFetchingMore: page.isFetchingMore,\n      fetchMoreError: page.fetchMoreError,\n      fetchMore: page.fetchMore\n    };\n  }\n  // NOTE: This will read the async result, but WILL NOT start loading at the moment!\n  getNotificationSettingsLoadingState(roomId) {\n    const queryKey = makeNotificationSettingsQueryKey(roomId);\n    const resource = this._roomNotificationSettings.get(queryKey);\n    if (resource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = resource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    return {\n      isLoading: false,\n      settings: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(this.get().settingsByRoomId[roomId])\n    };\n  }\n  getRoomVersionsLoadingState(roomId) {\n    const queryKey = makeVersionsQueryKey(roomId);\n    const resource = this._roomVersions.get(queryKey);\n    if (resource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = resource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    return {\n      isLoading: false,\n      versions: Object.values(this.get().versionsByRoomId[roomId] ?? {})\n    };\n  }\n  /**\n   * @private Only used by the E2E test suite.\n   */\n  _hasOptimisticUpdates() {\n    return this._store.get().optimisticUpdates.length > 0;\n  }\n  subscribe(callback) {\n    return this._store.subscribe(callback);\n  }\n  // Direct low-level cache mutations ------------------------------------------------- {{{\n  mutateThreadsDB(mutate) {\n    const db = this._rawThreadsDB;\n    const old = db.version;\n    mutate(db);\n    if (old !== db.version) {\n      this._store.set((state) => ({ ...state }));\n    }\n  }\n  updateInboxNotificationsCache(mapFn) {\n    this._store.set((state) => {\n      const inboxNotifications = mapFn(state.notificationsById);\n      return inboxNotifications !== state.notificationsById ? { ...state, notificationsById: inboxNotifications } : state;\n    });\n  }\n  setNotificationSettings(roomId, settings) {\n    this._store.set((state) => ({\n      ...state,\n      settingsByRoomId: {\n        ...state.settingsByRoomId,\n        [roomId]: settings\n      }\n    }));\n  }\n  updateRoomVersions(roomId, versions) {\n    this._store.set((state) => {\n      const versionsById = Object.fromEntries(\n        versions.map((version2) => [version2.id, version2])\n      );\n      return {\n        ...state,\n        versionsByRoomId: {\n          ...state.versionsByRoomId,\n          [roomId]: {\n            // Merge with existing versions for the room, or start with an empty object\n            ...state.versionsByRoomId[roomId] ?? {},\n            ...versionsById\n          }\n        }\n      };\n    });\n  }\n  updateOptimisticUpdatesCache(mapFn) {\n    this._store.set((state) => ({\n      ...state,\n      optimisticUpdates: mapFn(state.optimisticUpdates)\n    }));\n  }\n  // ---------------------------------------------------------------------------------- }}}\n  /** @internal - Only call this method from unit tests. */\n  force_set(callback) {\n    return this._store.set(callback);\n  }\n  /**\n   * Updates an existing inbox notification with a new value, replacing the\n   * corresponding optimistic update.\n   *\n   * This will not update anything if the inbox notification ID isn't found in\n   * the cache.\n   */\n  updateInboxNotification(inboxNotificationId, optimisticUpdateId, callback) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache((cache) => {\n        const existing = cache[inboxNotificationId];\n        if (!existing) {\n          return cache;\n        }\n        const inboxNotifications = {\n          ...cache,\n          [inboxNotificationId]: callback(existing)\n        };\n        return inboxNotifications;\n      });\n    });\n  }\n  /**\n   * Updates *all* inbox notifications by running a mapper function over all of\n   * them, replacing the corresponding optimistic update.\n   */\n  updateAllInboxNotifications(optimisticUpdateId, mapFn) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache((cache) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.mapValues)(cache, mapFn));\n    });\n  }\n  /**\n   * Deletes an existing inbox notification, replacing the corresponding\n   * optimistic update.\n   */\n  deleteInboxNotification(inboxNotificationId, optimisticUpdateId) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache((cache) => {\n        const { [inboxNotificationId]: removed, ...newCache } = cache;\n        return removed === void 0 ? cache : newCache;\n      });\n    });\n  }\n  /**\n   * Deletes *all* inbox notifications, replacing the corresponding optimistic\n   * update.\n   */\n  deleteAllInboxNotifications(optimisticUpdateId) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache(() => ({}));\n    });\n  }\n  /**\n   * Creates an new thread, replacing the corresponding optimistic update.\n   */\n  createThread(optimisticUpdateId, thread) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.mutateThreadsDB((db) => db.upsert(thread));\n    });\n  }\n  /**\n   * Updates an existing thread with a new value, replacing the corresponding\n   * optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found in the cache; or\n   * - The thread ID was already deleted from the cache; or\n   * - The thread ID in the cache was updated more recently than the optimistic\n   *   update's timestamp (if given)\n   */\n  updateThread(threadId, optimisticUpdateId, callback, updatedAt) {\n    this._store.batch(() => {\n      if (optimisticUpdateId !== null) {\n        this.removeOptimisticUpdate(optimisticUpdateId);\n      }\n      this.mutateThreadsDB((db) => {\n        const existing = db.get(threadId);\n        if (!existing) return;\n        if (!!updatedAt && existing.updatedAt > updatedAt) return;\n        db.upsert(callback(existing));\n      });\n    });\n  }\n  patchThread(threadId, optimisticUpdateId, patch, updatedAt) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => ({ ...thread, ...(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.compactObject)(patch) }),\n      updatedAt\n    );\n  }\n  addReaction(threadId, optimisticUpdateId, commentId, reaction, createdAt) {\n    this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyAddReaction(thread, commentId, reaction),\n      createdAt\n    );\n  }\n  removeReaction(threadId, optimisticUpdateId, commentId, emoji, userId, removedAt) {\n    this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),\n      removedAt\n    );\n  }\n  /**\n   * Soft-deletes an existing thread by setting its `deletedAt` value,\n   * replacing the corresponding optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found in the cache; or\n   * - The thread ID was already deleted from the cache\n   */\n  deleteThread(threadId, optimisticUpdateId) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      // A deletion is actually an update of the deletedAt property internally\n      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })\n    );\n  }\n  /**\n   * Creates an existing comment and ensures the associated notification is\n   * updated correctly, replacing the corresponding optimistic update.\n   */\n  createComment(newComment, optimisticUpdateId) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      const existingThread = this._rawThreadsDB.get(newComment.threadId);\n      if (!existingThread) {\n        return;\n      }\n      this.mutateThreadsDB(\n        (db) => db.upsert(applyUpsertComment(existingThread, newComment))\n      );\n      this.updateInboxNotificationsCache((cache) => {\n        const existingNotification = Object.values(cache).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === newComment.threadId\n        );\n        if (!existingNotification) {\n          return cache;\n        }\n        return {\n          ...cache,\n          [existingNotification.id]: {\n            ...existingNotification,\n            notifiedAt: newComment.createdAt,\n            readAt: newComment.createdAt\n          }\n        };\n      });\n    });\n  }\n  editComment(threadId, optimisticUpdateId, editedComment) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyUpsertComment(thread, editedComment)\n    );\n  }\n  deleteComment(threadId, optimisticUpdateId, commentId, deletedAt) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyDeleteComment(thread, commentId, deletedAt),\n      deletedAt\n    );\n  }\n  updateThreadAndNotification(thread, inboxNotification) {\n    this._store.batch(() => {\n      this.mutateThreadsDB((db) => db.upsertIfNewer(thread));\n      if (inboxNotification !== void 0) {\n        this.updateInboxNotificationsCache((cache) => ({\n          ...cache,\n          [inboxNotification.id]: inboxNotification\n        }));\n      }\n    });\n  }\n  updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads = [], deletedInboxNotifications = []) {\n    this._store.batch(() => {\n      this.mutateThreadsDB(\n        (db) => applyThreadDeltaUpdates(db, { newThreads: threads, deletedThreads })\n      );\n      this.updateInboxNotificationsCache(\n        (cache) => applyNotificationsUpdates(cache, {\n          newInboxNotifications: inboxNotifications,\n          deletedNotifications: deletedInboxNotifications\n        })\n      );\n    });\n  }\n  /**\n   * Updates existing notification setting for a room with a new value,\n   * replacing the corresponding optimistic update.\n   */\n  updateRoomNotificationSettings_confirmOptimisticUpdate(roomId, optimisticUpdateId, settings) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.setNotificationSettings(roomId, settings);\n    });\n  }\n  addOptimisticUpdate(optimisticUpdate) {\n    const id = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nanoid)();\n    const newUpdate = { ...optimisticUpdate, id };\n    this.updateOptimisticUpdatesCache((cache) => [...cache, newUpdate]);\n    return id;\n  }\n  removeOptimisticUpdate(optimisticUpdateId) {\n    this.updateOptimisticUpdatesCache(\n      (cache) => cache.filter((ou) => ou.id !== optimisticUpdateId)\n    );\n  }\n  async fetchNotificationsDeltaUpdate(signal) {\n    const lastRequestedAt = this._notificationsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this._client.getInboxNotificationsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this._notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadsAndNotifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n  }\n  waitUntilNotificationsLoaded() {\n    return this._notifications.waitUntilLoaded();\n  }\n  waitUntilRoomThreadsLoaded(roomId, query) {\n    const threadsFetcher = async (cursor) => {\n      const room = this._client.getRoom(roomId);\n      if (room === null) {\n        throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError(`Room '${roomId}' is not available on client`, 479);\n      }\n      const result = await room.getThreads({ cursor, query });\n      this.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications\n      );\n      const lastRequestedAt = this._roomThreadsLastRequestedAtByRoom.get(roomId);\n      if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n        this._roomThreadsLastRequestedAtByRoom.set(roomId, result.requestedAt);\n      }\n      return result.nextCursor;\n    };\n    const queryKey = makeRoomThreadsQueryKey(roomId, query);\n    let paginatedResource = this._roomThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      paginatedResource = new PaginatedResource(threadsFetcher);\n    }\n    paginatedResource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._roomThreads.set(queryKey, paginatedResource);\n    return paginatedResource.waitUntilLoaded();\n  }\n  async fetchRoomThreadsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this._roomThreadsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(\n      this._client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const updates = await room.getThreadsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    this.updateThreadsAndNotifications(\n      updates.threads.updated,\n      updates.inboxNotifications.updated,\n      updates.threads.deleted,\n      updates.inboxNotifications.deleted\n    );\n    if (lastRequestedAt < updates.requestedAt) {\n      this._roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  waitUntilUserThreadsLoaded(query) {\n    const queryKey = makeUserThreadsQueryKey(query);\n    const threadsFetcher = async (cursor) => {\n      const result = await this._client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getUserThreads_experimental({\n        cursor,\n        query\n      });\n      this.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications\n      );\n      if (this._userThreadsLastRequestedAt === null) {\n        this._userThreadsLastRequestedAt = result.requestedAt;\n      }\n      return result.nextCursor;\n    };\n    let paginatedResource = this._userThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      paginatedResource = new PaginatedResource(threadsFetcher);\n    }\n    paginatedResource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._userThreads.set(queryKey, paginatedResource);\n    return paginatedResource.waitUntilLoaded();\n  }\n  async fetchUserThreadsDeltaUpdate(signal) {\n    const lastRequestedAt = this._userThreadsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this._client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getUserThreadsSince_experimental({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this._notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadsAndNotifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n  }\n  waitUntilRoomVersionsLoaded(roomId) {\n    const queryKey = makeVersionsQueryKey(roomId);\n    let resource = this._roomVersions.get(queryKey);\n    if (resource === void 0) {\n      const versionsFetcher = async () => {\n        const room = this._client.getRoom(roomId);\n        if (room === null) {\n          throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError(\n            `Room '${roomId}' is not available on client`,\n            479\n          );\n        }\n        const result = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].listTextVersions();\n        this.updateRoomVersions(roomId, result.versions);\n        const lastRequestedAt = this._roomVersionsLastRequestedAtByRoom.get(roomId);\n        if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n          this._roomVersionsLastRequestedAtByRoom.set(\n            roomId,\n            result.requestedAt\n          );\n        }\n      };\n      resource = new SinglePageResource(versionsFetcher);\n    }\n    resource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._roomVersions.set(queryKey, resource);\n    return resource.waitUntilLoaded();\n  }\n  async fetchRoomVersionsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this._roomVersionsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(\n      this._client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const updates = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].listTextVersionsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    this.updateRoomVersions(roomId, updates.versions);\n    if (lastRequestedAt < updates.requestedAt) {\n      this._roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  waitUntilRoomNotificationSettingsLoaded(roomId) {\n    const queryKey = makeNotificationSettingsQueryKey(roomId);\n    let resource = this._roomNotificationSettings.get(queryKey);\n    if (resource === void 0) {\n      const notificationSettingsFetcher = async () => {\n        const room = this._client.getRoom(roomId);\n        if (room === null) {\n          throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError(\n            `Room '${roomId}' is not available on client`,\n            479\n          );\n        }\n        const result = await room.getNotificationSettings();\n        this.setNotificationSettings(roomId, result);\n      };\n      resource = new SinglePageResource(notificationSettingsFetcher);\n    }\n    resource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._roomNotificationSettings.set(queryKey, resource);\n    return resource.waitUntilLoaded();\n  }\n  async refreshRoomNotificationSettings(roomId, signal) {\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(\n      this._client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const result = await room.getNotificationSettings({ signal });\n    this.setNotificationSettings(roomId, result);\n  }\n};\nfunction internalToExternalState(state, rawThreadsDB) {\n  const threadsDB = rawThreadsDB.clone();\n  const computed = {\n    notificationsById: { ...state.notificationsById },\n    settingsByRoomId: { ...state.settingsByRoomId }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        threadsDB.upsert(optimisticUpdate.thread);\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        if (thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        threadsDB.upsert({\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        });\n        break;\n      }\n      case \"mark-thread-as-resolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: true });\n        break;\n      }\n      case \"mark-thread-as-unresolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: false });\n        break;\n      }\n      case \"create-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        const inboxNotification = Object.values(\n          computed.notificationsById\n        ).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        computed.notificationsById[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyDeleteComment(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.deletedAt\n          )\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({\n          ...thread,\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        });\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyAddReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.reaction\n          )\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyRemoveReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.emoji,\n            optimisticUpdate.userId,\n            optimisticUpdate.removedAt\n          )\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        const ibn = computed.notificationsById[optimisticUpdate.inboxNotificationId];\n        if (ibn === void 0) {\n          break;\n        }\n        computed.notificationsById[optimisticUpdate.inboxNotificationId] = {\n          ...ibn,\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in computed.notificationsById) {\n          const ibn = computed.notificationsById[id];\n          if (ibn === void 0) {\n            break;\n          }\n          computed.notificationsById[id] = {\n            ...ibn,\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        delete computed.notificationsById[optimisticUpdate.inboxNotificationId];\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        computed.notificationsById = {};\n        break;\n      }\n      case \"update-notification-settings\": {\n        const settings = computed.settingsByRoomId[optimisticUpdate.roomId];\n        if (settings === void 0) {\n          break;\n        }\n        computed.settingsByRoomId[optimisticUpdate.roomId] = {\n          ...settings,\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  const cleanedNotifications = (\n    // Sort so that the most recent notifications are first\n    Object.values(computed.notificationsById).filter(\n      (ibn) => ibn.kind === \"thread\" ? threadsDB.get(ibn.threadId) !== void 0 : true\n    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())\n  );\n  return {\n    cleanedNotifications,\n    notificationsById: computed.notificationsById,\n    settingsByRoomId: computed.settingsByRoomId,\n    threadsDB,\n    versionsByRoomId: state.versionsByRoomId\n  };\n}\nfunction applyThreadDeltaUpdates(db, updates) {\n  updates.newThreads.forEach((thread) => db.upsertIfNewer(thread));\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existing = db.getEvenIfDeleted(id);\n    if (!existing) return;\n    db.delete(id, deletedAt);\n  });\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1) return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction applyUpsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt.getTime(),\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction applyDeleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      // We optimistically remove the comment body and attachments when marking it as deleted\n      body: void 0,\n      attachments: []\n    } : comment\n  );\n  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction applyAddReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/liveblocks.tsx\nvar ClientContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction missingUserError(userId) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\nfunction missingRoomInfoError(roomId) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\nfunction identity(x) {\n  return x;\n}\nvar _umbrellaStores = /* @__PURE__ */ new WeakMap();\nvar _extras = /* @__PURE__ */ new WeakMap();\nvar _bundles = /* @__PURE__ */ new WeakMap();\nfunction selectUnreadInboxNotificationsCount(inboxNotifications) {\n  let count = 0;\n  for (const notification of inboxNotifications) {\n    if (notification.readAt === null || notification.readAt < notification.notifiedAt) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction selectorFor_useUnreadInboxNotificationsCount(result) {\n  if (!result.inboxNotifications) {\n    return result;\n  }\n  return {\n    isLoading: false,\n    count: selectUnreadInboxNotificationsCount(result.inboxNotifications)\n  };\n}\nfunction selectorFor_useUser(state, userId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId)\n    };\n  }\n  return {\n    isLoading: false,\n    user: state.data\n  };\n}\nfunction selectorFor_useRoomInfo(state, roomId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId)\n    };\n  }\n  return {\n    isLoading: false,\n    info: state.data\n  };\n}\nfunction getOrCreateContextBundle(client) {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getUmbrellaStoreForClient(client) {\n  let store = _umbrellaStores.get(client);\n  if (!store) {\n    store = new UmbrellaStore(client);\n    _umbrellaStores.set(client, store);\n  }\n  return store;\n}\nfunction getLiveblocksExtrasForClient(client) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeLiveblocksExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n  return extras;\n}\nfunction makeLiveblocksExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  const notificationsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchNotificationsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.NOTIFICATIONS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n  );\n  const userThreadsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchUserThreadsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new user threads failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.USER_THREADS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }\n  );\n  return {\n    store,\n    notificationsPoller,\n    userThreadsPoller\n  };\n}\nfunction makeLiveblocksContextBundle(client) {\n  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);\n  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);\n  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);\n  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);\n  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);\n  function LiveblocksProvider2(props) {\n    useEnsureNoLiveblocksProvider();\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClientContext.Provider, { value: client }, props.children);\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    LiveblocksProvider: LiveblocksProvider2,\n    useInboxNotifications: () => useInboxNotifications_withClient(client, identity, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow),\n    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),\n    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n    useDeleteInboxNotification: useDeleteInboxNotification2,\n    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n    useInboxNotificationThread: useInboxNotificationThread2,\n    useUserThreads_experimental,\n    ...shared.classic,\n    suspense: {\n      LiveblocksProvider: LiveblocksProvider2,\n      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),\n      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),\n      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n      useDeleteInboxNotification: useDeleteInboxNotification2,\n      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n      useInboxNotificationThread: useInboxNotificationThread2,\n      useUserThreads_experimental: useUserThreadsSuspense_experimental,\n      ...shared.suspense\n    }\n  };\n  return bundle;\n}\nfunction useInboxNotifications_withClient(client, selector, isEqual) {\n  const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void store.waitUntilNotificationsLoaded();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.getInboxNotificationsLoadingState,\n    store.getInboxNotificationsLoadingState,\n    selector,\n    isEqual\n  );\n}\nfunction useInboxNotificationsSuspense_withClient(client) {\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.waitUntilNotificationsLoaded());\n  const result = useInboxNotifications_withClient(client, identity, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUnreadInboxNotificationsCount_withClient(client) {\n  return useInboxNotifications_withClient(\n    client,\n    selectorFor_useUnreadInboxNotificationsCount,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n}\nfunction useUnreadInboxNotificationsCountSuspense_withClient(client) {\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.waitUntilNotificationsLoaded());\n  const result = useUnreadInboxNotificationsCount_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  return result;\n}\nfunction useMarkInboxNotificationAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const readAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId,\n        readAt\n      });\n      client.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          store.updateInboxNotification(\n            inboxNotificationId,\n            optimisticUpdateId,\n            (inboxNotification) => ({ ...inboxNotification, readAt })\n          );\n        },\n        () => {\n          store.removeOptimisticUpdate(optimisticUpdateId);\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const readAt = /* @__PURE__ */ new Date();\n    const optimisticUpdateId = store.addOptimisticUpdate({\n      type: \"mark-all-inbox-notifications-as-read\",\n      readAt\n    });\n    client.markAllInboxNotificationsAsRead().then(\n      () => {\n        store.updateAllInboxNotifications(\n          optimisticUpdateId,\n          (inboxNotification) => ({ ...inboxNotification, readAt })\n        );\n      },\n      () => {\n        store.removeOptimisticUpdate(optimisticUpdateId);\n      }\n    );\n  }, [client]);\n}\nfunction useDeleteInboxNotification_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const deletedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"delete-inbox-notification\",\n        inboxNotificationId,\n        deletedAt\n      });\n      client.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          store.deleteInboxNotification(\n            inboxNotificationId,\n            optimisticUpdateId\n          );\n        },\n        () => {\n          store.removeOptimisticUpdate(optimisticUpdateId);\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useDeleteAllInboxNotifications_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const deletedAt = /* @__PURE__ */ new Date();\n    const optimisticUpdateId = store.addOptimisticUpdate({\n      type: \"delete-all-inbox-notifications\",\n      deletedAt\n    });\n    client.deleteAllInboxNotifications().then(\n      () => {\n        store.deleteAllInboxNotifications(optimisticUpdateId);\n      },\n      () => {\n        store.removeOptimisticUpdate(optimisticUpdateId);\n      }\n    );\n  }, [client]);\n}\nfunction useInboxNotificationThread_withClient(client, inboxNotificationId) {\n  const { store } = getLiveblocksExtrasForClient(client);\n  const getter = store.getFullState;\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => {\n      const inboxNotification = state.notificationsById[inboxNotificationId] ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(`Inbox notification with ID \"${inboxNotificationId}\" not found`);\n      if (inboxNotification.kind !== \"thread\") {\n        (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\n          `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n        );\n      }\n      const thread = state.threadsDB.get(inboxNotification.threadId) ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\n        `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n      );\n      return thread;\n    },\n    [inboxNotificationId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    // Re-evaluate if we need to update any time the notification changes over time\n    getter,\n    getter,\n    selector\n  );\n}\nfunction useUser_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useUser(state, userId),\n    [userId]\n  );\n  const result = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void usersStore.get(userId);\n  }, [usersStore, userId, result]);\n  return result;\n}\nfunction useUserSuspense_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n  if (!userState || userState.isLoading) {\n    throw usersStore.get(userId);\n  }\n  if (userState.error) {\n    throw userState.error;\n  }\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n  const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: void 0\n  };\n}\nfunction useRoomInfo_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n  const result = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void roomsInfoStore.get(roomId);\n  }, [roomsInfoStore, roomId, result]);\n  return result;\n}\nfunction useRoomInfoSuspense_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.get(roomId);\n  }\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n  const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.error, \"Unexpected error state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state.data !== void 0, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: void 0\n  };\n}\nfunction createSharedContext(client) {\n  const useClient2 = () => client;\n  return {\n    classic: {\n      useClient: useClient2,\n      useUser: (userId) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),\n      useIsInsideRoom\n    },\n    suspense: {\n      useClient: useClient2,\n      useUser: (userId) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),\n      useIsInsideRoom\n    }\n  };\n}\nfunction useEnsureNoLiveblocksProvider(options) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\nfunction useClientOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ClientContext);\n}\nfunction useClient() {\n  return useClientOrNull() ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\"LiveblocksProvider is missing from the React tree.\");\n}\nfunction LiveblocksProviderWithClient(props) {\n  useEnsureNoLiveblocksProvider(props);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClientContext.Provider, { value: props.client }, props.children);\n}\nfunction LiveblocksProvider(props) {\n  const { children, ...o } = props;\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging\n    )\n  };\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createClient)(options), []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiveblocksProviderWithClient, { client }, children);\n}\nfunction createLiveblocksContext(client) {\n  return getOrCreateContextBundle(client);\n}\nfunction useUserThreads_experimental(options = {\n  query: {\n    metadata: {}\n  }\n}) {\n  const client = useClient();\n  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => {\n      void store.waitUntilUserThreadsLoaded(options.query);\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const getter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => store.getUserThreadsLoadingState(options.query),\n    [store, options.query]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    getter,\n    getter,\n    identity,\n    shallow2\n    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!\n  );\n}\nfunction useUserThreadsSuspense_experimental(options = {\n  query: {\n    metadata: {}\n  }\n}) {\n  const client = useClient();\n  const { store } = getLiveblocksExtrasForClient(client);\n  use(store.waitUntilUserThreadsLoaded(options.query));\n  const result = useUserThreads_experimental(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useInboxNotifications() {\n  return useInboxNotifications_withClient(useClient(), identity, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n}\nfunction useInboxNotificationsSuspense() {\n  return useInboxNotificationsSuspense_withClient(useClient());\n}\nfunction useInboxNotificationThread(inboxNotificationId) {\n  return useInboxNotificationThread_withClient(\n    useClient(),\n    inboxNotificationId\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCount() {\n  return useUnreadInboxNotificationsCount_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCountSuspense() {\n  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());\n}\nfunction useUser(userId) {\n  const client = useClient();\n  return useUser_withClient(client, userId);\n}\nfunction useUserSuspense(userId) {\n  const client = useClient();\n  return useUserSuspense_withClient(client, userId);\n}\nfunction useRoomInfo(roomId) {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\nfunction useRoomInfoSuspense(roomId) {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\nvar _useInboxNotificationThread = useInboxNotificationThread;\nvar _useUser = useUser;\nvar _useUserSuspense = useUserSuspense;\nvar _useUserThreads_experimental = useUserThreads_experimental;\nvar _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;\n\n// src/types/errors.ts\nvar CreateThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateThreadError\";\n  }\n};\nvar DeleteThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteThreadError\";\n  }\n};\nvar EditThreadMetadataError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit thread metadata failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditThreadMetadataError\";\n  }\n};\nvar MarkThreadAsResolvedError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark thread as resolved failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkThreadAsResolvedError\";\n  }\n};\nvar MarkThreadAsUnresolvedError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark thread as unresolved failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkThreadAsUnresolvedError\";\n  }\n};\nvar CreateCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateCommentError\";\n  }\n};\nvar EditCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditCommentError\";\n  }\n};\nvar DeleteCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteCommentError\";\n  }\n};\nvar AddReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Add reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"AddReactionError\";\n  }\n};\nvar RemoveReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Remove reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"RemoveReactionError\";\n  }\n};\nvar MarkInboxNotificationAsReadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark inbox notification as read failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkInboxNotificationAsReadError\";\n  }\n};\nvar UpdateNotificationSettingsError = class extends Error {\n  constructor(cause, context) {\n    super(\"Update notification settings failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"UpdateNotificationSettingsError\";\n  }\n};\n\n// src/room.tsx\n\n\n\n\n\n// src/use-scroll-to-comment-on-load-effect.ts\n\nfunction handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {\n  if (shouldScrollOnLoad === false) return;\n  if (!state.threads) return;\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n  if (!commentId.startsWith(\"cm_\")) return;\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment2) => comment2.id === commentId\n  );\n  if (!isCommentInThreads) return;\n  comment.scrollIntoView();\n}\nfunction useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n\n// src/room.tsx\nvar SMOOTH_DELAY = 1e3;\nvar noop3 = () => {\n};\nvar identity2 = (x) => x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\\u2019re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(\n  roomId\n)} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\nvar superfluous_unstable_batchedUpdates = \"You don\\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\\u2019re on React 18+ already.\";\nfunction useSyncExternalStore2(s, gs, gss) {\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(s, gs, gss, identity2);\n}\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n  return null;\n}\nfunction selectorFor_useOthersConnectionIds(others) {\n  return others.map((user) => user.connectionId);\n}\nfunction makeMutationContext(room) {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n    setMyPresence: room.updatePresence\n  };\n}\nfunction getCurrentUserId(room) {\n  const self = room.getSelf();\n  if (self === null || self.id === void 0) {\n    return \"anonymous\";\n  } else {\n    return self.id;\n  }\n}\nfunction handleApiError(err) {\n  const message = `Request failed with status ${err.status}: ${err.message}`;\n  if (err.details?.error === \"FORBIDDEN\") {\n    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join(\"\\n\");\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.error(detailedMessage);\n  }\n  return new Error(message);\n}\nvar _extras2 = /* @__PURE__ */ new WeakMap();\nvar _bundles2 = /* @__PURE__ */ new WeakMap();\nfunction getOrCreateRoomContextBundle(client) {\n  let bundle = _bundles2.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles2.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getRoomExtrasForClient(client) {\n  let extras = _extras2.get(client);\n  if (!extras) {\n    extras = makeRoomExtrasForClient(client);\n    _extras2.set(client, extras);\n  }\n  return extras;\n}\nfunction makeRoomExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n  function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {\n    store.removeOptimisticUpdate(optimisticUpdateId);\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError) {\n      const error = handleApiError(innerError);\n      commentsErrorEventSource.notify(createPublicError(error));\n      return;\n    }\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError) {\n      handleApiError(innerError);\n      return;\n    }\n    throw innerError;\n  }\n  const threadsPollersByRoomId = /* @__PURE__ */ new Map();\n  const versionsPollersByRoomId = /* @__PURE__ */ new Map();\n  const roomNotificationSettingsPollersByRoomId = /* @__PURE__ */ new Map();\n  function getOrCreateThreadsPollerForRoomId(roomId) {\n    let poller = threadsPollersByRoomId.get(roomId);\n    if (!poller) {\n      poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n        async (signal) => {\n          try {\n            return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);\n          } catch (err) {\n            _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);\n            throw err;\n          }\n        },\n        config.ROOM_THREADS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }\n      );\n      threadsPollersByRoomId.set(roomId, poller);\n    }\n    return poller;\n  }\n  function getOrCreateVersionsPollerForRoomId(roomId) {\n    let poller = versionsPollersByRoomId.get(roomId);\n    if (!poller) {\n      poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n        async (signal) => {\n          try {\n            return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);\n          } catch (err) {\n            _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);\n            throw err;\n          }\n        },\n        config.HISTORY_VERSIONS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }\n      );\n      versionsPollersByRoomId.set(roomId, poller);\n    }\n    return poller;\n  }\n  function getOrCreateNotificationsSettingsPollerForRoomId(roomId) {\n    let poller = roomNotificationSettingsPollersByRoomId.get(roomId);\n    if (!poller) {\n      poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n        async (signal) => {\n          try {\n            return await store.refreshRoomNotificationSettings(roomId, signal);\n          } catch (err) {\n            _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Polling notification settings for '${roomId}' failed: ${String(err)}`);\n            throw err;\n          }\n        },\n        config.NOTIFICATION_SETTINGS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n      );\n      roomNotificationSettingsPollersByRoomId.set(roomId, poller);\n    }\n    return poller;\n  }\n  return {\n    store,\n    commentsErrorEventSource: commentsErrorEventSource.observable,\n    onMutationFailure,\n    getOrCreateThreadsPollerForRoomId,\n    getOrCreateVersionsPollerForRoomId,\n    getOrCreateNotificationsSettingsPollerForRoomId\n  };\n}\nfunction makeRoomContextBundle(client) {\n  function RoomProvider_withImplicitLiveblocksProvider(props) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiveblocksProviderWithClient, { client, allowNesting: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProvider, { ...props }));\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    RoomContext,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n    useRoom,\n    useStatus,\n    useStorageStatus,\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useErrorListener,\n    useEventListener,\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n    useStorageRoot,\n    useStorage,\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n    useMutation,\n    useThreads,\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useAttachmentUrl,\n    useHistoryVersions,\n    useHistoryVersionData,\n    useRoomNotificationSettings,\n    useUpdateRoomNotificationSettings,\n    ...shared.classic,\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n      useRoom,\n      useStatus,\n      useStorageStatus: useStorageStatusSuspense,\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useErrorListener,\n      useEventListener,\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n      useMutation,\n      useThreads: useThreadsSuspense,\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useAttachmentUrl: useAttachmentUrlSuspense,\n      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,\n      useHistoryVersions: useHistoryVersionsSuspense,\n      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n      useUpdateRoomNotificationSettings,\n      ...shared.suspense\n    },\n    useCommentsErrorListener\n  };\n  return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal, {\n    enumerable: false\n  });\n}\nfunction RoomProvider(props) {\n  const client = useClient();\n  const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => /* @__PURE__ */ new Map()\n  );\n  const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (roomId, options) => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n      const rv = client.enterRoom(roomId, options);\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    RoomProviderInner,\n    {\n      ...props,\n      stableEnterRoom\n    }\n  );\n}\nfunction RoomProviderInner(props) {\n  const client = useClient();\n  const { id: roomId, stableEnterRoom } = props;\n  if (true) {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n    if (!isString(roomId)) {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n    const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n    const oldReactVersion = majorReactVersion < 18;\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.errorIf)(\n      oldReactVersion && props.unstable_batchedUpdates === void 0,\n      missing_unstable_batchedUpdates(majorReactVersion, roomId)\n    );\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deprecateIf)(\n      !oldReactVersion && props.unstable_batchedUpdates !== void 0,\n      superfluous_unstable_batchedUpdates\n    );\n  }\n  const frozenProps = useInitial({\n    initialPresence: props.initialPresence,\n    initialStorage: props.initialStorage,\n    unstable_batchedUpdates: props.unstable_batchedUpdates,\n    autoConnect: props.autoConnect ?? typeof window !== \"undefined\"\n  });\n  const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false\n      // Deliberately using false here on the first render, see below\n    })\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const { store } = getRoomExtrasForClient(client);\n    async function handleCommentEvent(message) {\n      if (message.type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const info = await room.getThread(message.threadId);\n      if (!info.thread) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const { thread, inboxNotification } = info;\n      const existingThread = store.getFullState().threadsDB.getEvenIfDeleted(message.threadId);\n      switch (message.type) {\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_EDITED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_METADATA_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_ADDED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_DELETED:\n          if (!existingThread) break;\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        default:\n          break;\n      }\n    }\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n    setRoomLeavePair(pair);\n    const { room: room2, leave } = pair;\n    if (frozenProps.autoConnect) {\n      room2.connect();\n    }\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, { value: room }, props.children);\n}\nfunction useRoom() {\n  const room = useRoomOrNull();\n  if (room === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\nfunction useStatus() {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatus(options) {\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useStorageStatusSmooth();\n  } else {\n    return useStorageStatusImmediate();\n  }\n}\nfunction useStorageStatusImmediate() {\n  const room = useRoom();\n  const subscribe = room.events.storageStatus.subscribe;\n  const getSnapshot = room.getStorageStatus;\n  const getServerSnapshot = room.getStorageStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatusSmooth() {\n  const room = useRoom();\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(room.getStorageStatus);\n  const oldStatus = useLatest(room.getStorageStatus());\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let timeoutId;\n    const unsub = room.events.storageStatus.subscribe((newStatus) => {\n      if (oldStatus.current === \"synchronizing\" && newStatus === \"synchronized\") {\n        timeoutId = setTimeout(() => setStatus(newStatus), SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [room, oldStatus]);\n  return status;\n}\nfunction useBatch() {\n  return useRoom().batch;\n}\nfunction useBroadcastEvent() {\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (event, options = { shouldQueueEventIfNotReady: false }) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\nfunction useOthersListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\nfunction useLostConnectionListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.lostConnection.subscribe(\n      (event) => savedCallback.current(event)\n    ),\n    [room, savedCallback]\n  );\n}\nfunction useErrorListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.error.subscribe((e) => savedCallback.current(e)),\n    [room, savedCallback]\n  );\n}\nfunction useEventListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const listener = (eventData) => {\n      savedCallback.current(eventData);\n    };\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\nfunction useHistory() {\n  return useRoom().history;\n}\nfunction useUndo() {\n  return useHistory().undo;\n}\nfunction useRedo() {\n  return useHistory().redo;\n}\nfunction useCanUndo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return useSyncExternalStore2(subscribe, canUndo, canUndo);\n}\nfunction useCanRedo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return useSyncExternalStore2(subscribe, canRedo, canRedo);\n}\nfunction useSelf(maybeSelector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot = room.getSelf;\n  const selector = maybeSelector ?? identity2;\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (me) => me !== null ? selector(me) : null,\n    [selector]\n  );\n  const getServerSnapshot = alwaysNull;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMyPresence() {\n  const room = useRoom();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = useSyncExternalStore2(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\nfunction useUpdateMyPresence() {\n  return useRoom().updatePresence;\n}\nfunction useOthers(selector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? identity2,\n    isEqual\n  );\n}\nfunction useOthersMapped(itemSelector, itemIsEqual) {\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),\n    [itemSelector]\n  );\n  const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (a, b) => {\n      const eq = itemIsEqual ?? Object.is;\n      return a.length === b.length && a.every((atuple, index) => {\n        const btuple = b[index];\n        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n      });\n    },\n    [itemIsEqual]\n  );\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\nfunction useOthersConnectionIds() {\n  return useOthers(selectorFor_useOthersConnectionIds, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n}\nvar NOT_FOUND = Symbol();\nfunction useOther(connectionId, selector, isEqual) {\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (others) => {\n      const other2 = others.find((other3) => other3.connectionId === connectionId);\n      return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n  const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (prev, curr) => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n  return other;\n}\nfunction useMutableStorageRoot() {\n  const room = useRoom();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageRoot() {\n  return [useMutableStorageRoot()];\n}\nfunction useStorage(selector, isEqual) {\n  const room = useRoom();\n  const rootOrNull = useMutableStorageRoot();\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,\n    [selector]\n  );\n  const subscribe = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop3,\n    [room, rootOrNull]\n  );\n  const getSnapshot = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n  const getServerSnapshot = alwaysNull;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMutation(callback, deps) {\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => {\n      return (...args) => (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(\n          () => (\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              ...args\n            )\n          )\n        )\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\nfunction useThreads(options = {\n  query: { metadata: {} }\n}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateThreadsPollerForRoomId(room.id);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      void store.waitUntilRoomThreadsLoaded(room.id, options.query);\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getRoomThreadsLoadingState(room.id, options.query),\n    [store, room.id, options.query]\n  );\n  const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    getter,\n    getter,\n    identity2,\n    shallow2\n    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, state);\n  return state;\n}\nfunction useCommentsErrorListener(callback) {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  const { commentsErrorEventSource } = getRoomExtrasForClient(client);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return commentsErrorEventSource.subscribe(savedCallback.current);\n  }, [savedCallback, commentsErrorEventSource]);\n}\nfunction useCreateThread() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (options) => {\n      const body = options.body;\n      const metadata = options.metadata ?? {};\n      const attachments = options.attachments;\n      const threadId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createThreadId)();\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const newComment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(room),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const newThread = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId: room.id,\n        metadata,\n        comments: [newComment],\n        resolved: false\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"create-thread\",\n        thread: newThread,\n        roomId: room.id\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      room.createThread({ threadId, commentId, body, metadata, attachmentIds }).then(\n        (thread) => {\n          store.createThread(optimisticUpdateId, thread);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateThreadError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body,\n            metadata\n          })\n        )\n      );\n      return newThread;\n    },\n    [client, room]\n  );\n}\nfunction useDeleteThread() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const userId = getCurrentUserId(room);\n      const existing = store.getFullState().threadsDB.get(threadId);\n      if (existing?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"delete-thread\",\n        roomId: room.id,\n        threadId,\n        deletedAt: /* @__PURE__ */ new Date()\n      });\n      room.deleteThread(threadId).then(\n        () => {\n          store.deleteThread(threadId, optimisticUpdateId);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new DeleteThreadError(err2, { roomId: room.id, threadId })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useEditThreadMetadata() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (options) => {\n      if (!options.metadata) {\n        return;\n      }\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"edit-thread-metadata\",\n        metadata,\n        threadId,\n        updatedAt\n      });\n      room.editThreadMetadata({ threadId, metadata }).then(\n        (metadata2) => (\n          // Replace the optimistic update by the real thing\n          store.patchThread(\n            threadId,\n            optimisticUpdateId,\n            { metadata: metadata2 },\n            updatedAt\n          )\n        ),\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditThreadMetadataError(error, {\n            roomId: room.id,\n            threadId,\n            metadata\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useCreateComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, body, attachments }) => {\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const comment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(room),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"create-comment\",\n        comment\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      room.createComment({ threadId, commentId, body, attachmentIds }).then(\n        (newComment) => {\n          store.createComment(newComment, optimisticUpdateId);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateCommentError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n      return comment;\n    },\n    [client, room]\n  );\n}\nfunction useEditComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, body, attachments }) => {\n      const editedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const existing = store.getFullState().threadsDB.getEvenIfDeleted(threadId);\n      if (existing === void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n      const comment = existing.comments.find(\n        (comment2) => comment2.id === commentId\n      );\n      if (comment === void 0 || comment.deletedAt !== void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body,\n          attachments: attachments ?? []\n        }\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      room.editComment({ threadId, commentId, body, attachmentIds }).then(\n        (editedComment) => {\n          store.editComment(threadId, optimisticUpdateId, editedComment);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useDeleteComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId }) => {\n      const deletedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        roomId: room.id\n      });\n      room.deleteComment({ threadId, commentId }).then(\n        () => {\n          store.deleteComment(\n            threadId,\n            optimisticUpdateId,\n            commentId,\n            deletedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new DeleteCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useAddReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const createdAt = /* @__PURE__ */ new Date();\n      const userId = getCurrentUserId(room);\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt\n        }\n      });\n      room.addReaction({ threadId, commentId, emoji }).then(\n        (addedReaction) => {\n          store.addReaction(\n            threadId,\n            optimisticUpdateId,\n            commentId,\n            addedReaction,\n            createdAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new AddReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useRemoveReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const userId = getCurrentUserId(room);\n      const removedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt\n      });\n      room.removeReaction({ threadId, commentId, emoji }).then(\n        () => {\n          store.removeReaction(\n            threadId,\n            optimisticUpdateId,\n            commentId,\n            emoji,\n            userId,\n            removedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new RemoveReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsRead() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const inboxNotification = Object.values(\n        store.getFullState().notificationsById\n      ).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      if (!inboxNotification) return;\n      const now = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId: inboxNotification.id,\n        readAt: now\n      });\n      room.markInboxNotificationAsRead(inboxNotification.id).then(\n        () => {\n          store.updateInboxNotification(\n            inboxNotification.id,\n            optimisticUpdateId,\n            (inboxNotification2) => ({ ...inboxNotification2, readAt: now })\n          );\n        },\n        (err) => {\n          onMutationFailure(\n            err,\n            optimisticUpdateId,\n            (error) => new MarkInboxNotificationAsReadError(error, {\n              inboxNotificationId: inboxNotification.id\n            })\n          );\n          return;\n        }\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsResolved() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-thread-as-resolved\",\n        threadId,\n        updatedAt\n      });\n      room.markThreadAsResolved(threadId).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticUpdateId,\n            { resolved: true },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new MarkThreadAsResolvedError(error, {\n            roomId: room.id,\n            threadId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsUnresolved() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-thread-as-unresolved\",\n        threadId,\n        updatedAt\n      });\n      room.markThreadAsUnresolved(threadId).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticUpdateId,\n            { resolved: false },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new MarkThreadAsUnresolvedError(error, {\n            roomId: room.id,\n            threadId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useThreadSubscription(threadId) {\n  const client = useClient();\n  const { store } = getRoomExtrasForClient(client);\n  const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (state) => {\n      const notification = state.cleanedNotifications.find(\n        (inboxNotification) => inboxNotification.kind === \"thread\" && inboxNotification.threadId === threadId\n      );\n      const thread = state.threadsDB.get(threadId);\n      if (notification === void 0 || thread === void 0) {\n        return { status: \"not-subscribed\" };\n      }\n      return {\n        status: \"subscribed\",\n        unreadSince: notification.readAt\n      };\n    },\n    [threadId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.getFullState,\n    store.getFullState,\n    selector\n  );\n}\nfunction useRoomNotificationSettings() {\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateNotificationsSettingsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateNotificationsSettingsPollerForRoomId(room.id);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      void store.waitUntilRoomNotificationSettingsLoaded(room.id);\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getNotificationSettingsLoadingState(room.id),\n    [store, room.id]\n  );\n  const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    getter,\n    getter,\n    identity2,\n    shallow2\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useRoomNotificationSettingsSuspense() {\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  const room = useRoom();\n  use(store.waitUntilRoomNotificationSettingsLoaded(room.id));\n  const [settings, updateRoomNotificationSettings] = useRoomNotificationSettings();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!settings.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!settings.isLoading, \"Did not expect loading\");\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useHistoryVersionData(versionId) {\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    isLoading: true\n  });\n  const room = useRoom();\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    setState({ isLoading: true });\n    const load = async () => {\n      try {\n        const response = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getTextVersion(versionId);\n        const buffer = await response.arrayBuffer();\n        const data = new Uint8Array(buffer);\n        setState({\n          isLoading: false,\n          data\n        });\n      } catch (error) {\n        setState({\n          isLoading: false,\n          error: error instanceof Error ? error : new Error(\n            \"An unknown error occurred while loading this version\"\n          )\n        });\n      }\n    };\n    void load();\n  }, [room, versionId]);\n  return state;\n}\nfunction useHistoryVersions() {\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateVersionsPollerForRoomId(room.id);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getRoomVersionsLoadingState(room.id),\n    [store, room.id]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      void store.waitUntilRoomVersionsLoaded(room.id);\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    getter,\n    getter,\n    identity2,\n    shallow2\n  );\n  return state;\n}\nfunction useHistoryVersionsSuspense() {\n  const client = useClient();\n  const room = useRoom();\n  const store = getRoomExtrasForClient(client).store;\n  use(store.waitUntilRoomVersionsLoaded(room.id));\n  const result = useHistoryVersions();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUpdateRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (settings) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"update-notification-settings\",\n        roomId: room.id,\n        settings\n      });\n      room.updateNotificationSettings(settings).then(\n        (settings2) => {\n          store.updateRoomNotificationSettings_confirmOptimisticUpdate(\n            room.id,\n            optimisticUpdateId,\n            settings2\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new UpdateNotificationSettingsError(error, {\n            roomId: room.id\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction ensureNotServerSide() {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\"\n    );\n  }\n}\nfunction useSuspendUntilPresenceReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\nfunction useSelfSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersConnectionIdsSuspense() {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\nfunction useOthersMappedSuspense(itemSelector, itemIsEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\nfunction useOtherSuspense(connectionId, selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\nfunction useSuspendUntilStorageReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\nfunction useStorageSuspense(selector, isEqual) {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual\n  );\n}\nfunction useStorageStatusSuspense(options) {\n  useSuspendUntilStorageReady();\n  return useStorageStatus(options);\n}\nfunction useThreadsSuspense(options = {\n  query: { metadata: {} }\n}) {\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getRoomExtrasForClient(client);\n  use(store.waitUntilRoomThreadsLoaded(room.id, options.query));\n  const result = useThreads(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction selectorFor_useAttachmentUrl(state) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state.data !== void 0, \"Unexpected missing attachment URL\");\n  return {\n    isLoading: false,\n    url: state.data\n  };\n}\nfunction useAttachmentUrl(attachmentId) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal];\n  const getAttachmentUrlState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => attachmentUrlsStore.getState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    void attachmentUrlsStore.get(attachmentId);\n  }, [attachmentUrlsStore, attachmentId]);\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState,\n    selectorFor_useAttachmentUrl,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n}\nfunction useAttachmentUrlSuspense(attachmentId) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal];\n  const getAttachmentUrlState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => attachmentUrlsStore.getState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  const attachmentUrlState = getAttachmentUrlState();\n  if (!attachmentUrlState || attachmentUrlState.isLoading) {\n    throw attachmentUrlsStore.get(attachmentId);\n  }\n  if (attachmentUrlState.error) {\n    throw attachmentUrlState.error;\n  }\n  const state = useSyncExternalStore2(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    url: state.data,\n    error: void 0\n  };\n}\nfunction createRoomContext(client) {\n  return getOrCreateRoomContextBundle(client);\n}\nvar _RoomProvider = RoomProvider;\nvar _useBroadcastEvent = useBroadcastEvent;\nvar _useOthersListener = useOthersListener;\nvar _useRoom = useRoom;\nvar _useIsInsideRoom = useIsInsideRoom;\nvar _useAddReaction = useAddReaction;\nvar _useMutation = useMutation;\nvar _useCreateThread = useCreateThread;\nvar _useDeleteThread = useDeleteThread;\nvar _useEditThreadMetadata = useEditThreadMetadata;\nvar _useEventListener = useEventListener;\nvar _useMyPresence = useMyPresence;\nvar _useOthersMapped = useOthersMapped;\nvar _useOthersMappedSuspense = useOthersMappedSuspense;\nvar _useThreads = useThreads;\nvar _useThreadsSuspense = useThreadsSuspense;\nvar _useRoomNotificationSettings = useRoomNotificationSettings;\nvar _useRoomNotificationSettingsSuspense = useRoomNotificationSettingsSuspense;\nvar _useHistoryVersions = useHistoryVersions;\nvar _useHistoryVersionsSuspense = useHistoryVersionsSuspense;\nvar _useOther = useOther;\nfunction _useOthers(...args) {\n  return useOthers(...args);\n}\nvar _useOtherSuspense = useOtherSuspense;\nfunction _useOthersSuspense(...args) {\n  return useOthersSuspense(...args);\n}\nvar _useStorage = useStorage;\nvar _useStorageSuspense = useStorageSuspense;\nfunction _useSelf(...args) {\n  return useSelf(...args);\n}\nfunction _useSelfSuspense(...args) {\n  return useSelfSuspense(...args);\n}\nvar _useStorageRoot = useStorageRoot;\nvar _useUpdateMyPresence = useUpdateMyPresence;\n\n\n//# sourceMappingURL=chunk-A7GJNN4L.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1BN0dKTk40TC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMrQjtBQUMvQixrQkFBa0IsZ0RBQW1CO0FBQ3JDO0FBQ0EsU0FBUyw2Q0FBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQVEwQjtBQU9YO0FBQzhEO0FBQ29COztBQUVqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEQ7QUFDMUQ7QUFDQSxPQUFPLCtEQUFhLFFBQVEsK0RBQWE7QUFDekMsV0FBVyx5REFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQseURBQU87QUFDcEU7QUFDQTs7QUFFQTtBQUNnRDs7QUFFaEQ7QUFDMEM7QUFDMUM7QUFDQSxjQUFjLDZDQUFNO0FBQ3BCLEVBQUUsZ0RBQVM7QUFDWDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaURBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQVc7QUFDdEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBYTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFD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b3RlLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0L2Rpc3QvY2h1bmstQTdHSk5ONEwubWpzP2I1OGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbnRleHRzLnRzXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbnZhciBSb29tQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiB1c2VSb29tT3JOdWxsKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb29tQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VJc0luc2lkZVJvb20oKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tT3JOdWxsKCk7XG4gIHJldHVybiByb29tICE9PSBudWxsO1xufVxuXG4vLyBzcmMvbGl2ZWJsb2Nrcy50c3hcbmltcG9ydCB7XG4gIGFzc2VydCxcbiAgY3JlYXRlQ2xpZW50LFxuICBrSW50ZXJuYWwgYXMga0ludGVybmFsMixcbiAgbWFrZVBvbGxlcixcbiAgcmFpc2UsXG4gIHNoYWxsb3cgYXMgc2hhbGxvdzNcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCBSZWFjdDIsIHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MixcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2syLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MixcbiAgdXNlTWVtb1xufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanNcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qc1wiO1xuXG4vLyBzcmMvY29uZmlnLnRzXG52YXIgU0VDT05EUyA9IDFlMztcbnZhciBNSU5VVEVTID0gNjAgKiBTRUNPTkRTO1xudmFyIGNvbmZpZyA9IHtcbiAgTk9USUZJQ0FUSU9OU19QT0xMX0lOVEVSVkFMOiAxICogTUlOVVRFUyxcbiAgTk9USUZJQ0FUSU9OU19NQVhfU1RBTEVfVElNRTogNSAqIFNFQ09ORFMsXG4gIFJPT01fVEhSRUFEU19QT0xMX0lOVEVSVkFMOiA1ICogTUlOVVRFUyxcbiAgUk9PTV9USFJFQURTX01BWF9TVEFMRV9USU1FOiA1ICogU0VDT05EUyxcbiAgVVNFUl9USFJFQURTX1BPTExfSU5URVJWQUw6IDEgKiBNSU5VVEVTLFxuICBVU0VSX1RIUkVBRFNfTUFYX1NUQUxFX1RJTUU6IDUgKiBTRUNPTkRTLFxuICBISVNUT1JZX1ZFUlNJT05TX1BPTExfSU5URVJWQUw6IDEgKiBNSU5VVEVTLFxuICBISVNUT1JZX1ZFUlNJT05TX01BWF9TVEFMRV9USU1FOiA1ICogU0VDT05EUyxcbiAgTk9USUZJQ0FUSU9OX1NFVFRJTkdTX1BPTExfSU5URVJWQUw6IDEgKiBNSU5VVEVTLFxuICBOT1RJRklDQVRJT05fU0VUVElOR1NfTUFYX1NUQUxFX1RJTUU6IDUgKiBTRUNPTkRTXG59O1xuXG4vLyBzcmMvbGliL3NoYWxsb3cyLnRzXG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0LCBzaGFsbG93IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmZ1bmN0aW9uIHNoYWxsb3cyKGEsIGIpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGEpIHx8ICFpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgcmV0dXJuIHNoYWxsb3coYSwgYik7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXlzQS5ldmVyeShcbiAgICAoa2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSAmJiBzaGFsbG93KGFba2V5XSwgYltrZXldKVxuICApO1xufVxuXG4vLyBzcmMvbGliL3VzZS1pbml0aWFsLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVkdWNlciB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvbGliL3VzZS1sYXRlc3QudHNcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VMYXRlc3QodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLy8gc3JjL2xpYi91c2UtaW5pdGlhbC50c1xudmFyIG5vb3AgPSAoc3RhdGUpID0+IHN0YXRlO1xuZnVuY3Rpb24gdXNlSW5pdGlhbCh2YWx1ZSkge1xuICByZXR1cm4gdXNlUmVkdWNlcihub29wLCB2YWx1ZSlbMF07XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24obGF0ZXN0VmFsdWUpIHtcbiAgY29uc3QgZnJvemVuVmFsdWUgPSB1c2VJbml0aWFsKGxhdGVzdFZhbHVlKTtcbiAgaWYgKHR5cGVvZiBmcm96ZW5WYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgcmVmID0gdXNlTGF0ZXN0KGxhdGVzdFZhbHVlKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKC4uLmFyZ3MpID0+IHJlZi5jdXJyZW50KC4uLmFyZ3MpLCBbXG4gICAgICByZWZcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvemVuVmFsdWU7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi91c2UtcG9seWZpbGwudHNcbnZhciB1c2UgPSAoXG4gIC8vIFJlYWN0LnVzZSB8fFxuICAocHJvbWlzZSkgPT4ge1xuICAgIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHRocm93IHByb21pc2U7XG4gICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgIHByb21pc2UudGhlbihcbiAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHY7XG4gICAgICAgIH0sXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgICB9XG4gIH1cbik7XG5cbi8vIHNyYy91bWJyZWxsYS1zdG9yZS50c1xuaW1wb3J0IHtcbiAgYXV0b1JldHJ5LFxuICBjb21wYWN0T2JqZWN0LFxuICBjb25zb2xlIGFzIGNvbnNvbGUyLFxuICBjcmVhdGVTdG9yZSxcbiAgSHR0cEVycm9yLFxuICBrSW50ZXJuYWwsXG4gIG1ha2VFdmVudFNvdXJjZSxcbiAgbWFwVmFsdWVzLFxuICBuYW5vaWQsXG4gIG5uLFxuICBzdHJpbmdpZnlcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL2xpYi9hdXRvYmluZC50c1xuZnVuY3Rpb24gYXV0b2JpbmQoc2VsZikge1xuICBjb25zdCBzZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgc2Vlbi5hZGQoXCJjb25zdHJ1Y3RvclwiKTtcbiAgbGV0IG9iaiA9IHNlbGYuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICBkbyB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKG9iaikpIHtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3I/LnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgc2VsZltrZXldID0gc2VsZltrZXldLmJpbmQoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgob2JqID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihvYmopKSAmJiBvYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xufVxuXG4vLyBzcmMvVGhyZWFkREIudHNcbmltcG9ydCB7IFNvcnRlZExpc3QgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuXG4vLyBzcmMvbGliL2d1YXJkcy50c1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCBhcyBpc1BsYWluT2JqZWN0MiB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBpc1N0YXJ0c1dpdGgoYmxvYikge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdDIoYmxvYikgJiYgaXNTdHJpbmcoYmxvYi5zdGFydHNXaXRoKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIHNyYy9saWIvcXVlcnlpbmcudHNcbmZ1bmN0aW9uIG1ha2VUaHJlYWRzRmlsdGVyKHF1ZXJ5KSB7XG4gIHJldHVybiAodGhyZWFkKSA9PiBtYXRjaGVzUXVlcnkodGhyZWFkLCBxdWVyeSkgJiYgbWF0Y2hlc01ldGFkYXRhKHRocmVhZCwgcXVlcnkpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc1F1ZXJ5KHRocmVhZCwgcSkge1xuICByZXR1cm4gcS5yZXNvbHZlZCA9PT0gdm9pZCAwIHx8IHRocmVhZC5yZXNvbHZlZCA9PT0gcS5yZXNvbHZlZDtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNNZXRhZGF0YSh0aHJlYWQsIHEpIHtcbiAgY29uc3QgbWV0YWRhdGEgPSB0aHJlYWQubWV0YWRhdGE7XG4gIHJldHVybiBxLm1ldGFkYXRhID09PSB2b2lkIDAgfHwgT2JqZWN0LmVudHJpZXMocS5tZXRhZGF0YSkuZXZlcnkoXG4gICAgKFtrZXksIG9wXSkgPT4gKFxuICAgICAgLy8gTk9URTogYG9wYCBjYW4gYmUgZXhwbGljaXRseS1gdW5kZWZpbmVkYCBoZXJlLCB3aGljaCBpZGVhbGx5IHdvdWxkIG5vdFxuICAgICAgLy8gbWVhbiBcImZpbHRlciBmb3IgYWJzZW5jZVwiIGxpa2UgaXQgZG9lcyBub3csIGFzIHRoaXMgZG9lcyBub3QgbWF0Y2ggdGhlXG4gICAgICAvLyBiYWNrZW5kIGJlaGF2aW9yIGF0IHRoZSBtb21lbnQuIEZvciBhbiBpbi1kZXB0aCBkaXNjdXNzaW9uLCBzZWVcbiAgICAgIC8vIGh0dHBzOi8vbGl2ZWJsb2Nrcy5zbGFjay5jb20vYXJjaGl2ZXMvQzAyUFpMN1FBQVcvcDE3Mjg1NDY5ODg1MDU5ODlcbiAgICAgIG1hdGNoZXNPcGVyYXRvcihtZXRhZGF0YVtrZXldLCBvcClcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBtYXRjaGVzT3BlcmF0b3IodmFsdWUsIG9wKSB7XG4gIGlmIChpc1N0YXJ0c1dpdGgob3ApKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdGFydHNXaXRoKG9wLnN0YXJ0c1dpdGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3A7XG4gIH1cbn1cblxuLy8gc3JjL1RocmVhZERCLnRzXG5mdW5jdGlvbiBzYW5pdGl6ZVRocmVhZCh0aHJlYWQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQpIHtcbiAgICBpZiAodGhyZWFkLmNvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7IC4uLnRocmVhZCwgY29tbWVudHM6IFtdIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhc0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuc29tZSgoYykgPT4gIWMuZGVsZXRlZEF0KTtcbiAgaWYgKCFoYXNDb21tZW50KSB7XG4gICAgcmV0dXJuIHsgLi4udGhyZWFkLCBkZWxldGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBjb21tZW50czogW10gfTtcbiAgfVxuICByZXR1cm4gdGhyZWFkO1xufVxudmFyIFRocmVhZERCID0gY2xhc3MgX1RocmVhZERCIHtcbiAgLy8gVGhlIHZlcnNpb24gaXMgYXV0by1pbmNyZW1lbnRlZCBvbiBldmVyeSBtdXRhdGlvbiBhbmQgY2FuIGJlIHVzZWQgYXMgYSByZWxpYWJsZSBpbmRpY2F0b3IgdG8gdGVsbCBpZiB0aGUgY29udGVudHMgb2YgdGhlIHRocmVhZCBwb29sIGhhcyBjaGFuZ2VkXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2FzYyA9IFNvcnRlZExpc3QuZnJvbShbXSwgKHQxLCB0MikgPT4ge1xuICAgICAgY29uc3QgZDEgPSB0MS5jcmVhdGVkQXQ7XG4gICAgICBjb25zdCBkMiA9IHQyLmNyZWF0ZWRBdDtcbiAgICAgIHJldHVybiBkMSA8IGQyID8gdHJ1ZSA6IGQxID09PSBkMiA/IHQxLmlkIDwgdDIuaWQgOiBmYWxzZTtcbiAgICB9KTtcbiAgICB0aGlzLl9kZXNjID0gU29ydGVkTGlzdC5mcm9tKFtdLCAodDEsIHQyKSA9PiB7XG4gICAgICBjb25zdCBkMiA9IHQyLnVwZGF0ZWRBdDtcbiAgICAgIGNvbnN0IGQxID0gdDEudXBkYXRlZEF0O1xuICAgICAgcmV0dXJuIGQyIDwgZDEgPyB0cnVlIDogZDIgPT09IGQxID8gdDIuaWQgPCB0MS5pZCA6IGZhbHNlO1xuICAgIH0pO1xuICAgIHRoaXMuX2J5SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3ZlcnNpb24gPSAwO1xuICB9XG4gIC8vXG4gIC8vIFB1YmxpYyBBUElzXG4gIC8vXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG5ld1Bvb2wgPSBuZXcgX1RocmVhZERCKCk7XG4gICAgbmV3UG9vbC5fYnlJZCA9IG5ldyBNYXAodGhpcy5fYnlJZCk7XG4gICAgbmV3UG9vbC5fYXNjID0gdGhpcy5fYXNjLmNsb25lKCk7XG4gICAgbmV3UG9vbC5fZGVzYyA9IHRoaXMuX2Rlc2MuY2xvbmUoKTtcbiAgICBuZXdQb29sLl92ZXJzaW9uID0gdGhpcy5fdmVyc2lvbjtcbiAgICByZXR1cm4gbmV3UG9vbDtcbiAgfVxuICAvKiogR2V0cyB0aGUgdHJhbnNhY3Rpb24gY291bnQgZm9yIHRoaXMgREIuIEluY3JlbWVudHMgYW55IHRpbWUgdGhlIERCIGlzIG1vZGlmaWVkLiAqL1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgfVxuICAvKiogUmV0dXJucyBhbiBleGlzdGluZyB0aHJlYWQgYnkgSUQuIFdpbGwgbmV2ZXIgcmV0dXJuIGEgZGVsZXRlZCB0aHJlYWQuICovXG4gIGdldCh0aHJlYWRJZCkge1xuICAgIGNvbnN0IHRocmVhZCA9IHRoaXMuZ2V0RXZlbklmRGVsZXRlZCh0aHJlYWRJZCk7XG4gICAgcmV0dXJuIHRocmVhZD8uZGVsZXRlZEF0ID8gdm9pZCAwIDogdGhyZWFkO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSAocG9zc2libHkgZGVsZXRlZCkgdGhyZWFkIGJ5IElELiAqL1xuICBnZXRFdmVuSWZEZWxldGVkKHRocmVhZElkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J5SWQuZ2V0KHRocmVhZElkKTtcbiAgfVxuICAvKiogQWRkcyBvciB1cGRhdGVzIGEgdGhyZWFkIGluIHRoZSBEQi4gSWYgdGhlIG5ld2x5IGdpdmVuIHRocmVhZCBpcyBhIGRlbGV0ZWQgb25lLCBpdCB3aWxsIGdldCBkZWxldGVkLiAqL1xuICB1cHNlcnQodGhyZWFkKSB7XG4gICAgdGhyZWFkID0gc2FuaXRpemVUaHJlYWQodGhyZWFkKTtcbiAgICBjb25zdCBpZCA9IHRocmVhZC5pZDtcbiAgICBjb25zdCB0b1JlbW92ZSA9IHRoaXMuX2J5SWQuZ2V0KGlkKTtcbiAgICBpZiAodG9SZW1vdmUpIHtcbiAgICAgIGlmICh0b1JlbW92ZS5kZWxldGVkQXQpIHJldHVybjtcbiAgICAgIHRoaXMuX2FzYy5yZW1vdmUodG9SZW1vdmUpO1xuICAgICAgdGhpcy5fZGVzYy5yZW1vdmUodG9SZW1vdmUpO1xuICAgIH1cbiAgICBpZiAoIXRocmVhZC5kZWxldGVkQXQpIHtcbiAgICAgIHRoaXMuX2FzYy5hZGQodGhyZWFkKTtcbiAgICAgIHRoaXMuX2Rlc2MuYWRkKHRocmVhZCk7XG4gICAgfVxuICAgIHRoaXMuX2J5SWQuc2V0KGlkLCB0aHJlYWQpO1xuICAgIHRoaXMudG91Y2goKTtcbiAgfVxuICAvKiogTGlrZSAudXBzZXJ0KCksIGV4Y2VwdCBpdCB3b24ndCB1cGRhdGUgaWYgYSB0aHJlYWQgYnkgdGhpcyBJRCBhbHJlYWR5IGV4aXN0cy4gKi9cbiAgLy8gVE9ETyBDb25zaWRlciByZW5hbWluZyB0aGlzIHRvIGp1c3QgLnVwc2VydCgpLiBJJ20gbm90IHN1cmUgaWYgd2UgcmVhbGx5XG4gIC8vIFRPRE8gbmVlZCB0aGUgcmF3IC51cHNlcnQoKS4gV291bGQgYmUgbmljZSBpZiB0aGlzIGJlaGF2aW9yIHdhcyB0aGUgZGVmYXVsdC5cbiAgdXBzZXJ0SWZOZXdlcih0aHJlYWQpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZ2V0KHRocmVhZC5pZCk7XG4gICAgaWYgKCFleGlzdGluZyB8fCB0aHJlYWQudXBkYXRlZEF0ID49IGV4aXN0aW5nLnVwZGF0ZWRBdCkge1xuICAgICAgdGhpcy51cHNlcnQodGhyZWFkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIGEgdGhyZWFkIGFzIGRlbGV0ZWQuIEl0IHdpbGwgbm8gbG9uZ2VyIHBvcCB1cCBpbiAuZmluZE1hbnkoKVxuICAgKiBxdWVyaWVzLCBidXQgaXQgY2FuIHN0aWxsIGJlIGFjY2Vzc2VkIHZpYSBgLmdldEV2ZW5JZkRlbGV0ZWQoKWAuXG4gICAqL1xuICBkZWxldGUodGhyZWFkSWQsIGRlbGV0ZWRBdCkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fYnlJZC5nZXQodGhyZWFkSWQpO1xuICAgIGlmIChleGlzdGluZyAmJiAhZXhpc3RpbmcuZGVsZXRlZEF0KSB7XG4gICAgICB0aGlzLnVwc2VydCh7IC4uLmV4aXN0aW5nLCBkZWxldGVkQXQsIHVwZGF0ZWRBdDogZGVsZXRlZEF0IH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhyZWFkcyBtYXRjaGluZyBhIGdpdmVuIHJvb21JZCBhbmQgcXVlcnkuIElmIHJvb21JZCBpcyBub3RcbiAgICogc3BlY2lmaWVkLCBpdCB3aWxsIHJldHVybiBhbGwgdGhyZWFkcyBtYXRjaGluZyB0aGUgcXVlcnksIGFjcm9zcyBhbGxcbiAgICogcm9vbXMuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHJlc3VsdHMgaW4gdGhlIHJlcXVlc3RlZCBvcmRlci4gUGxlYXNlIG5vdGU6XG4gICAqICAgJ2FzYycgIG1lYW5zIGJ5IGNyZWF0ZWRBdCBBU0NcbiAgICogICAnZGVzYycgbWVhbnMgYnkgdXBkYXRlZEF0IERFU0NcbiAgICpcbiAgICogV2lsbCBuZXZlciByZXR1cm4gZGVsZXRlZCB0aHJlYWRzIGluIHRoZSByZXN1bHQuXG4gICAqL1xuICBmaW5kTWFueShyb29tSWQsIHF1ZXJ5LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBpbmRleCA9IGRpcmVjdGlvbiA9PT0gXCJkZXNjXCIgPyB0aGlzLl9kZXNjIDogdGhpcy5fYXNjO1xuICAgIGNvbnN0IGNyaXQgPSBbXTtcbiAgICBpZiAocm9vbUlkICE9PSB2b2lkIDApIHtcbiAgICAgIGNyaXQucHVzaCgodCkgPT4gdC5yb29tSWQgPT09IHJvb21JZCk7XG4gICAgfVxuICAgIGNyaXQucHVzaChtYWtlVGhyZWFkc0ZpbHRlcihxdWVyeSkpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGluZGV4LmZpbHRlcigodCkgPT4gY3JpdC5ldmVyeSgocHJlZCkgPT4gcHJlZCh0KSkpKTtcbiAgfVxuICAvL1xuICAvLyBQcml2YXRlIEFQSXNcbiAgLy9cbiAgdG91Y2goKSB7XG4gICAgKyt0aGlzLl92ZXJzaW9uO1xuICB9XG59O1xuXG4vLyBzcmMvdW1icmVsbGEtc3RvcmUudHNcbmZ1bmN0aW9uIG1ha2VSb29tVGhyZWFkc1F1ZXJ5S2V5KHJvb21JZCwgcXVlcnkpIHtcbiAgcmV0dXJuIGAke3Jvb21JZH0tJHtzdHJpbmdpZnkocXVlcnkgPz8ge30pfWA7XG59XG5mdW5jdGlvbiBtYWtlVXNlclRocmVhZHNRdWVyeUtleShxdWVyeSkge1xuICByZXR1cm4gYFVTRVJfVEhSRUFEUzoke3N0cmluZ2lmeShxdWVyeSA/PyB7fSl9YDtcbn1cbmZ1bmN0aW9uIG1ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb21JZCkge1xuICByZXR1cm4gYCR7cm9vbUlkfTpOT1RJRklDQVRJT05fU0VUVElOR1NgO1xufVxuZnVuY3Rpb24gbWFrZVZlcnNpb25zUXVlcnlLZXkocm9vbUlkKSB7XG4gIHJldHVybiBgJHtyb29tSWR9LVZFUlNJT05TYDtcbn1cbmZ1bmN0aW9uIHVzaWZ5KHByb21pc2UpIHtcbiAgaWYgKFwic3RhdHVzXCIgaW4gcHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGNvbnN0IHVzYWJsZSA9IHByb21pc2U7XG4gIHVzYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgdXNhYmxlLnRoZW4oXG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICB1c2FibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIHVzYWJsZS52YWx1ZSA9IHZhbHVlO1xuICAgIH0sXG4gICAgKGVycikgPT4ge1xuICAgICAgdXNhYmxlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgIHVzYWJsZS5yZWFzb24gPSBlcnI7XG4gICAgfVxuICApO1xuICByZXR1cm4gdXNhYmxlO1xufVxudmFyIG5vb3AyID0gUHJvbWlzZS5yZXNvbHZlKCk7XG52YXIgQVNZTkNfTE9BRElORyA9IE9iamVjdC5mcmVlemUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG52YXIgUGFnaW5hdGVkUmVzb3VyY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZldGNoUGFnZSkge1xuICAgIHRoaXMuX2NhY2hlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3BhZ2luYXRpb25TdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5fZmV0Y2hQYWdlID0gZmV0Y2hQYWdlO1xuICAgIHRoaXMuX2V2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gICAgdGhpcy5fcGVuZGluZ0ZldGNoTW9yZSA9IG51bGw7XG4gICAgdGhpcy5vYnNlcnZhYmxlID0gdGhpcy5fZXZlbnRTb3VyY2Uub2JzZXJ2YWJsZTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuICBwYXRjaFBhZ2luYXRpb25TdGF0ZShwYXRjaCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fcGFnaW5hdGlvblN0YXRlO1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHRoaXMuX3BhZ2luYXRpb25TdGF0ZSA9IHsgLi4uc3RhdGUsIC4uLnBhdGNoIH07XG4gICAgdGhpcy5fZXZlbnRTb3VyY2Uubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoTW9yZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3BhZ2luYXRpb25TdGF0ZTtcbiAgICBpZiAoIXN0YXRlPy5jdXJzb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXRjaFBhZ2luYXRpb25TdGF0ZSh7IGlzRmV0Y2hpbmdNb3JlOiB0cnVlIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXh0Q3Vyc29yID0gYXdhaXQgdGhpcy5fZmV0Y2hQYWdlKHN0YXRlLmN1cnNvcik7XG4gICAgICB0aGlzLnBhdGNoUGFnaW5hdGlvblN0YXRlKHtcbiAgICAgICAgY3Vyc29yOiBuZXh0Q3Vyc29yLFxuICAgICAgICBmZXRjaE1vcmVFcnJvcjogdm9pZCAwLFxuICAgICAgICBpc0ZldGNoaW5nTW9yZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5wYXRjaFBhZ2luYXRpb25TdGF0ZSh7XG4gICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBmYWxzZSxcbiAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IGVyclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZldGNoTW9yZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3BhZ2luYXRpb25TdGF0ZTtcbiAgICBpZiAoc3RhdGU/LmN1cnNvciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vb3AyO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdGZXRjaE1vcmUpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdGZXRjaE1vcmUgPSB0aGlzLl9mZXRjaE1vcmUoKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0ZldGNoTW9yZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdGZXRjaE1vcmU7XG4gIH1cbiAgZ2V0KCkge1xuICAgIGNvbnN0IHVzYWJsZSA9IHRoaXMuX2NhY2hlZFByb21pc2U7XG4gICAgaWYgKHVzYWJsZSA9PT0gbnVsbCB8fCB1c2FibGUuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgcmV0dXJuIEFTWU5DX0xPQURJTkc7XG4gICAgfVxuICAgIGlmICh1c2FibGUuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgIHJldHVybiB7IGlzTG9hZGluZzogZmFsc2UsIGVycm9yOiB1c2FibGUucmVhc29uIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fcGFnaW5hdGlvblN0YXRlO1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZGF0YToge1xuICAgICAgICBmZXRjaE1vcmU6IHRoaXMuZmV0Y2hNb3JlLFxuICAgICAgICBpc0ZldGNoaW5nTW9yZTogc3RhdGUuaXNGZXRjaGluZ01vcmUsXG4gICAgICAgIGZldGNoTW9yZUVycm9yOiBzdGF0ZS5mZXRjaE1vcmVFcnJvcixcbiAgICAgICAgaGFzRmV0Y2hlZEFsbDogc3RhdGUuY3Vyc29yID09PSBudWxsXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB3YWl0VW50aWxMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsRmV0Y2hlciA9IGF1dG9SZXRyeShcbiAgICAgICgpID0+IHRoaXMuX2ZldGNoUGFnZShcbiAgICAgICAgLyogY3Vyc29yICovXG4gICAgICAgIHZvaWQgMFxuICAgICAgKSxcbiAgICAgIDUsXG4gICAgICBbNWUzLCA1ZTMsIDFlNCwgMTVlM11cbiAgICApO1xuICAgIGNvbnN0IHByb21pc2UgPSB1c2lmeShcbiAgICAgIGluaXRpYWxGZXRjaGVyLnRoZW4oKGN1cnNvcikgPT4ge1xuICAgICAgICB0aGlzLl9wYWdpbmF0aW9uU3RhdGUgPSB7XG4gICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBmYWxzZSxcbiAgICAgICAgICBmZXRjaE1vcmVFcnJvcjogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICk7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKCkgPT4gdGhpcy5fZXZlbnRTb3VyY2Uubm90aWZ5KCksXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2V2ZW50U291cmNlLm5vdGlmeSgpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9jYWNoZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9ldmVudFNvdXJjZS5ub3RpZnkoKTtcbiAgICAgICAgfSwgNWUzKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuX2NhY2hlZFByb21pc2UgPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59O1xudmFyIFNpbmdsZVBhZ2VSZXNvdXJjZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZmV0Y2hQYWdlKSB7XG4gICAgdGhpcy5fY2FjaGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fZmV0Y2hQYWdlID0gZmV0Y2hQYWdlO1xuICAgIHRoaXMuX2V2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gICAgdGhpcy5vYnNlcnZhYmxlID0gdGhpcy5fZXZlbnRTb3VyY2Uub2JzZXJ2YWJsZTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgdXNhYmxlID0gdGhpcy5fY2FjaGVkUHJvbWlzZTtcbiAgICBpZiAodXNhYmxlID09PSBudWxsIHx8IHVzYWJsZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICByZXR1cm4gQVNZTkNfTE9BRElORztcbiAgICB9XG4gICAgaWYgKHVzYWJsZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgcmV0dXJuIHsgaXNMb2FkaW5nOiBmYWxzZSwgZXJyb3I6IHVzYWJsZS5yZWFzb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBkYXRhOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIHdhaXRVbnRpbExvYWRlZCgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWxGZXRjaGVyID0gYXV0b1JldHJ5KFxuICAgICAgKCkgPT4gdGhpcy5fZmV0Y2hQYWdlKCksXG4gICAgICA1LFxuICAgICAgWzVlMywgNWUzLCAxZTQsIDE1ZTNdXG4gICAgKTtcbiAgICBjb25zdCBwcm9taXNlID0gdXNpZnkoaW5pdGlhbEZldGNoZXIpO1xuICAgIHByb21pc2UudGhlbihcbiAgICAgICgpID0+IHRoaXMuX2V2ZW50U291cmNlLm5vdGlmeSgpLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLl9ldmVudFNvdXJjZS5ub3RpZnkoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fZXZlbnRTb3VyY2Uubm90aWZ5KCk7XG4gICAgICAgIH0sIDVlMyk7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLl9jYWNoZWRQcm9taXNlID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcbnZhciBVbWJyZWxsYVN0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLl9wcmV2VmVyc2lvbiA9IC0xO1xuICAgIHRoaXMuX3ByZXZTdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGVDYWNoZWQgPSBudWxsO1xuICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICB0aGlzLl9ub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID0gbnVsbDtcbiAgICAvLyBSb29tIFRocmVhZHNcbiAgICB0aGlzLl9yb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcm9vbVRocmVhZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8vIFVzZXIgVGhyZWFkc1xuICAgIHRoaXMuX3VzZXJUaHJlYWRzTGFzdFJlcXVlc3RlZEF0ID0gbnVsbDtcbiAgICB0aGlzLl91c2VyVGhyZWFkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgLy8gUm9vbSB2ZXJzaW9uc1xuICAgIHRoaXMuX3Jvb21WZXJzaW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcm9vbVZlcnNpb25zTGFzdFJlcXVlc3RlZEF0QnlSb29tID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAvLyBSb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5nc1xuICAgIHRoaXMuX3Jvb21Ob3RpZmljYXRpb25TZXR0aW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50W2tJbnRlcm5hbF0uYXMoKTtcbiAgICBjb25zdCBpbmJveEZldGNoZXIgPSBhc3luYyAoY3Vyc29yKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9jbGllbnQuZ2V0SW5ib3hOb3RpZmljYXRpb25zKHsgY3Vyc29yIH0pO1xuICAgICAgdGhpcy51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgICAgcmVzdWx0LnRocmVhZHMsXG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5fbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0LnJlcXVlc3RlZEF0O1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dEN1cnNvciA9IHJlc3VsdC5uZXh0Q3Vyc29yO1xuICAgICAgcmV0dXJuIG5leHRDdXJzb3I7XG4gICAgfTtcbiAgICB0aGlzLl9ub3RpZmljYXRpb25zID0gbmV3IFBhZ2luYXRlZFJlc291cmNlKGluYm94RmV0Y2hlcik7XG4gICAgdGhpcy5fbm90aWZpY2F0aW9ucy5vYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICgpID0+IChcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzdG9yZSBpdHNlbGYgZG9lcyBub3QgY2hhbmdlLCBidXQgaXQncyBvbmx5IHZlaGljbGUgYXRcbiAgICAgICAgLy8gdGhlIG1vbWVudCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyLCBzbyB3ZSdsbCBkbyBhIG5vLW9wIHVwZGF0ZSBoZXJlLlxuICAgICAgICB0aGlzLl9zdG9yZS5zZXQoKHN0b3JlKSA9PiAoeyAuLi5zdG9yZSB9KSlcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3Jhd1RocmVhZHNEQiA9IG5ldyBUaHJlYWREQigpO1xuICAgIHRoaXMuX3N0b3JlID0gY3JlYXRlU3RvcmUoe1xuICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IFtdLFxuICAgICAgbm90aWZpY2F0aW9uc0J5SWQ6IHt9LFxuICAgICAgc2V0dGluZ3NCeVJvb21JZDoge30sXG4gICAgICB2ZXJzaW9uc0J5Um9vbUlkOiB7fVxuICAgIH0pO1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG4gIGdldCgpIHtcbiAgICBjb25zdCByYXdTdGF0ZSA9IHRoaXMuX3N0b3JlLmdldCgpO1xuICAgIGlmICh0aGlzLl9wcmV2VmVyc2lvbiAhPT0gdGhpcy5fcmF3VGhyZWFkc0RCLnZlcnNpb24gfHwgLy8gTm90ZTogVmVyc2lvbiBjaGVjayBpcyBvbmx5IG5lZWRlZCB0ZW1wb3JhcmlseSwgdW50aWwgd2UgY2FuIGdldCByaWQgb2YgdGhlIFp1c3RhbmQtbGlrZSB1cGRhdGUgbW9kZWxcbiAgICB0aGlzLl9wcmV2U3RhdGUgIT09IHJhd1N0YXRlIHx8IHRoaXMuX3N0YXRlQ2FjaGVkID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9zdGF0ZUNhY2hlZCA9IGludGVybmFsVG9FeHRlcm5hbFN0YXRlKHJhd1N0YXRlLCB0aGlzLl9yYXdUaHJlYWRzREIpO1xuICAgICAgdGhpcy5fcHJldlN0YXRlID0gcmF3U3RhdGU7XG4gICAgICB0aGlzLl9wcmV2VmVyc2lvbiA9IHRoaXMuX3Jhd1RocmVhZHNEQi52ZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhdGVDYWNoZWQ7XG4gIH1cbiAgYmF0Y2goY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuYmF0Y2goY2FsbGJhY2spO1xuICB9XG4gIGdldEZ1bGxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXN5bmMgcmVzdWx0IG9mIHRoZSBnaXZlbiBxdWVyeSBhbmQgcm9vbSBpZC4gSWYgdGhlIHF1ZXJ5IGlzIHN1Y2Nlc3MsXG4gICAqIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhlIHRocmVhZHMgdGhhdCBtYXRjaCB0aGF0IHByb3ZpZGVkIHF1ZXJ5IGFuZCByb29tIGlkLlxuICAgKlxuICAgKi9cbiAgZ2V0Um9vbVRocmVhZHNMb2FkaW5nU3RhdGUocm9vbUlkLCBxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZVJvb21UaHJlYWRzUXVlcnlLZXkocm9vbUlkLCBxdWVyeSk7XG4gICAgY29uc3QgcGFnaW5hdGVkUmVzb3VyY2UgPSB0aGlzLl9yb29tVGhyZWFkcy5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChwYWdpbmF0ZWRSZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gQVNZTkNfTE9BRElORztcbiAgICB9XG4gICAgY29uc3QgYXN5bmNSZXN1bHQgPSBwYWdpbmF0ZWRSZXNvdXJjZS5nZXQoKTtcbiAgICBpZiAoYXN5bmNSZXN1bHQuaXNMb2FkaW5nIHx8IGFzeW5jUmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gYXN5bmNSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHRocmVhZHMgPSB0aGlzLmdldEZ1bGxTdGF0ZSgpLnRocmVhZHNEQi5maW5kTWFueShcbiAgICAgIHJvb21JZCxcbiAgICAgIHF1ZXJ5ID8/IHt9LFxuICAgICAgXCJhc2NcIlxuICAgICk7XG4gICAgY29uc3QgcGFnZSA9IGFzeW5jUmVzdWx0LmRhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICB0aHJlYWRzLFxuICAgICAgaGFzRmV0Y2hlZEFsbDogcGFnZS5oYXNGZXRjaGVkQWxsLFxuICAgICAgaXNGZXRjaGluZ01vcmU6IHBhZ2UuaXNGZXRjaGluZ01vcmUsXG4gICAgICBmZXRjaE1vcmVFcnJvcjogcGFnZS5mZXRjaE1vcmVFcnJvcixcbiAgICAgIGZldGNoTW9yZTogcGFnZS5mZXRjaE1vcmVcbiAgICB9O1xuICB9XG4gIGdldFVzZXJUaHJlYWRzTG9hZGluZ1N0YXRlKHF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBtYWtlVXNlclRocmVhZHNRdWVyeUtleShxdWVyeSk7XG4gICAgY29uc3QgcGFnaW5hdGVkUmVzb3VyY2UgPSB0aGlzLl91c2VyVGhyZWFkcy5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChwYWdpbmF0ZWRSZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gQVNZTkNfTE9BRElORztcbiAgICB9XG4gICAgY29uc3QgYXN5bmNSZXN1bHQgPSBwYWdpbmF0ZWRSZXNvdXJjZS5nZXQoKTtcbiAgICBpZiAoYXN5bmNSZXN1bHQuaXNMb2FkaW5nIHx8IGFzeW5jUmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gYXN5bmNSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHRocmVhZHMgPSB0aGlzLmdldEZ1bGxTdGF0ZSgpLnRocmVhZHNEQi5maW5kTWFueShcbiAgICAgIHZvaWQgMCxcbiAgICAgIC8vIERvIF9ub3RfIGZpbHRlciBieSByb29tSWRcbiAgICAgIHF1ZXJ5ID8/IHt9LFxuICAgICAgXCJkZXNjXCJcbiAgICApO1xuICAgIGNvbnN0IHBhZ2UgPSBhc3luY1Jlc3VsdC5kYXRhO1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgdGhyZWFkcyxcbiAgICAgIGhhc0ZldGNoZWRBbGw6IHBhZ2UuaGFzRmV0Y2hlZEFsbCxcbiAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgZmV0Y2hNb3JlRXJyb3I6IHBhZ2UuZmV0Y2hNb3JlRXJyb3IsXG4gICAgICBmZXRjaE1vcmU6IHBhZ2UuZmV0Y2hNb3JlXG4gICAgfTtcbiAgfVxuICAvLyBOT1RFOiBUaGlzIHdpbGwgcmVhZCB0aGUgYXN5bmMgcmVzdWx0LCBidXQgV0lMTCBOT1Qgc3RhcnQgbG9hZGluZyBhdCB0aGUgbW9tZW50IVxuICBnZXRJbmJveE5vdGlmaWNhdGlvbnNMb2FkaW5nU3RhdGUoKSB7XG4gICAgY29uc3QgYXN5bmNSZXN1bHQgPSB0aGlzLl9ub3RpZmljYXRpb25zLmdldCgpO1xuICAgIGlmIChhc3luY1Jlc3VsdC5pc0xvYWRpbmcgfHwgYXN5bmNSZXN1bHQuZXJyb3IpIHtcbiAgICAgIHJldHVybiBhc3luY1Jlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcGFnZSA9IGFzeW5jUmVzdWx0LmRhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHRoaXMuZ2V0RnVsbFN0YXRlKCkuY2xlYW5lZE5vdGlmaWNhdGlvbnMsXG4gICAgICBoYXNGZXRjaGVkQWxsOiBwYWdlLmhhc0ZldGNoZWRBbGwsXG4gICAgICBpc0ZldGNoaW5nTW9yZTogcGFnZS5pc0ZldGNoaW5nTW9yZSxcbiAgICAgIGZldGNoTW9yZUVycm9yOiBwYWdlLmZldGNoTW9yZUVycm9yLFxuICAgICAgZmV0Y2hNb3JlOiBwYWdlLmZldGNoTW9yZVxuICAgIH07XG4gIH1cbiAgLy8gTk9URTogVGhpcyB3aWxsIHJlYWQgdGhlIGFzeW5jIHJlc3VsdCwgYnV0IFdJTEwgTk9UIHN0YXJ0IGxvYWRpbmcgYXQgdGhlIG1vbWVudCFcbiAgZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3NMb2FkaW5nU3RhdGUocm9vbUlkKSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBtYWtlTm90aWZpY2F0aW9uU2V0dGluZ3NRdWVyeUtleShyb29tSWQpO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5fcm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLmdldChxdWVyeUtleSk7XG4gICAgaWYgKHJlc291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBBU1lOQ19MT0FESU5HO1xuICAgIH1cbiAgICBjb25zdCBhc3luY1Jlc3VsdCA9IHJlc291cmNlLmdldCgpO1xuICAgIGlmIChhc3luY1Jlc3VsdC5pc0xvYWRpbmcgfHwgYXN5bmNSZXN1bHQuZXJyb3IpIHtcbiAgICAgIHJldHVybiBhc3luY1Jlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBzZXR0aW5nczogbm4odGhpcy5nZXQoKS5zZXR0aW5nc0J5Um9vbUlkW3Jvb21JZF0pXG4gICAgfTtcbiAgfVxuICBnZXRSb29tVmVyc2lvbnNMb2FkaW5nU3RhdGUocm9vbUlkKSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBtYWtlVmVyc2lvbnNRdWVyeUtleShyb29tSWQpO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5fcm9vbVZlcnNpb25zLmdldChxdWVyeUtleSk7XG4gICAgaWYgKHJlc291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBBU1lOQ19MT0FESU5HO1xuICAgIH1cbiAgICBjb25zdCBhc3luY1Jlc3VsdCA9IHJlc291cmNlLmdldCgpO1xuICAgIGlmIChhc3luY1Jlc3VsdC5pc0xvYWRpbmcgfHwgYXN5bmNSZXN1bHQuZXJyb3IpIHtcbiAgICAgIHJldHVybiBhc3luY1Jlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICB2ZXJzaW9uczogT2JqZWN0LnZhbHVlcyh0aGlzLmdldCgpLnZlcnNpb25zQnlSb29tSWRbcm9vbUlkXSA/PyB7fSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBPbmx5IHVzZWQgYnkgdGhlIEUyRSB0ZXN0IHN1aXRlLlxuICAgKi9cbiAgX2hhc09wdGltaXN0aWNVcGRhdGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXQoKS5vcHRpbWlzdGljVXBkYXRlcy5sZW5ndGggPiAwO1xuICB9XG4gIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9XG4gIC8vIERpcmVjdCBsb3ctbGV2ZWwgY2FjaGUgbXV0YXRpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0ge3t7XG4gIG11dGF0ZVRocmVhZHNEQihtdXRhdGUpIHtcbiAgICBjb25zdCBkYiA9IHRoaXMuX3Jhd1RocmVhZHNEQjtcbiAgICBjb25zdCBvbGQgPSBkYi52ZXJzaW9uO1xuICAgIG11dGF0ZShkYik7XG4gICAgaWYgKG9sZCAhPT0gZGIudmVyc2lvbikge1xuICAgICAgdGhpcy5fc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHsgLi4uc3RhdGUgfSkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVJbmJveE5vdGlmaWNhdGlvbnNDYWNoZShtYXBGbikge1xuICAgIHRoaXMuX3N0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9ucyA9IG1hcEZuKHN0YXRlLm5vdGlmaWNhdGlvbnNCeUlkKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbnMgIT09IHN0YXRlLm5vdGlmaWNhdGlvbnNCeUlkID8geyAuLi5zdGF0ZSwgbm90aWZpY2F0aW9uc0J5SWQ6IGluYm94Tm90aWZpY2F0aW9ucyB9IDogc3RhdGU7XG4gICAgfSk7XG4gIH1cbiAgc2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzZXR0aW5ncykge1xuICAgIHRoaXMuX3N0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNldHRpbmdzQnlSb29tSWQ6IHtcbiAgICAgICAgLi4uc3RhdGUuc2V0dGluZ3NCeVJvb21JZCxcbiAgICAgICAgW3Jvb21JZF06IHNldHRpbmdzXG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIHVwZGF0ZVJvb21WZXJzaW9ucyhyb29tSWQsIHZlcnNpb25zKSB7XG4gICAgdGhpcy5fc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgdmVyc2lvbnNCeUlkID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICB2ZXJzaW9ucy5tYXAoKHZlcnNpb24yKSA9PiBbdmVyc2lvbjIuaWQsIHZlcnNpb24yXSlcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdmVyc2lvbnNCeVJvb21JZDoge1xuICAgICAgICAgIC4uLnN0YXRlLnZlcnNpb25zQnlSb29tSWQsXG4gICAgICAgICAgW3Jvb21JZF06IHtcbiAgICAgICAgICAgIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgdmVyc2lvbnMgZm9yIHRoZSByb29tLCBvciBzdGFydCB3aXRoIGFuIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgLi4uc3RhdGUudmVyc2lvbnNCeVJvb21JZFtyb29tSWRdID8/IHt9LFxuICAgICAgICAgICAgLi4udmVyc2lvbnNCeUlkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZU9wdGltaXN0aWNVcGRhdGVzQ2FjaGUobWFwRm4pIHtcbiAgICB0aGlzLl9zdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBvcHRpbWlzdGljVXBkYXRlczogbWFwRm4oc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMpXG4gICAgfSkpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfX19XG4gIC8qKiBAaW50ZXJuYWwgLSBPbmx5IGNhbGwgdGhpcyBtZXRob2QgZnJvbSB1bml0IHRlc3RzLiAqL1xuICBmb3JjZV9zZXQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuc2V0KGNhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhbiBleGlzdGluZyBpbmJveCBub3RpZmljYXRpb24gd2l0aCBhIG5ldyB2YWx1ZSwgcmVwbGFjaW5nIHRoZVxuICAgKiBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IHVwZGF0ZSBhbnl0aGluZyBpZiB0aGUgaW5ib3ggbm90aWZpY2F0aW9uIElEIGlzbid0IGZvdW5kIGluXG4gICAqIHRoZSBjYWNoZS5cbiAgICovXG4gIHVwZGF0ZUluYm94Tm90aWZpY2F0aW9uKGluYm94Tm90aWZpY2F0aW9uSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9zdG9yZS5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIHRoaXMudXBkYXRlSW5ib3hOb3RpZmljYXRpb25zQ2FjaGUoKGNhY2hlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gY2FjaGVbaW5ib3hOb3RpZmljYXRpb25JZF07XG4gICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25zID0ge1xuICAgICAgICAgIC4uLmNhY2hlLFxuICAgICAgICAgIFtpbmJveE5vdGlmaWNhdGlvbklkXTogY2FsbGJhY2soZXhpc3RpbmcpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbnM7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyAqYWxsKiBpbmJveCBub3RpZmljYXRpb25zIGJ5IHJ1bm5pbmcgYSBtYXBwZXIgZnVuY3Rpb24gb3ZlciBhbGwgb2ZcbiAgICogdGhlbSwgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKG9wdGltaXN0aWNVcGRhdGVJZCwgbWFwRm4pIHtcbiAgICB0aGlzLl9zdG9yZS5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIHRoaXMudXBkYXRlSW5ib3hOb3RpZmljYXRpb25zQ2FjaGUoKGNhY2hlKSA9PiBtYXBWYWx1ZXMoY2FjaGUsIG1hcEZuKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZXhpc3RpbmcgaW5ib3ggbm90aWZpY2F0aW9uLCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICogb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkLCBvcHRpbWlzdGljVXBkYXRlSWQpIHtcbiAgICB0aGlzLl9zdG9yZS5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIHRoaXMudXBkYXRlSW5ib3hOb3RpZmljYXRpb25zQ2FjaGUoKGNhY2hlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgW2luYm94Tm90aWZpY2F0aW9uSWRdOiByZW1vdmVkLCAuLi5uZXdDYWNoZSB9ID0gY2FjaGU7XG4gICAgICAgIHJldHVybiByZW1vdmVkID09PSB2b2lkIDAgPyBjYWNoZSA6IG5ld0NhY2hlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgKmFsbCogaW5ib3ggbm90aWZpY2F0aW9ucywgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWNcbiAgICogdXBkYXRlLlxuICAgKi9cbiAgZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKG9wdGltaXN0aWNVcGRhdGVJZCkge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgdGhpcy51cGRhdGVJbmJveE5vdGlmaWNhdGlvbnNDYWNoZSgoKSA9PiAoe30pKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBuZXcgdGhyZWFkLCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICBjcmVhdGVUaHJlYWQob3B0aW1pc3RpY1VwZGF0ZUlkLCB0aHJlYWQpIHtcbiAgICB0aGlzLl9zdG9yZS5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIHRoaXMubXV0YXRlVGhyZWFkc0RCKChkYikgPT4gZGIudXBzZXJ0KHRocmVhZCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIHRocmVhZCB3aXRoIGEgbmV3IHZhbHVlLCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICogb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgdXBkYXRlIGFueXRoaW5nIGlmOlxuICAgKiAtIFRoZSB0aHJlYWQgSUQgaXNuJ3QgZm91bmQgaW4gdGhlIGNhY2hlOyBvclxuICAgKiAtIFRoZSB0aHJlYWQgSUQgd2FzIGFscmVhZHkgZGVsZXRlZCBmcm9tIHRoZSBjYWNoZTsgb3JcbiAgICogLSBUaGUgdGhyZWFkIElEIGluIHRoZSBjYWNoZSB3YXMgdXBkYXRlZCBtb3JlIHJlY2VudGx5IHRoYW4gdGhlIG9wdGltaXN0aWNcbiAgICogICB1cGRhdGUncyB0aW1lc3RhbXAgKGlmIGdpdmVuKVxuICAgKi9cbiAgdXBkYXRlVGhyZWFkKHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQsIGNhbGxiYWNrLCB1cGRhdGVkQXQpIHtcbiAgICB0aGlzLl9zdG9yZS5iYXRjaCgoKSA9PiB7XG4gICAgICBpZiAob3B0aW1pc3RpY1VwZGF0ZUlkICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5tdXRhdGVUaHJlYWRzREIoKGRiKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gZGIuZ2V0KHRocmVhZElkKTtcbiAgICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuO1xuICAgICAgICBpZiAoISF1cGRhdGVkQXQgJiYgZXhpc3RpbmcudXBkYXRlZEF0ID4gdXBkYXRlZEF0KSByZXR1cm47XG4gICAgICAgIGRiLnVwc2VydChjYWxsYmFjayhleGlzdGluZykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcGF0Y2hUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgcGF0Y2gsIHVwZGF0ZWRBdCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgKHRocmVhZCkgPT4gKHsgLi4udGhyZWFkLCAuLi5jb21wYWN0T2JqZWN0KHBhdGNoKSB9KSxcbiAgICAgIHVwZGF0ZWRBdFxuICAgICk7XG4gIH1cbiAgYWRkUmVhY3Rpb24odGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgY29tbWVudElkLCByZWFjdGlvbiwgY3JlYXRlZEF0KSB7XG4gICAgdGhpcy51cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICh0aHJlYWQpID0+IGFwcGx5QWRkUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIHJlYWN0aW9uKSxcbiAgICAgIGNyZWF0ZWRBdFxuICAgICk7XG4gIH1cbiAgcmVtb3ZlUmVhY3Rpb24odGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgY29tbWVudElkLCBlbW9qaSwgdXNlcklkLCByZW1vdmVkQXQpIHtcbiAgICB0aGlzLnVwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlSZW1vdmVSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgZW1vamksIHVzZXJJZCwgcmVtb3ZlZEF0KSxcbiAgICAgIHJlbW92ZWRBdFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNvZnQtZGVsZXRlcyBhbiBleGlzdGluZyB0aHJlYWQgYnkgc2V0dGluZyBpdHMgYGRlbGV0ZWRBdGAgdmFsdWUsXG4gICAqIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWY6XG4gICAqIC0gVGhlIHRocmVhZCBJRCBpc24ndCBmb3VuZCBpbiB0aGUgY2FjaGU7IG9yXG4gICAqIC0gVGhlIHRocmVhZCBJRCB3YXMgYWxyZWFkeSBkZWxldGVkIGZyb20gdGhlIGNhY2hlXG4gICAqL1xuICBkZWxldGVUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgLy8gQSBkZWxldGlvbiBpcyBhY3R1YWxseSBhbiB1cGRhdGUgb2YgdGhlIGRlbGV0ZWRBdCBwcm9wZXJ0eSBpbnRlcm5hbGx5XG4gICAgICAodGhyZWFkKSA9PiAoeyAuLi50aHJlYWQsIHVwZGF0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGRlbGV0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4aXN0aW5nIGNvbW1lbnQgYW5kIGVuc3VyZXMgdGhlIGFzc29jaWF0ZWQgbm90aWZpY2F0aW9uIGlzXG4gICAqIHVwZGF0ZWQgY29ycmVjdGx5LCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICBjcmVhdGVDb21tZW50KG5ld0NvbW1lbnQsIG9wdGltaXN0aWNVcGRhdGVJZCkge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSB0aGlzLl9yYXdUaHJlYWRzREIuZ2V0KG5ld0NvbW1lbnQudGhyZWFkSWQpO1xuICAgICAgaWYgKCFleGlzdGluZ1RocmVhZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm11dGF0ZVRocmVhZHNEQihcbiAgICAgICAgKGRiKSA9PiBkYi51cHNlcnQoYXBwbHlVcHNlcnRDb21tZW50KGV4aXN0aW5nVGhyZWFkLCBuZXdDb21tZW50KSlcbiAgICAgICk7XG4gICAgICB0aGlzLnVwZGF0ZUluYm94Tm90aWZpY2F0aW9uc0NhY2hlKChjYWNoZSkgPT4ge1xuICAgICAgICBjb25zdCBleGlzdGluZ05vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMoY2FjaGUpLmZpbmQoXG4gICAgICAgICAgKG5vdGlmaWNhdGlvbikgPT4gbm90aWZpY2F0aW9uLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgbm90aWZpY2F0aW9uLnRocmVhZElkID09PSBuZXdDb21tZW50LnRocmVhZElkXG4gICAgICAgICk7XG4gICAgICAgIGlmICghZXhpc3RpbmdOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jYWNoZSxcbiAgICAgICAgICBbZXhpc3RpbmdOb3RpZmljYXRpb24uaWRdOiB7XG4gICAgICAgICAgICAuLi5leGlzdGluZ05vdGlmaWNhdGlvbixcbiAgICAgICAgICAgIG5vdGlmaWVkQXQ6IG5ld0NvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgICAgcmVhZEF0OiBuZXdDb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGVkaXRDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQsIGVkaXRlZENvbW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICh0aHJlYWQpID0+IGFwcGx5VXBzZXJ0Q29tbWVudCh0aHJlYWQsIGVkaXRlZENvbW1lbnQpXG4gICAgKTtcbiAgfVxuICBkZWxldGVDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGhyZWFkKFxuICAgICAgdGhyZWFkSWQsXG4gICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAodGhyZWFkKSA9PiBhcHBseURlbGV0ZUNvbW1lbnQodGhyZWFkLCBjb21tZW50SWQsIGRlbGV0ZWRBdCksXG4gICAgICBkZWxldGVkQXRcbiAgICApO1xuICB9XG4gIHVwZGF0ZVRocmVhZEFuZE5vdGlmaWNhdGlvbih0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5tdXRhdGVUaHJlYWRzREIoKGRiKSA9PiBkYi51cHNlcnRJZk5ld2VyKHRocmVhZCkpO1xuICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy51cGRhdGVJbmJveE5vdGlmaWNhdGlvbnNDYWNoZSgoY2FjaGUpID0+ICh7XG4gICAgICAgICAgLi4uY2FjaGUsXG4gICAgICAgICAgW2luYm94Tm90aWZpY2F0aW9uLmlkXTogaW5ib3hOb3RpZmljYXRpb25cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKHRocmVhZHMsIGluYm94Tm90aWZpY2F0aW9ucywgZGVsZXRlZFRocmVhZHMgPSBbXSwgZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucyA9IFtdKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5tdXRhdGVUaHJlYWRzREIoXG4gICAgICAgIChkYikgPT4gYXBwbHlUaHJlYWREZWx0YVVwZGF0ZXMoZGIsIHsgbmV3VGhyZWFkczogdGhyZWFkcywgZGVsZXRlZFRocmVhZHMgfSlcbiAgICAgICk7XG4gICAgICB0aGlzLnVwZGF0ZUluYm94Tm90aWZpY2F0aW9uc0NhY2hlKFxuICAgICAgICAoY2FjaGUpID0+IGFwcGx5Tm90aWZpY2F0aW9uc1VwZGF0ZXMoY2FjaGUsIHtcbiAgICAgICAgICBuZXdJbmJveE5vdGlmaWNhdGlvbnM6IGluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICBkZWxldGVkTm90aWZpY2F0aW9uczogZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBleGlzdGluZyBub3RpZmljYXRpb24gc2V0dGluZyBmb3IgYSByb29tIHdpdGggYSBuZXcgdmFsdWUsXG4gICAqIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc19jb25maXJtT3B0aW1pc3RpY1VwZGF0ZShyb29tSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zdG9yZS5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIHRoaXMuc2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzZXR0aW5ncyk7XG4gICAgfSk7XG4gIH1cbiAgYWRkT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlKSB7XG4gICAgY29uc3QgaWQgPSBuYW5vaWQoKTtcbiAgICBjb25zdCBuZXdVcGRhdGUgPSB7IC4uLm9wdGltaXN0aWNVcGRhdGUsIGlkIH07XG4gICAgdGhpcy51cGRhdGVPcHRpbWlzdGljVXBkYXRlc0NhY2hlKChjYWNoZSkgPT4gWy4uLmNhY2hlLCBuZXdVcGRhdGVdKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgcmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpIHtcbiAgICB0aGlzLnVwZGF0ZU9wdGltaXN0aWNVcGRhdGVzQ2FjaGUoXG4gICAgICAoY2FjaGUpID0+IGNhY2hlLmZpbHRlcigob3UpID0+IG91LmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWQpXG4gICAgKTtcbiAgfVxuICBhc3luYyBmZXRjaE5vdGlmaWNhdGlvbnNEZWx0YVVwZGF0ZShzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLl9ub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0O1xuICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fY2xpZW50LmdldEluYm94Tm90aWZpY2F0aW9uc1NpbmNlKHtcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0IDwgcmVzdWx0LnJlcXVlc3RlZEF0KSB7XG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0LnJlcXVlc3RlZEF0O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgcmVzdWx0LnRocmVhZHMudXBkYXRlZCxcbiAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMudXBkYXRlZCxcbiAgICAgIHJlc3VsdC50aHJlYWRzLmRlbGV0ZWQsXG4gICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLmRlbGV0ZWRcbiAgICApO1xuICB9XG4gIHdhaXRVbnRpbE5vdGlmaWNhdGlvbnNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vdGlmaWNhdGlvbnMud2FpdFVudGlsTG9hZGVkKCk7XG4gIH1cbiAgd2FpdFVudGlsUm9vbVRocmVhZHNMb2FkZWQocm9vbUlkLCBxdWVyeSkge1xuICAgIGNvbnN0IHRocmVhZHNGZXRjaGVyID0gYXN5bmMgKGN1cnNvcikgPT4ge1xuICAgICAgY29uc3Qgcm9vbSA9IHRoaXMuX2NsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKGBSb29tICcke3Jvb21JZH0nIGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YCwgNDc5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJvb20uZ2V0VGhyZWFkcyh7IGN1cnNvciwgcXVlcnkgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGxhc3RSZXF1ZXN0ZWRBdCA9IHRoaXMuX3Jvb21UaHJlYWRzTGFzdFJlcXVlc3RlZEF0QnlSb29tLmdldChyb29tSWQpO1xuICAgICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwIHx8IGxhc3RSZXF1ZXN0ZWRBdCA+IHJlc3VsdC5yZXF1ZXN0ZWRBdCkge1xuICAgICAgICB0aGlzLl9yb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQocm9vbUlkLCByZXN1bHQucmVxdWVzdGVkQXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdC5uZXh0Q3Vyc29yO1xuICAgIH07XG4gICAgY29uc3QgcXVlcnlLZXkgPSBtYWtlUm9vbVRocmVhZHNRdWVyeUtleShyb29tSWQsIHF1ZXJ5KTtcbiAgICBsZXQgcGFnaW5hdGVkUmVzb3VyY2UgPSB0aGlzLl9yb29tVGhyZWFkcy5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChwYWdpbmF0ZWRSZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBQYWdpbmF0ZWRSZXNvdXJjZSh0aHJlYWRzRmV0Y2hlcik7XG4gICAgfVxuICAgIHBhZ2luYXRlZFJlc291cmNlLm9ic2VydmFibGUuc3Vic2NyaWJlKFxuICAgICAgKCkgPT4gKFxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIHN0b3JlIGl0c2VsZiBkb2VzIG5vdCBjaGFuZ2UsIGJ1dCBpdCdzIG9ubHkgdmVoaWNsZSBhdFxuICAgICAgICAvLyB0aGUgbW9tZW50IHRvIHRyaWdnZXIgYSByZS1yZW5kZXIsIHNvIHdlJ2xsIGRvIGEgbm8tb3AgdXBkYXRlIGhlcmUuXG4gICAgICAgIHRoaXMuX3N0b3JlLnNldCgoc3RvcmUpID0+ICh7IC4uLnN0b3JlIH0pKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5fcm9vbVRocmVhZHMuc2V0KHF1ZXJ5S2V5LCBwYWdpbmF0ZWRSZXNvdXJjZSk7XG4gICAgcmV0dXJuIHBhZ2luYXRlZFJlc291cmNlLndhaXRVbnRpbExvYWRlZCgpO1xuICB9XG4gIGFzeW5jIGZldGNoUm9vbVRocmVhZHNEZWx0YVVwZGF0ZShyb29tSWQsIHNpZ25hbCkge1xuICAgIGNvbnN0IGxhc3RSZXF1ZXN0ZWRBdCA9IHRoaXMuX3Jvb21UaHJlYWRzTGFzdFJlcXVlc3RlZEF0QnlSb29tLmdldChyb29tSWQpO1xuICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb29tID0gbm4oXG4gICAgICB0aGlzLl9jbGllbnQuZ2V0Um9vbShyb29tSWQpLFxuICAgICAgYFJvb20gd2l0aCBpZCAke3Jvb21JZH0gaXMgbm90IGF2YWlsYWJsZSBvbiBjbGllbnRgXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVzID0gYXdhaXQgcm9vbS5nZXRUaHJlYWRzU2luY2Uoe1xuICAgICAgc2luY2U6IGxhc3RSZXF1ZXN0ZWRBdCxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICB1cGRhdGVzLnRocmVhZHMudXBkYXRlZCxcbiAgICAgIHVwZGF0ZXMuaW5ib3hOb3RpZmljYXRpb25zLnVwZGF0ZWQsXG4gICAgICB1cGRhdGVzLnRocmVhZHMuZGVsZXRlZCxcbiAgICAgIHVwZGF0ZXMuaW5ib3hOb3RpZmljYXRpb25zLmRlbGV0ZWRcbiAgICApO1xuICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPCB1cGRhdGVzLnJlcXVlc3RlZEF0KSB7XG4gICAgICB0aGlzLl9yb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQocm9vbUlkLCB1cGRhdGVzLnJlcXVlc3RlZEF0KTtcbiAgICB9XG4gIH1cbiAgd2FpdFVudGlsVXNlclRocmVhZHNMb2FkZWQocXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IG1ha2VVc2VyVGhyZWFkc1F1ZXJ5S2V5KHF1ZXJ5KTtcbiAgICBjb25zdCB0aHJlYWRzRmV0Y2hlciA9IGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2NsaWVudFtrSW50ZXJuYWxdLmdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCh7XG4gICAgICAgIGN1cnNvcixcbiAgICAgICAgcXVlcnlcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgICAgcmVzdWx0LnRocmVhZHMsXG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5fdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQucmVxdWVzdGVkQXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0Lm5leHRDdXJzb3I7XG4gICAgfTtcbiAgICBsZXQgcGFnaW5hdGVkUmVzb3VyY2UgPSB0aGlzLl91c2VyVGhyZWFkcy5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChwYWdpbmF0ZWRSZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBQYWdpbmF0ZWRSZXNvdXJjZSh0aHJlYWRzRmV0Y2hlcik7XG4gICAgfVxuICAgIHBhZ2luYXRlZFJlc291cmNlLm9ic2VydmFibGUuc3Vic2NyaWJlKFxuICAgICAgKCkgPT4gKFxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIHN0b3JlIGl0c2VsZiBkb2VzIG5vdCBjaGFuZ2UsIGJ1dCBpdCdzIG9ubHkgdmVoaWNsZSBhdFxuICAgICAgICAvLyB0aGUgbW9tZW50IHRvIHRyaWdnZXIgYSByZS1yZW5kZXIsIHNvIHdlJ2xsIGRvIGEgbm8tb3AgdXBkYXRlIGhlcmUuXG4gICAgICAgIHRoaXMuX3N0b3JlLnNldCgoc3RvcmUpID0+ICh7IC4uLnN0b3JlIH0pKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5fdXNlclRocmVhZHMuc2V0KHF1ZXJ5S2V5LCBwYWdpbmF0ZWRSZXNvdXJjZSk7XG4gICAgcmV0dXJuIHBhZ2luYXRlZFJlc291cmNlLndhaXRVbnRpbExvYWRlZCgpO1xuICB9XG4gIGFzeW5jIGZldGNoVXNlclRocmVhZHNEZWx0YVVwZGF0ZShzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLl91c2VyVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdDtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2NsaWVudFtrSW50ZXJuYWxdLmdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsKHtcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0IDwgcmVzdWx0LnJlcXVlc3RlZEF0KSB7XG4gICAgICB0aGlzLl9ub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0LnJlcXVlc3RlZEF0O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgcmVzdWx0LnRocmVhZHMudXBkYXRlZCxcbiAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMudXBkYXRlZCxcbiAgICAgIHJlc3VsdC50aHJlYWRzLmRlbGV0ZWQsXG4gICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLmRlbGV0ZWRcbiAgICApO1xuICB9XG4gIHdhaXRVbnRpbFJvb21WZXJzaW9uc0xvYWRlZChyb29tSWQpIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IG1ha2VWZXJzaW9uc1F1ZXJ5S2V5KHJvb21JZCk7XG4gICAgbGV0IHJlc291cmNlID0gdGhpcy5fcm9vbVZlcnNpb25zLmdldChxdWVyeUtleSk7XG4gICAgaWYgKHJlc291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHZlcnNpb25zRmV0Y2hlciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgcm9vbSA9IHRoaXMuX2NsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICAgIGlmIChyb29tID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcihcbiAgICAgICAgICAgIGBSb29tICcke3Jvb21JZH0nIGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YCxcbiAgICAgICAgICAgIDQ3OVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcm9vbVtrSW50ZXJuYWxdLmxpc3RUZXh0VmVyc2lvbnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVSb29tVmVyc2lvbnMocm9vbUlkLCByZXN1bHQudmVyc2lvbnMpO1xuICAgICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLl9yb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb21JZCk7XG4gICAgICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IHZvaWQgMCB8fCBsYXN0UmVxdWVzdGVkQXQgPiByZXN1bHQucmVxdWVzdGVkQXQpIHtcbiAgICAgICAgICB0aGlzLl9yb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20uc2V0KFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgcmVzdWx0LnJlcXVlc3RlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlc291cmNlID0gbmV3IFNpbmdsZVBhZ2VSZXNvdXJjZSh2ZXJzaW9uc0ZldGNoZXIpO1xuICAgIH1cbiAgICByZXNvdXJjZS5vYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICgpID0+IChcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzdG9yZSBpdHNlbGYgZG9lcyBub3QgY2hhbmdlLCBidXQgaXQncyBvbmx5IHZlaGljbGUgYXRcbiAgICAgICAgLy8gdGhlIG1vbWVudCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyLCBzbyB3ZSdsbCBkbyBhIG5vLW9wIHVwZGF0ZSBoZXJlLlxuICAgICAgICB0aGlzLl9zdG9yZS5zZXQoKHN0b3JlKSA9PiAoeyAuLi5zdG9yZSB9KSlcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3Jvb21WZXJzaW9ucy5zZXQocXVlcnlLZXksIHJlc291cmNlKTtcbiAgICByZXR1cm4gcmVzb3VyY2Uud2FpdFVudGlsTG9hZGVkKCk7XG4gIH1cbiAgYXN5bmMgZmV0Y2hSb29tVmVyc2lvbnNEZWx0YVVwZGF0ZShyb29tSWQsIHNpZ25hbCkge1xuICAgIGNvbnN0IGxhc3RSZXF1ZXN0ZWRBdCA9IHRoaXMuX3Jvb21WZXJzaW9uc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5nZXQocm9vbUlkKTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vbSA9IG5uKFxuICAgICAgdGhpcy5fY2xpZW50LmdldFJvb20ocm9vbUlkKSxcbiAgICAgIGBSb29tIHdpdGggaWQgJHtyb29tSWR9IGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YFxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlcyA9IGF3YWl0IHJvb21ba0ludGVybmFsXS5saXN0VGV4dFZlcnNpb25zU2luY2Uoe1xuICAgICAgc2luY2U6IGxhc3RSZXF1ZXN0ZWRBdCxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlUm9vbVZlcnNpb25zKHJvb21JZCwgdXBkYXRlcy52ZXJzaW9ucyk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA8IHVwZGF0ZXMucmVxdWVzdGVkQXQpIHtcbiAgICAgIHRoaXMuX3Jvb21WZXJzaW9uc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQocm9vbUlkLCB1cGRhdGVzLnJlcXVlc3RlZEF0KTtcbiAgICB9XG4gIH1cbiAgd2FpdFVudGlsUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzTG9hZGVkKHJvb21JZCkge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZU5vdGlmaWNhdGlvblNldHRpbmdzUXVlcnlLZXkocm9vbUlkKTtcbiAgICBsZXQgcmVzb3VyY2UgPSB0aGlzLl9yb29tTm90aWZpY2F0aW9uU2V0dGluZ3MuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAocmVzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgbm90aWZpY2F0aW9uU2V0dGluZ3NGZXRjaGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByb29tID0gdGhpcy5fY2xpZW50LmdldFJvb20ocm9vbUlkKTtcbiAgICAgICAgaWYgKHJvb20gPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKFxuICAgICAgICAgICAgYFJvb20gJyR7cm9vbUlkfScgaXMgbm90IGF2YWlsYWJsZSBvbiBjbGllbnRgLFxuICAgICAgICAgICAgNDc5XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByb29tLmdldE5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gICAgICAgIHRoaXMuc2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCByZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlc291cmNlID0gbmV3IFNpbmdsZVBhZ2VSZXNvdXJjZShub3RpZmljYXRpb25TZXR0aW5nc0ZldGNoZXIpO1xuICAgIH1cbiAgICByZXNvdXJjZS5vYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICgpID0+IChcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzdG9yZSBpdHNlbGYgZG9lcyBub3QgY2hhbmdlLCBidXQgaXQncyBvbmx5IHZlaGljbGUgYXRcbiAgICAgICAgLy8gdGhlIG1vbWVudCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyLCBzbyB3ZSdsbCBkbyBhIG5vLW9wIHVwZGF0ZSBoZXJlLlxuICAgICAgICB0aGlzLl9zdG9yZS5zZXQoKHN0b3JlKSA9PiAoeyAuLi5zdG9yZSB9KSlcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3Jvb21Ob3RpZmljYXRpb25TZXR0aW5ncy5zZXQocXVlcnlLZXksIHJlc291cmNlKTtcbiAgICByZXR1cm4gcmVzb3VyY2Uud2FpdFVudGlsTG9hZGVkKCk7XG4gIH1cbiAgYXN5bmMgcmVmcmVzaFJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyhyb29tSWQsIHNpZ25hbCkge1xuICAgIGNvbnN0IHJvb20gPSBubihcbiAgICAgIHRoaXMuX2NsaWVudC5nZXRSb29tKHJvb21JZCksXG4gICAgICBgUm9vbSB3aXRoIGlkICR7cm9vbUlkfSBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGBcbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJvb20uZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3MoeyBzaWduYWwgfSk7XG4gICAgdGhpcy5zZXROb3RpZmljYXRpb25TZXR0aW5ncyhyb29tSWQsIHJlc3VsdCk7XG4gIH1cbn07XG5mdW5jdGlvbiBpbnRlcm5hbFRvRXh0ZXJuYWxTdGF0ZShzdGF0ZSwgcmF3VGhyZWFkc0RCKSB7XG4gIGNvbnN0IHRocmVhZHNEQiA9IHJhd1RocmVhZHNEQi5jbG9uZSgpO1xuICBjb25zdCBjb21wdXRlZCA9IHtcbiAgICBub3RpZmljYXRpb25zQnlJZDogeyAuLi5zdGF0ZS5ub3RpZmljYXRpb25zQnlJZCB9LFxuICAgIHNldHRpbmdzQnlSb29tSWQ6IHsgLi4uc3RhdGUuc2V0dGluZ3NCeVJvb21JZCB9XG4gIH07XG4gIGZvciAoY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZSBvZiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcykge1xuICAgIHN3aXRjaCAob3B0aW1pc3RpY1VwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiY3JlYXRlLXRocmVhZFwiOiB7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQob3B0aW1pc3RpY1VwZGF0ZS50aHJlYWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LXRocmVhZC1tZXRhZGF0YVwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIGlmICh0aHJlYWQudXBkYXRlZEF0ID4gb3B0aW1pc3RpY1VwZGF0ZS51cGRhdGVkQXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KHtcbiAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgdXBkYXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLnVwZGF0ZWRBdCxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgLi4udGhyZWFkLm1ldGFkYXRhLFxuICAgICAgICAgICAgLi4ub3B0aW1pc3RpY1VwZGF0ZS5tZXRhZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstdGhyZWFkLWFzLXJlc29sdmVkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydCh7IC4uLnRocmVhZCwgcmVzb2x2ZWQ6IHRydWUgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstdGhyZWFkLWFzLXVucmVzb2x2ZWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KHsgLi4udGhyZWFkLCByZXNvbHZlZDogZmFsc2UgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImNyZWF0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KGFwcGx5VXBzZXJ0Q29tbWVudCh0aHJlYWQsIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudCkpO1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMoXG4gICAgICAgICAgY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWRcbiAgICAgICAgKS5maW5kKFxuICAgICAgICAgIChub3RpZmljYXRpb24pID0+IG5vdGlmaWNhdGlvbi5raW5kID09PSBcInRocmVhZFwiICYmIG5vdGlmaWNhdGlvbi50aHJlYWRJZCA9PT0gdGhyZWFkLmlkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbmJveE5vdGlmaWNhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWRbaW5ib3hOb3RpZmljYXRpb24uaWRdID0ge1xuICAgICAgICAgIC4uLmluYm94Tm90aWZpY2F0aW9uLFxuICAgICAgICAgIG5vdGlmaWVkQXQ6IG9wdGltaXN0aWNVcGRhdGUuY29tbWVudC5jcmVhdGVkQXQsXG4gICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVkaXQtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChhcHBseVVwc2VydENvbW1lbnQodGhyZWFkLCBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KFxuICAgICAgICAgIGFwcGx5RGVsZXRlQ29tbWVudChcbiAgICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5kZWxldGVkQXRcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS10aHJlYWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KHtcbiAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgZGVsZXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9wdGltaXN0aWNVcGRhdGUuZGVsZXRlZEF0LFxuICAgICAgICAgIGNvbW1lbnRzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYWRkLXJlYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChcbiAgICAgICAgICBhcHBseUFkZFJlYWN0aW9uKFxuICAgICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50SWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnJlYWN0aW9uXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJyZW1vdmUtcmVhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KFxuICAgICAgICAgIGFwcGx5UmVtb3ZlUmVhY3Rpb24oXG4gICAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZW1vamksXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnVzZXJJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUucmVtb3ZlZEF0XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCI6IHtcbiAgICAgICAgY29uc3QgaWJuID0gY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXTtcbiAgICAgICAgaWYgKGlibiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXSA9IHtcbiAgICAgICAgICAuLi5pYm4sXG4gICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLnJlYWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLWFsbC1pbmJveC1ub3RpZmljYXRpb25zLWFzLXJlYWRcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkKSB7XG4gICAgICAgICAgY29uc3QgaWJuID0gY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWRbaWRdO1xuICAgICAgICAgIGlmIChpYm4gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkW2lkXSA9IHtcbiAgICAgICAgICAgIC4uLmlibixcbiAgICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5yZWFkQXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1pbmJveC1ub3RpZmljYXRpb25cIjoge1xuICAgICAgICBkZWxldGUgY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWRbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWFsbC1pbmJveC1ub3RpZmljYXRpb25zXCI6IHtcbiAgICAgICAgY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWQgPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXBkYXRlLW5vdGlmaWNhdGlvbi1zZXR0aW5nc1wiOiB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gY29tcHV0ZWQuc2V0dGluZ3NCeVJvb21JZFtvcHRpbWlzdGljVXBkYXRlLnJvb21JZF07XG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZWQuc2V0dGluZ3NCeVJvb21JZFtvcHRpbWlzdGljVXBkYXRlLnJvb21JZF0gPSB7XG4gICAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgICAgLi4ub3B0aW1pc3RpY1VwZGF0ZS5zZXR0aW5nc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBjbGVhbmVkTm90aWZpY2F0aW9ucyA9IChcbiAgICAvLyBTb3J0IHNvIHRoYXQgdGhlIG1vc3QgcmVjZW50IG5vdGlmaWNhdGlvbnMgYXJlIGZpcnN0XG4gICAgT2JqZWN0LnZhbHVlcyhjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZCkuZmlsdGVyKFxuICAgICAgKGlibikgPT4gaWJuLmtpbmQgPT09IFwidGhyZWFkXCIgPyB0aHJlYWRzREIuZ2V0KGlibi50aHJlYWRJZCkgIT09IHZvaWQgMCA6IHRydWVcbiAgICApLnNvcnQoKGEsIGIpID0+IGIubm90aWZpZWRBdC5nZXRUaW1lKCkgLSBhLm5vdGlmaWVkQXQuZ2V0VGltZSgpKVxuICApO1xuICByZXR1cm4ge1xuICAgIGNsZWFuZWROb3RpZmljYXRpb25zLFxuICAgIG5vdGlmaWNhdGlvbnNCeUlkOiBjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZCxcbiAgICBzZXR0aW5nc0J5Um9vbUlkOiBjb21wdXRlZC5zZXR0aW5nc0J5Um9vbUlkLFxuICAgIHRocmVhZHNEQixcbiAgICB2ZXJzaW9uc0J5Um9vbUlkOiBzdGF0ZS52ZXJzaW9uc0J5Um9vbUlkXG4gIH07XG59XG5mdW5jdGlvbiBhcHBseVRocmVhZERlbHRhVXBkYXRlcyhkYiwgdXBkYXRlcykge1xuICB1cGRhdGVzLm5ld1RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiBkYi51cHNlcnRJZk5ld2VyKHRocmVhZCkpO1xuICB1cGRhdGVzLmRlbGV0ZWRUaHJlYWRzLmZvckVhY2goKHsgaWQsIGRlbGV0ZWRBdCB9KSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBkYi5nZXRFdmVuSWZEZWxldGVkKGlkKTtcbiAgICBpZiAoIWV4aXN0aW5nKSByZXR1cm47XG4gICAgZGIuZGVsZXRlKGlkLCBkZWxldGVkQXQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFwcGx5Tm90aWZpY2F0aW9uc1VwZGF0ZXMoZXhpc3RpbmdJbmJveE5vdGlmaWNhdGlvbnMsIHVwZGF0ZXMpIHtcbiAgY29uc3QgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucyA9IHsgLi4uZXhpc3RpbmdJbmJveE5vdGlmaWNhdGlvbnMgfTtcbiAgdXBkYXRlcy5uZXdJbmJveE5vdGlmaWNhdGlvbnMuZm9yRWFjaCgobm90aWZpY2F0aW9uKSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmdOb3RpZmljYXRpb24gPSB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zW25vdGlmaWNhdGlvbi5pZF07XG4gICAgaWYgKGV4aXN0aW5nTm90aWZpY2F0aW9uKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlSW5ib3hOb3RpZmljYXRpb25zKFxuICAgICAgICBleGlzdGluZ05vdGlmaWNhdGlvbixcbiAgICAgICAgbm90aWZpY2F0aW9uXG4gICAgICApO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gMSkgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zW25vdGlmaWNhdGlvbi5pZF0gPSBub3RpZmljYXRpb247XG4gIH0pO1xuICB1cGRhdGVzLmRlbGV0ZWROb3RpZmljYXRpb25zLmZvckVhY2goXG4gICAgKHsgaWQgfSkgPT4gZGVsZXRlIHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnNbaWRdXG4gICk7XG4gIHJldHVybiB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zO1xufVxuZnVuY3Rpb24gY29tcGFyZUluYm94Tm90aWZpY2F0aW9ucyhpbmJveE5vdGlmaWNhdGlvbkEsIGluYm94Tm90aWZpY2F0aW9uQikge1xuICBpZiAoaW5ib3hOb3RpZmljYXRpb25BLm5vdGlmaWVkQXQgPiBpbmJveE5vdGlmaWNhdGlvbkIubm90aWZpZWRBdCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5ub3RpZmllZEF0IDwgaW5ib3hOb3RpZmljYXRpb25CLm5vdGlmaWVkQXQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgJiYgaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCkge1xuICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ID4gaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCA/IDEgOiBpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0IDwgaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCA/IC0xIDogMDtcbiAgfSBlbHNlIGlmIChpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0IHx8IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQpIHtcbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFwcGx5VXBzZXJ0Q29tbWVudCh0aHJlYWQsIGNvbW1lbnQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGNvbW1lbnQudGhyZWFkSWQgIT09IHRocmVhZC5pZCkge1xuICAgIGNvbnNvbGUyLndhcm4oXG4gICAgICBgQ29tbWVudCAke2NvbW1lbnQuaWR9IGRvZXMgbm90IGJlbG9uZyB0byB0aHJlYWQgJHt0aHJlYWQuaWR9YFxuICAgICk7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoZXhpc3RpbmdDb21tZW50MikgPT4gZXhpc3RpbmdDb21tZW50Mi5pZCA9PT0gY29tbWVudC5pZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHRocmVhZC51cGRhdGVkQXQuZ2V0VGltZSgpLCBjb21tZW50LmNyZWF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVkVGhyZWFkID0ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgdXBkYXRlZEF0LFxuICAgICAgY29tbWVudHM6IFsuLi50aHJlYWQuY29tbWVudHMsIGNvbW1lbnRdXG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmVkaXRlZEF0ID09PSB2b2lkIDAgfHwgY29tbWVudC5lZGl0ZWRBdCA9PT0gdm9pZCAwIHx8IGV4aXN0aW5nQ29tbWVudC5lZGl0ZWRBdCA8PSBjb21tZW50LmVkaXRlZEF0KSB7XG4gICAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAgIChleGlzdGluZ0NvbW1lbnQyKSA9PiBleGlzdGluZ0NvbW1lbnQyLmlkID09PSBjb21tZW50LmlkID8gY29tbWVudCA6IGV4aXN0aW5nQ29tbWVudDJcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZWRUaHJlYWQgPSB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICB0aHJlYWQudXBkYXRlZEF0LmdldFRpbWUoKSxcbiAgICAgICAgICBjb21tZW50LmVkaXRlZEF0Py5nZXRUaW1lKCkgfHwgY29tbWVudC5jcmVhdGVkQXQuZ2V0VGltZSgpXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgfVxuICByZXR1cm4gdGhyZWFkO1xufVxuZnVuY3Rpb24gYXBwbHlEZWxldGVDb21tZW50KHRocmVhZCwgY29tbWVudElkLCBkZWxldGVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICAvLyBXZSBvcHRpbWlzdGljYWxseSByZW1vdmUgdGhlIGNvbW1lbnQgYm9keSBhbmQgYXR0YWNobWVudHMgd2hlbiBtYXJraW5nIGl0IGFzIGRlbGV0ZWRcbiAgICAgIGJvZHk6IHZvaWQgMCxcbiAgICAgIGF0dGFjaG1lbnRzOiBbXVxuICAgIH0gOiBjb21tZW50XG4gICk7XG4gIGlmICh1cGRhdGVkQ29tbWVudHMuZXZlcnkoKGNvbW1lbnQpID0+IGNvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIGRlbGV0ZWRBdCxcbiAgICAgIHVwZGF0ZWRBdDogZGVsZXRlZEF0XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdCxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBhcHBseUFkZFJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCByZWFjdGlvbikge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIHJlYWN0aW9uczogdXBzZXJ0UmVhY3Rpb24oY29tbWVudC5yZWFjdGlvbnMsIHJlYWN0aW9uKVxuICAgIH0gOiBjb21tZW50XG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4udGhyZWFkLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoXG4gICAgICBNYXRoLm1heChyZWFjdGlvbi5jcmVhdGVkQXQuZ2V0VGltZSgpLCB0aHJlYWQudXBkYXRlZEF0LmdldFRpbWUoKSlcbiAgICApLFxuICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5UmVtb3ZlUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIGVtb2ppLCB1c2VySWQsIHJlbW92ZWRBdCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIHJlYWN0aW9uczogY29tbWVudC5yZWFjdGlvbnMubWFwKFxuICAgICAgICAocmVhY3Rpb24pID0+IHJlYWN0aW9uLmVtb2ppID09PSBlbW9qaSA/IHtcbiAgICAgICAgICAuLi5yZWFjdGlvbixcbiAgICAgICAgICB1c2VyczogcmVhY3Rpb24udXNlcnMuZmlsdGVyKCh1c2VyKSA9PiB1c2VyLmlkICE9PSB1c2VySWQpXG4gICAgICAgIH0gOiByZWFjdGlvblxuICAgICAgKS5maWx0ZXIoKHJlYWN0aW9uKSA9PiByZWFjdGlvbi51c2Vycy5sZW5ndGggPiAwKVxuICAgICAgLy8gUmVtb3ZlIHJlYWN0aW9ucyB3aXRoIG5vIHVzZXJzIGxlZnRcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVtb3ZlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiB1cHNlcnRSZWFjdGlvbihyZWFjdGlvbnMsIHJlYWN0aW9uKSB7XG4gIGNvbnN0IGV4aXN0aW5nUmVhY3Rpb24gPSByZWFjdGlvbnMuZmluZChcbiAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaVxuICApO1xuICBpZiAoZXhpc3RpbmdSZWFjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnJlYWN0aW9ucyxcbiAgICAgIHtcbiAgICAgICAgZW1vamk6IHJlYWN0aW9uLmVtb2ppLFxuICAgICAgICBjcmVhdGVkQXQ6IHJlYWN0aW9uLmNyZWF0ZWRBdCxcbiAgICAgICAgdXNlcnM6IFt7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGlmIChleGlzdGluZ1JlYWN0aW9uLnVzZXJzLnNvbWUoKHVzZXIpID0+IHVzZXIuaWQgPT09IHJlYWN0aW9uLnVzZXJJZCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHJlYWN0aW9ucy5tYXAoXG4gICAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaSA/IHtcbiAgICAgICAgLi4uZXhpc3RpbmdSZWFjdGlvbjIsXG4gICAgICAgIHVzZXJzOiBbLi4uZXhpc3RpbmdSZWFjdGlvbjIudXNlcnMsIHsgaWQ6IHJlYWN0aW9uLnVzZXJJZCB9XVxuICAgICAgfSA6IGV4aXN0aW5nUmVhY3Rpb24yXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVhY3Rpb25zO1xufVxuXG4vLyBzcmMvbGl2ZWJsb2Nrcy50c3hcbnZhciBDbGllbnRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDIobnVsbCk7XG5mdW5jdGlvbiBtaXNzaW5nVXNlckVycm9yKHVzZXJJZCkge1xuICByZXR1cm4gbmV3IEVycm9yKGByZXNvbHZlVXNlcnMgZGlkbid0IHJldHVybiBhbnl0aGluZyBmb3IgdXNlciAnJHt1c2VySWR9J2ApO1xufVxuZnVuY3Rpb24gbWlzc2luZ1Jvb21JbmZvRXJyb3Iocm9vbUlkKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYHJlc29sdmVSb29tc0luZm8gZGlkbid0IHJldHVybiBhbnl0aGluZyBmb3Igcm9vbSAnJHtyb29tSWR9J2BcbiAgKTtcbn1cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG52YXIgX3VtYnJlbGxhU3RvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgX2V4dHJhcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIF9idW5kbGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzZWxlY3RVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChpbmJveE5vdGlmaWNhdGlvbnMpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBub3RpZmljYXRpb24gb2YgaW5ib3hOb3RpZmljYXRpb25zKSB7XG4gICAgaWYgKG5vdGlmaWNhdGlvbi5yZWFkQXQgPT09IG51bGwgfHwgbm90aWZpY2F0aW9uLnJlYWRBdCA8IG5vdGlmaWNhdGlvbi5ub3RpZmllZEF0KSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChyZXN1bHQpIHtcbiAgaWYgKCFyZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgY291bnQ6IHNlbGVjdFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpXG4gIH07XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VVc2VyKHN0YXRlLCB1c2VySWQpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDAgfHwgc3RhdGU/LmlzTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZSA/PyB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGlmIChzdGF0ZS5lcnJvcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAoIXN0YXRlLmRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGVycm9yOiBtaXNzaW5nVXNlckVycm9yKHVzZXJJZClcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1c2VyOiBzdGF0ZS5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VSb29tSW5mbyhzdGF0ZSwgcm9vbUlkKSB7XG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwIHx8IHN0YXRlPy5pc0xvYWRpbmcpIHtcbiAgICByZXR1cm4gc3RhdGUgPz8geyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgfVxuICBpZiAoc3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKCFzdGF0ZS5kYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBlcnJvcjogbWlzc2luZ1Jvb21JbmZvRXJyb3Iocm9vbUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIGluZm86IHN0YXRlLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ29udGV4dEJ1bmRsZShjbGllbnQpIHtcbiAgbGV0IGJ1bmRsZSA9IF9idW5kbGVzLmdldChjbGllbnQpO1xuICBpZiAoIWJ1bmRsZSkge1xuICAgIGJ1bmRsZSA9IG1ha2VMaXZlYmxvY2tzQ29udGV4dEJ1bmRsZShjbGllbnQpO1xuICAgIF9idW5kbGVzLnNldChjbGllbnQsIGJ1bmRsZSk7XG4gIH1cbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KSB7XG4gIGxldCBzdG9yZSA9IF91bWJyZWxsYVN0b3Jlcy5nZXQoY2xpZW50KTtcbiAgaWYgKCFzdG9yZSkge1xuICAgIHN0b3JlID0gbmV3IFVtYnJlbGxhU3RvcmUoY2xpZW50KTtcbiAgICBfdW1icmVsbGFTdG9yZXMuc2V0KGNsaWVudCwgc3RvcmUpO1xuICB9XG4gIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KSB7XG4gIGxldCBleHRyYXMgPSBfZXh0cmFzLmdldChjbGllbnQpO1xuICBpZiAoIWV4dHJhcykge1xuICAgIGV4dHJhcyA9IG1ha2VMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgX2V4dHJhcy5zZXQoY2xpZW50LCBleHRyYXMpO1xuICB9XG4gIHJldHVybiBleHRyYXM7XG59XG5mdW5jdGlvbiBtYWtlTGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IG5vdGlmaWNhdGlvbnNQb2xsZXIgPSBtYWtlUG9sbGVyKFxuICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5mZXRjaE5vdGlmaWNhdGlvbnNEZWx0YVVwZGF0ZShzaWduYWwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUG9sbGluZyBuZXcgaW5ib3ggbm90aWZpY2F0aW9ucyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmZpZy5OT1RJRklDQVRJT05TX1BPTExfSU5URVJWQUwsXG4gICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLk5PVElGSUNBVElPTlNfTUFYX1NUQUxFX1RJTUUgfVxuICApO1xuICBjb25zdCB1c2VyVGhyZWFkc1BvbGxlciA9IG1ha2VQb2xsZXIoXG4gICAgYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLmZldGNoVXNlclRocmVhZHNEZWx0YVVwZGF0ZShzaWduYWwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUG9sbGluZyBuZXcgdXNlciB0aHJlYWRzIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29uZmlnLlVTRVJfVEhSRUFEU19QT0xMX0lOVEVSVkFMLFxuICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5VU0VSX1RIUkVBRFNfTUFYX1NUQUxFX1RJTUUgfVxuICApO1xuICByZXR1cm4ge1xuICAgIHN0b3JlLFxuICAgIG5vdGlmaWNhdGlvbnNQb2xsZXIsXG4gICAgdXNlclRocmVhZHNQb2xsZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VMaXZlYmxvY2tzQ29udGV4dEJ1bmRsZShjbGllbnQpIHtcbiAgY29uc3QgdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQyID0gKGluYm94Tm90aWZpY2F0aW9uSWQpID0+IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkX3dpdGhDbGllbnQoY2xpZW50LCBpbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgY29uc3QgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkMiA9ICgpID0+IHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZF93aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyID0gKCkgPT4gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZF93aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uMiA9ICgpID0+IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uX3dpdGhDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zMiA9ICgpID0+IHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCk7XG4gIGZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcjIocHJvcHMpIHtcbiAgICB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcigpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoQ2xpZW50Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY2xpZW50IH0sIHByb3BzLmNoaWxkcmVuKTtcbiAgfVxuICBjb25zdCBzaGFyZWQgPSBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCk7XG4gIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICBMaXZlYmxvY2tzUHJvdmlkZXI6IExpdmVibG9ja3NQcm92aWRlcjIsXG4gICAgdXNlSW5ib3hOb3RpZmljYXRpb25zOiAoKSA9PiB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQsIGlkZW50aXR5LCBzaGFsbG93MyksXG4gICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQ6ICgpID0+IHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50X3dpdGhDbGllbnQoY2xpZW50KSxcbiAgICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQ6IHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDIsXG4gICAgdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDogdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDIsXG4gICAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb246IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uMixcbiAgICB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnM6IHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczIsXG4gICAgdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQ6IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkMixcbiAgICB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwsXG4gICAgLi4uc2hhcmVkLmNsYXNzaWMsXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIExpdmVibG9ja3NQcm92aWRlcjogTGl2ZWJsb2Nrc1Byb3ZpZGVyMixcbiAgICAgIHVzZUluYm94Tm90aWZpY2F0aW9uczogKCkgPT4gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQpLFxuICAgICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQ6ICgpID0+IHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQpLFxuICAgICAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQyLFxuICAgICAgdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDogdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDIsXG4gICAgICB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjogdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24yLFxuICAgICAgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zOiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMyLFxuICAgICAgdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQ6IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkMixcbiAgICAgIHVzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbDogdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwsXG4gICAgICAuLi5zaGFyZWQuc3VzcGVuc2VcbiAgICB9XG4gIH07XG4gIHJldHVybiBidW5kbGU7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHsgc3RvcmUsIG5vdGlmaWNhdGlvbnNQb2xsZXI6IHBvbGxlciB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICB2b2lkIHN0b3JlLndhaXRVbnRpbE5vdGlmaWNhdGlvbnNMb2FkZWQoKTtcbiAgfSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIHBvbGxlci5pbmMoKTtcbiAgICBwb2xsZXIucG9sbE5vd0lmU3RhbGUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9sbGVyLmRlYygpO1xuICAgIH07XG4gIH0sIFtwb2xsZXJdKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICBzdG9yZS5nZXRJbmJveE5vdGlmaWNhdGlvbnNMb2FkaW5nU3RhdGUsXG4gICAgc3RvcmUuZ2V0SW5ib3hOb3RpZmljYXRpb25zTG9hZGluZ1N0YXRlLFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICB1c2Uoc3RvcmUud2FpdFVudGlsTm90aWZpY2F0aW9uc0xvYWRlZCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50LCBpZGVudGl0eSwgc2hhbGxvdzMpO1xuICBhc3NlcnQoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KGNsaWVudCkge1xuICByZXR1cm4gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoXG4gICAgY2xpZW50LFxuICAgIHNlbGVjdG9yRm9yX3VzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgIHNoYWxsb3czXG4gICk7XG59XG5mdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICB1c2Uoc3RvcmUud2FpdFVudGlsTm90aWZpY2F0aW9uc0xvYWRlZCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRfd2l0aENsaWVudChjbGllbnQpO1xuICBhc3NlcnQoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMihcbiAgICAoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3QgcmVhZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCIsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQsXG4gICAgICAgIHJlYWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnQubWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS51cGRhdGVJbmJveE5vdGlmaWNhdGlvbihcbiAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoaW5ib3hOb3RpZmljYXRpb24pID0+ICh7IC4uLmluYm94Tm90aWZpY2F0aW9uLCByZWFkQXQgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMigoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIGNvbnN0IHJlYWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgdHlwZTogXCJtYXJrLWFsbC1pbmJveC1ub3RpZmljYXRpb25zLWFzLXJlYWRcIixcbiAgICAgIHJlYWRBdFxuICAgIH0pO1xuICAgIGNsaWVudC5tYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkudGhlbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgc3RvcmUudXBkYXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoaW5ib3hOb3RpZmljYXRpb24pID0+ICh7IC4uLmluYm94Tm90aWZpY2F0aW9uLCByZWFkQXQgfSlcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIH1cbiAgICApO1xuICB9LCBbY2xpZW50XSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbl93aXRoQ2xpZW50KGNsaWVudCkge1xuICByZXR1cm4gdXNlQ2FsbGJhY2syKFxuICAgIChpbmJveE5vdGlmaWNhdGlvbklkKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBkZWxldGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImRlbGV0ZS1pbmJveC1ub3RpZmljYXRpb25cIixcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgZGVsZXRlZEF0XG4gICAgICB9KTtcbiAgICAgIGNsaWVudC5kZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oXG4gICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMigoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIGNvbnN0IGRlbGV0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgdHlwZTogXCJkZWxldGUtYWxsLWluYm94LW5vdGlmaWNhdGlvbnNcIixcbiAgICAgIGRlbGV0ZWRBdFxuICAgIH0pO1xuICAgIGNsaWVudC5kZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMoKS50aGVuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzdG9yZS5kZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIH1cbiAgICApO1xuICB9LCBbY2xpZW50XSk7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZF93aXRoQ2xpZW50KGNsaWVudCwgaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IGdldHRlciA9IHN0b3JlLmdldEZ1bGxTdGF0ZTtcbiAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazIoXG4gICAgKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IHN0YXRlLm5vdGlmaWNhdGlvbnNCeUlkW2luYm94Tm90aWZpY2F0aW9uSWRdID8/IHJhaXNlKGBJbmJveCBub3RpZmljYXRpb24gd2l0aCBJRCBcIiR7aW5ib3hOb3RpZmljYXRpb25JZH1cIiBub3QgZm91bmRgKTtcbiAgICAgIGlmIChpbmJveE5vdGlmaWNhdGlvbi5raW5kICE9PSBcInRocmVhZFwiKSB7XG4gICAgICAgIHJhaXNlKFxuICAgICAgICAgIGBJbmJveCBub3RpZmljYXRpb24gd2l0aCBJRCBcIiR7aW5ib3hOb3RpZmljYXRpb25JZH1cIiBpcyBub3Qgb2Yga2luZCBcInRocmVhZFwiYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGhyZWFkID0gc3RhdGUudGhyZWFkc0RCLmdldChpbmJveE5vdGlmaWNhdGlvbi50aHJlYWRJZCkgPz8gcmFpc2UoXG4gICAgICAgIGBUaHJlYWQgd2l0aCBJRCBcIiR7aW5ib3hOb3RpZmljYXRpb24udGhyZWFkSWR9XCIgbm90IGZvdW5kLCB0aGlzIGluYm94IG5vdGlmaWNhdGlvbiBtaWdodCBub3QgYmUgb2Yga2luZCBcInRocmVhZFwiYFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aHJlYWQ7XG4gICAgfSxcbiAgICBbaW5ib3hOb3RpZmljYXRpb25JZF1cbiAgKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAvLyBSZS1ldmFsdWF0ZSBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSBhbnkgdGltZSB0aGUgbm90aWZpY2F0aW9uIGNoYW5nZXMgb3ZlciB0aW1lXG4gICAgZ2V0dGVyLFxuICAgIGdldHRlcixcbiAgICBzZWxlY3RvclxuICApO1xufVxuZnVuY3Rpb24gdXNlVXNlcl93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSB7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjbGllbnRba0ludGVybmFsMl0udXNlcnNTdG9yZTtcbiAgY29uc3QgZ2V0VXNlclN0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHVzZXJzU3RvcmUuZ2V0U3RhdGUodXNlcklkKSxcbiAgICBbdXNlcnNTdG9yZSwgdXNlcklkXVxuICApO1xuICBjb25zdCBzZWxlY3RvciA9IHVzZUNhbGxiYWNrMihcbiAgICAoc3RhdGUpID0+IHNlbGVjdG9yRm9yX3VzZVVzZXIoc3RhdGUsIHVzZXJJZCksXG4gICAgW3VzZXJJZF1cbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgdXNlcnNTdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0VXNlclN0YXRlLFxuICAgIGdldFVzZXJTdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBzaGFsbG93M1xuICApO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICB2b2lkIHVzZXJzU3RvcmUuZ2V0KHVzZXJJZCk7XG4gIH0sIFt1c2Vyc1N0b3JlLCB1c2VySWQsIHJlc3VsdF0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlVXNlclN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpIHtcbiAgY29uc3QgdXNlcnNTdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS51c2Vyc1N0b3JlO1xuICBjb25zdCBnZXRVc2VyU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gdXNlcnNTdG9yZS5nZXRTdGF0ZSh1c2VySWQpLFxuICAgIFt1c2Vyc1N0b3JlLCB1c2VySWRdXG4gICk7XG4gIGNvbnN0IHVzZXJTdGF0ZSA9IGdldFVzZXJTdGF0ZSgpO1xuICBpZiAoIXVzZXJTdGF0ZSB8fCB1c2VyU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgdXNlcnNTdG9yZS5nZXQodXNlcklkKTtcbiAgfVxuICBpZiAodXNlclN0YXRlLmVycm9yKSB7XG4gICAgdGhyb3cgdXNlclN0YXRlLmVycm9yO1xuICB9XG4gIGlmICghdXNlclN0YXRlLmRhdGEpIHtcbiAgICB0aHJvdyBtaXNzaW5nVXNlckVycm9yKHVzZXJJZCk7XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICB1c2Vyc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRVc2VyU3RhdGUsXG4gICAgZ2V0VXNlclN0YXRlXG4gICk7XG4gIGFzc2VydChzdGF0ZSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5pc0xvYWRpbmcsIFwiVW5leHBlY3RlZCBsb2FkaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQoIXN0YXRlLmVycm9yLCBcIlVuZXhwZWN0ZWQgZXJyb3Igc3RhdGVcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1c2VyOiBzdGF0ZS5kYXRhLFxuICAgIGVycm9yOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpIHtcbiAgY29uc3Qgcm9vbXNJbmZvU3RvcmUgPSBjbGllbnRba0ludGVybmFsMl0ucm9vbXNJbmZvU3RvcmU7XG4gIGNvbnN0IGdldFJvb21JbmZvU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gcm9vbXNJbmZvU3RvcmUuZ2V0U3RhdGUocm9vbUlkKSxcbiAgICBbcm9vbXNJbmZvU3RvcmUsIHJvb21JZF1cbiAgKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazIoXG4gICAgKHN0YXRlKSA9PiBzZWxlY3RvckZvcl91c2VSb29tSW5mbyhzdGF0ZSwgcm9vbUlkKSxcbiAgICBbcm9vbUlkXVxuICApO1xuICBjb25zdCByZXN1bHQgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICByb29tc0luZm9TdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZSxcbiAgICBnZXRSb29tSW5mb1N0YXRlLFxuICAgIHNlbGVjdG9yLFxuICAgIHNoYWxsb3czXG4gICk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIHZvaWQgcm9vbXNJbmZvU3RvcmUuZ2V0KHJvb21JZCk7XG4gIH0sIFtyb29tc0luZm9TdG9yZSwgcm9vbUlkLCByZXN1bHRdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHJvb21JZCkge1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS5yb29tc0luZm9TdG9yZTtcbiAgY29uc3QgZ2V0Um9vbUluZm9TdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoKSA9PiByb29tc0luZm9TdG9yZS5nZXRTdGF0ZShyb29tSWQpLFxuICAgIFtyb29tc0luZm9TdG9yZSwgcm9vbUlkXVxuICApO1xuICBjb25zdCByb29tSW5mb1N0YXRlID0gZ2V0Um9vbUluZm9TdGF0ZSgpO1xuICBpZiAoIXJvb21JbmZvU3RhdGUgfHwgcm9vbUluZm9TdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICB0aHJvdyByb29tc0luZm9TdG9yZS5nZXQocm9vbUlkKTtcbiAgfVxuICBpZiAocm9vbUluZm9TdGF0ZS5lcnJvcikge1xuICAgIHRocm93IHJvb21JbmZvU3RhdGUuZXJyb3I7XG4gIH1cbiAgaWYgKCFyb29tSW5mb1N0YXRlLmRhdGEpIHtcbiAgICB0aHJvdyBtaXNzaW5nUm9vbUluZm9FcnJvcihyb29tSWQpO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgcm9vbXNJbmZvU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldFJvb21JbmZvU3RhdGUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZVxuICApO1xuICBhc3NlcnQoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuaXNMb2FkaW5nLCBcIlVuZXhwZWN0ZWQgbG9hZGluZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5lcnJvciwgXCJVbmV4cGVjdGVkIGVycm9yIHN0YXRlXCIpO1xuICBhc3NlcnQoc3RhdGUuZGF0YSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyByb29tIGluZm8gZGF0YVwiKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIGluZm86IHN0YXRlLmRhdGEsXG4gICAgZXJyb3I6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpIHtcbiAgY29uc3QgdXNlQ2xpZW50MiA9ICgpID0+IGNsaWVudDtcbiAgcmV0dXJuIHtcbiAgICBjbGFzc2ljOiB7XG4gICAgICB1c2VDbGllbnQ6IHVzZUNsaWVudDIsXG4gICAgICB1c2VVc2VyOiAodXNlcklkKSA9PiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpLFxuICAgICAgdXNlUm9vbUluZm86IChyb29tSWQpID0+IHVzZVJvb21JbmZvX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpLFxuICAgICAgdXNlSXNJbnNpZGVSb29tXG4gICAgfSxcbiAgICBzdXNwZW5zZToge1xuICAgICAgdXNlQ2xpZW50OiB1c2VDbGllbnQyLFxuICAgICAgdXNlVXNlcjogKHVzZXJJZCkgPT4gdXNlVXNlclN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpLFxuICAgICAgdXNlUm9vbUluZm86IChyb29tSWQpID0+IHVzZVJvb21JbmZvU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHJvb21JZCksXG4gICAgICB1c2VJc0luc2lkZVJvb21cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcihvcHRpb25zKSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gdXNlQ2xpZW50T3JOdWxsKCk7XG4gIGlmICghb3B0aW9ucz8uYWxsb3dOZXN0aW5nICYmIGV4aXN0aW5nICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IG5lc3QgbXVsdGlwbGUgTGl2ZWJsb2Nrc1Byb3ZpZGVyIGluc3RhbmNlcyBpbiB0aGUgc2FtZSBSZWFjdCB0cmVlLlwiXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlQ2xpZW50T3JOdWxsKCkge1xuICByZXR1cm4gdXNlQ29udGV4dDIoQ2xpZW50Q29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VDbGllbnQoKSB7XG4gIHJldHVybiB1c2VDbGllbnRPck51bGwoKSA/PyByYWlzZShcIkxpdmVibG9ja3NQcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xufVxuZnVuY3Rpb24gTGl2ZWJsb2Nrc1Byb3ZpZGVyV2l0aENsaWVudChwcm9wcykge1xuICB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcihwcm9wcyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoQ2xpZW50Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvcHMuY2xpZW50IH0sIHByb3BzLmNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcihwcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5vIH0gPSBwcm9wcztcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBwdWJsaWNBcGlLZXk6IHVzZUluaXRpYWwoby5wdWJsaWNBcGlLZXkpLFxuICAgIHRocm90dGxlOiB1c2VJbml0aWFsKG8udGhyb3R0bGUpLFxuICAgIGxvc3RDb25uZWN0aW9uVGltZW91dDogdXNlSW5pdGlhbChvLmxvc3RDb25uZWN0aW9uVGltZW91dCksXG4gICAgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQ6IHVzZUluaXRpYWwoby5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCksXG4gICAgcG9seWZpbGxzOiB1c2VJbml0aWFsKG8ucG9seWZpbGxzKSxcbiAgICB1bnN0YWJsZV9mYWxsYmFja1RvSFRUUDogdXNlSW5pdGlhbChvLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQKSxcbiAgICB1bnN0YWJsZV9zdHJlYW1EYXRhOiB1c2VJbml0aWFsKG8udW5zdGFibGVfc3RyZWFtRGF0YSksXG4gICAgYXV0aEVuZHBvaW50OiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oby5hdXRoRW5kcG9pbnQpLFxuICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM6IHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihcbiAgICAgIG8ucmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uc1xuICAgICksXG4gICAgcmVzb2x2ZVVzZXJzOiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oby5yZXNvbHZlVXNlcnMpLFxuICAgIHJlc29sdmVSb29tc0luZm86IHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihvLnJlc29sdmVSb29tc0luZm8pLFxuICAgIGJhc2VVcmw6IHVzZUluaXRpYWwoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gSGlkZGVuIGNvbmZpZyBvcHRpb25zXG4gICAgICBvLmJhc2VVcmxcbiAgICApLFxuICAgIGVuYWJsZURlYnVnTG9nZ2luZzogdXNlSW5pdGlhbChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBIaWRkZW4gY29uZmlnIG9wdGlvbnNcbiAgICAgIG8uZW5hYmxlRGVidWdMb2dnaW5nXG4gICAgKVxuICB9O1xuICBjb25zdCBjbGllbnQgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZUNsaWVudChvcHRpb25zKSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQsIHsgY2xpZW50IH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0KGNsaWVudCkge1xuICByZXR1cm4gZ2V0T3JDcmVhdGVDb250ZXh0QnVuZGxlKGNsaWVudCk7XG59XG5mdW5jdGlvbiB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucyA9IHtcbiAgcXVlcnk6IHtcbiAgICBtZXRhZGF0YToge31cbiAgfVxufSkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBzdG9yZSwgdXNlclRocmVhZHNQb2xsZXI6IHBvbGxlciB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2VFZmZlY3QyKFxuICAgICgpID0+IHtcbiAgICAgIHZvaWQgc3RvcmUud2FpdFVudGlsVXNlclRocmVhZHNMb2FkZWQob3B0aW9ucy5xdWVyeSk7XG4gICAgfVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb2xsZXIuZGVjKCk7XG4gICAgfTtcbiAgfSwgW3BvbGxlcl0pO1xuICBjb25zdCBnZXR0ZXIgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gc3RvcmUuZ2V0VXNlclRocmVhZHNMb2FkaW5nU3RhdGUob3B0aW9ucy5xdWVyeSksXG4gICAgW3N0b3JlLCBvcHRpb25zLnF1ZXJ5XVxuICApO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldHRlcixcbiAgICBnZXR0ZXIsXG4gICAgaWRlbnRpdHksXG4gICAgc2hhbGxvdzJcbiAgICAvLyBOT1RFOiBVc2luZyAyLWxldmVsLWRlZXAgc2hhbGxvdyBjaGVjayBoZXJlLCBiZWNhdXNlIHRoZSByZXN1bHQgb2Ygc2VsZWN0VGhyZWFkcygpIGlzIG5vdCBzdGFibGUhXG4gICk7XG59XG5mdW5jdGlvbiB1c2VVc2VyVGhyZWFkc1N1c3BlbnNlX2V4cGVyaW1lbnRhbChvcHRpb25zID0ge1xuICBxdWVyeToge1xuICAgIG1ldGFkYXRhOiB7fVxuICB9XG59KSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIHVzZShzdG9yZS53YWl0VW50aWxVc2VyVGhyZWFkc0xvYWRlZChvcHRpb25zLnF1ZXJ5KSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbChvcHRpb25zKTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydCghcmVzdWx0LmlzTG9hZGluZywgXCJEaWQgbm90IGV4cGVjdCBsb2FkaW5nXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICByZXR1cm4gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQodXNlQ2xpZW50KCksIGlkZW50aXR5LCBzaGFsbG93Myk7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZSgpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICByZXR1cm4gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWRfd2l0aENsaWVudChcbiAgICB1c2VDbGllbnQoKSxcbiAgICBpbmJveE5vdGlmaWNhdGlvbklkXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkge1xuICByZXR1cm4gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZF93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZF93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgcmV0dXJuIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uKCkge1xuICByZXR1cm4gdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb25fd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCgpIHtcbiAgcmV0dXJuIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50X3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZSgpIHtcbiAgcmV0dXJuIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2Vfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VVc2VyKHVzZXJJZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZVVzZXJfd2l0aENsaWVudChjbGllbnQsIHVzZXJJZCk7XG59XG5mdW5jdGlvbiB1c2VVc2VyU3VzcGVuc2UodXNlcklkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlVXNlclN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpO1xufVxuZnVuY3Rpb24gdXNlUm9vbUluZm8ocm9vbUlkKSB7XG4gIHJldHVybiB1c2VSb29tSW5mb193aXRoQ2xpZW50KHVzZUNsaWVudCgpLCByb29tSWQpO1xufVxuZnVuY3Rpb24gdXNlUm9vbUluZm9TdXNwZW5zZShyb29tSWQpIHtcbiAgcmV0dXJuIHVzZVJvb21JbmZvU3VzcGVuc2Vfd2l0aENsaWVudCh1c2VDbGllbnQoKSwgcm9vbUlkKTtcbn1cbnZhciBfdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQgPSB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDtcbnZhciBfdXNlVXNlciA9IHVzZVVzZXI7XG52YXIgX3VzZVVzZXJTdXNwZW5zZSA9IHVzZVVzZXJTdXNwZW5zZTtcbnZhciBfdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsID0gdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsO1xudmFyIF91c2VVc2VyVGhyZWFkc1N1c3BlbnNlX2V4cGVyaW1lbnRhbCA9IHVzZVVzZXJUaHJlYWRzU3VzcGVuc2VfZXhwZXJpbWVudGFsO1xuXG4vLyBzcmMvdHlwZXMvZXJyb3JzLnRzXG52YXIgQ3JlYXRlVGhyZWFkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkNyZWF0ZSB0aHJlYWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkNyZWF0ZVRocmVhZEVycm9yXCI7XG4gIH1cbn07XG52YXIgRGVsZXRlVGhyZWFkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkRlbGV0ZSB0aHJlYWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkRlbGV0ZVRocmVhZEVycm9yXCI7XG4gIH1cbn07XG52YXIgRWRpdFRocmVhZE1ldGFkYXRhRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkVkaXQgdGhyZWFkIG1ldGFkYXRhIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJFZGl0VGhyZWFkTWV0YWRhdGFFcnJvclwiO1xuICB9XG59O1xudmFyIE1hcmtUaHJlYWRBc1Jlc29sdmVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIk1hcmsgdGhyZWFkIGFzIHJlc29sdmVkIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJNYXJrVGhyZWFkQXNSZXNvbHZlZEVycm9yXCI7XG4gIH1cbn07XG52YXIgTWFya1RocmVhZEFzVW5yZXNvbHZlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJNYXJrIHRocmVhZCBhcyB1bnJlc29sdmVkIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJNYXJrVGhyZWFkQXNVbnJlc29sdmVkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBDcmVhdGVDb21tZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkNyZWF0ZSBjb21tZW50IGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJDcmVhdGVDb21tZW50RXJyb3JcIjtcbiAgfVxufTtcbnZhciBFZGl0Q29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJFZGl0IGNvbW1lbnQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkVkaXRDb21tZW50RXJyb3JcIjtcbiAgfVxufTtcbnZhciBEZWxldGVDb21tZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkRlbGV0ZSBjb21tZW50IGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJEZWxldGVDb21tZW50RXJyb3JcIjtcbiAgfVxufTtcbnZhciBBZGRSZWFjdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJBZGQgcmVhY3Rpb24gZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkFkZFJlYWN0aW9uRXJyb3JcIjtcbiAgfVxufTtcbnZhciBSZW1vdmVSZWFjdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJSZW1vdmUgcmVhY3Rpb24gZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIlJlbW92ZVJlYWN0aW9uRXJyb3JcIjtcbiAgfVxufTtcbnZhciBNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiTWFyayBpbmJveCBub3RpZmljYXRpb24gYXMgcmVhZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJVcGRhdGUgbm90aWZpY2F0aW9uIHNldHRpbmdzIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc0Vycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9yb29tLnRzeFxuaW1wb3J0IHsgc2hhbGxvdyBhcyBzaGFsbG93NCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jbGllbnRcIjtcbmltcG9ydCB7XG4gIGFzc2VydCBhcyBhc3NlcnQyLFxuICBjb25zb2xlIGFzIGNvbnNvbGUzLFxuICBjcmVhdGVDb21tZW50SWQsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBkZXByZWNhdGVJZixcbiAgZXJyb3JJZixcbiAgSHR0cEVycm9yIGFzIEh0dHBFcnJvcjIsXG4gIGtJbnRlcm5hbCBhcyBrSW50ZXJuYWwzLFxuICBtYWtlRXZlbnRTb3VyY2UgYXMgbWFrZUV2ZW50U291cmNlMixcbiAgbWFrZVBvbGxlciBhcyBtYWtlUG9sbGVyMixcbiAgU2VydmVyTXNnQ29kZVxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0ICogYXMgUmVhY3Q0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgYXMgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qc1wiO1xuXG4vLyBzcmMvdXNlLXNjcm9sbC10by1jb21tZW50LW9uLWxvYWQtZWZmZWN0LnRzXG5pbXBvcnQgKiBhcyBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQoc2hvdWxkU2Nyb2xsT25Mb2FkLCBzdGF0ZSkge1xuICBpZiAoc2hvdWxkU2Nyb2xsT25Mb2FkID09PSBmYWxzZSkgcmV0dXJuO1xuICBpZiAoIXN0YXRlLnRocmVhZHMpIHJldHVybjtcbiAgY29uc3QgaXNXaW5kb3dEZWZpbmVkID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKCFpc1dpbmRvd0RlZmluZWQpIHJldHVybjtcbiAgY29uc3QgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICBjb25zdCBjb21tZW50SWQgPSBoYXNoLnNsaWNlKDEpO1xuICBpZiAoIWNvbW1lbnRJZC5zdGFydHNXaXRoKFwiY21fXCIpKSByZXR1cm47XG4gIGNvbnN0IGNvbW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb21tZW50SWQpO1xuICBpZiAoY29tbWVudCA9PT0gbnVsbCkgcmV0dXJuO1xuICBjb25zdCBjb21tZW50cyA9IHN0YXRlLnRocmVhZHMuZmxhdE1hcCgodGhyZWFkKSA9PiB0aHJlYWQuY29tbWVudHMpO1xuICBjb25zdCBpc0NvbW1lbnRJblRocmVhZHMgPSBjb21tZW50cy5zb21lKFxuICAgIChjb21tZW50MikgPT4gY29tbWVudDIuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoIWlzQ29tbWVudEluVGhyZWFkcykgcmV0dXJuO1xuICBjb21tZW50LnNjcm9sbEludG9WaWV3KCk7XG59XG5mdW5jdGlvbiB1c2VTY3JvbGxUb0NvbW1lbnRPbkxvYWRFZmZlY3Qoc2hvdWxkU2Nyb2xsT25Mb2FkLCBzdGF0ZSkge1xuICBSZWFjdDMudXNlRWZmZWN0KFxuICAgICgpID0+IHtcbiAgICAgIGhhbmRsZVNjcm9sbFRvQ29tbWVudE9uTG9hZChzaG91bGRTY3JvbGxPbkxvYWQsIHN0YXRlKTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgLS0gV2Ugb25seSB3YW50IHRvIHJ1biB0aGlzIGVmZmVjdCBvbmNlXG4gICAgW3N0YXRlLmlzTG9hZGluZ11cbiAgKTtcbn1cblxuLy8gc3JjL3Jvb20udHN4XG52YXIgU01PT1RIX0RFTEFZID0gMWUzO1xudmFyIG5vb3AzID0gKCkgPT4ge1xufTtcbnZhciBpZGVudGl0eTIgPSAoeCkgPT4geDtcbnZhciBtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gKHJlYWN0VmVyc2lvbiwgcm9vbUlkKSA9PiBgV2Ugbm90aWNlZCB5b3VcXHUyMDE5cmUgdXNpbmcgUmVhY3QgJHtyZWFjdFZlcnNpb259LiBQbGVhc2UgcGFzcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhdCB0aGUgUm9vbVByb3ZpZGVyIGxldmVsIHVudGlsIHlvdVxcdTIwMTlyZSByZWFkeSB0byB1cGdyYWRlIHRvIFJlYWN0IDE4OlxuXG4gICAgaW1wb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tIFwicmVhY3QtZG9tXCI7ICAvLyBvciBcInJlYWN0LW5hdGl2ZVwiXG5cbiAgICA8Um9vbVByb3ZpZGVyIGlkPSR7SlNPTi5zdHJpbmdpZnkoXG4gIHJvb21JZFxuKX0gLi4uIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPXt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30+XG4gICAgICAuLi5cbiAgICA8L1Jvb21Qcm92aWRlcj5cblxuV2h5PyBQbGVhc2Ugc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3Ryb3VibGVzaG9vdGluZyNzdGFsZS1wcm9wcy16b21iaWUtY2hpbGQgZm9yIG1vcmUgaW5mb3JtYXRpb25gO1xudmFyIHN1cGVyZmx1b3VzX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gXCJZb3UgZG9uXFx1MjAxOXQgbmVlZCB0byBwYXNzIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIHRvIFJvb21Qcm92aWRlciBhbnltb3JlLCBzaW5jZSB5b3VcXHUyMDE5cmUgb24gUmVhY3QgMTgrIGFscmVhZHkuXCI7XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIocywgZ3MsIGdzcykge1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKHMsIGdzLCBnc3MsIGlkZW50aXR5Mik7XG59XG52YXIgU1RBQkxFX0VNUFRZX0xJU1QgPSBPYmplY3QuZnJlZXplKFtdKTtcbmZ1bmN0aW9uIGFsd2F5c0VtcHR5TGlzdCgpIHtcbiAgcmV0dXJuIFNUQUJMRV9FTVBUWV9MSVNUO1xufVxuZnVuY3Rpb24gYWx3YXlzTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VPdGhlcnNDb25uZWN0aW9uSWRzKG90aGVycykge1xuICByZXR1cm4gb3RoZXJzLm1hcCgodXNlcikgPT4gdXNlci5jb25uZWN0aW9uSWQpO1xufVxuZnVuY3Rpb24gbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSB7XG4gIGNvbnN0IGNhbm5vdFVzZVVudGlsID0gXCJUaGlzIG11dGF0aW9uIGNhbm5vdCBiZSB1c2VkIHVudGlsXCI7XG4gIGNvbnN0IG5lZWRzUHJlc2VuY2UgPSBgJHtjYW5ub3RVc2VVbnRpbH0gY29ubmVjdGVkIHRvIHRoZSBMaXZlYmxvY2tzIHJvb21gO1xuICBjb25zdCBuZWVkc1N0b3JhZ2UgPSBgJHtjYW5ub3RVc2VVbnRpbH0gc3RvcmFnZSBoYXMgYmVlbiBsb2FkZWRgO1xuICByZXR1cm4ge1xuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgY29uc3QgbXV0YWJsZVJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICAgICAgaWYgKG11dGFibGVSb290ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuZWVkc1N0b3JhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG11dGFibGVSb290O1xuICAgIH0sXG4gICAgZ2V0IHNlbGYoKSB7XG4gICAgICBjb25zdCBzZWxmID0gcm9vbS5nZXRTZWxmKCk7XG4gICAgICBpZiAoc2VsZiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNQcmVzZW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuICAgIGdldCBvdGhlcnMoKSB7XG4gICAgICBjb25zdCBvdGhlcnMgPSByb29tLmdldE90aGVycygpO1xuICAgICAgaWYgKHJvb20uZ2V0U2VsZigpID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuZWVkc1ByZXNlbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdGhlcnM7XG4gICAgfSxcbiAgICBzZXRNeVByZXNlbmNlOiByb29tLnVwZGF0ZVByZXNlbmNlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VXNlcklkKHJvb20pIHtcbiAgY29uc3Qgc2VsZiA9IHJvb20uZ2V0U2VsZigpO1xuICBpZiAoc2VsZiA9PT0gbnVsbCB8fCBzZWxmLmlkID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gXCJhbm9ueW1vdXNcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VsZi5pZDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQXBpRXJyb3IoZXJyKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtlcnIuc3RhdHVzfTogJHtlcnIubWVzc2FnZX1gO1xuICBpZiAoZXJyLmRldGFpbHM/LmVycm9yID09PSBcIkZPUkJJRERFTlwiKSB7XG4gICAgY29uc3QgZGV0YWlsZWRNZXNzYWdlID0gW21lc3NhZ2UsIGVyci5kZXRhaWxzLnN1Z2dlc3Rpb24sIGVyci5kZXRhaWxzLmRvY3NdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpO1xuICAgIGNvbnNvbGUzLmVycm9yKGRldGFpbGVkTWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbnZhciBfZXh0cmFzMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIF9idW5kbGVzMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0T3JDcmVhdGVSb29tQ29udGV4dEJ1bmRsZShjbGllbnQpIHtcbiAgbGV0IGJ1bmRsZSA9IF9idW5kbGVzMi5nZXQoY2xpZW50KTtcbiAgaWYgKCFidW5kbGUpIHtcbiAgICBidW5kbGUgPSBtYWtlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KTtcbiAgICBfYnVuZGxlczIuc2V0KGNsaWVudCwgYnVuZGxlKTtcbiAgfVxuICByZXR1cm4gYnVuZGxlO1xufVxuZnVuY3Rpb24gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpIHtcbiAgbGV0IGV4dHJhcyA9IF9leHRyYXMyLmdldChjbGllbnQpO1xuICBpZiAoIWV4dHJhcykge1xuICAgIGV4dHJhcyA9IG1ha2VSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgX2V4dHJhczIuc2V0KGNsaWVudCwgZXh0cmFzKTtcbiAgfVxuICByZXR1cm4gZXh0cmFzO1xufVxuZnVuY3Rpb24gbWFrZVJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBjb21tZW50c0Vycm9yRXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UyKCk7XG4gIGZ1bmN0aW9uIG9uTXV0YXRpb25GYWlsdXJlKGlubmVyRXJyb3IsIG9wdGltaXN0aWNVcGRhdGVJZCwgY3JlYXRlUHVibGljRXJyb3IpIHtcbiAgICBzdG9yZS5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgaWYgKGlubmVyRXJyb3IgaW5zdGFuY2VvZiBIdHRwRXJyb3IyKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGhhbmRsZUFwaUVycm9yKGlubmVyRXJyb3IpO1xuICAgICAgY29tbWVudHNFcnJvckV2ZW50U291cmNlLm5vdGlmeShjcmVhdGVQdWJsaWNFcnJvcihlcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5uZXJFcnJvciBpbnN0YW5jZW9mIEh0dHBFcnJvcjIpIHtcbiAgICAgIGhhbmRsZUFwaUVycm9yKGlubmVyRXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBpbm5lckVycm9yO1xuICB9XG4gIGNvbnN0IHRocmVhZHNQb2xsZXJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB2ZXJzaW9uc1BvbGxlcnNCeVJvb21JZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1BvbGxlcnNCeVJvb21JZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGdldE9yQ3JlYXRlVGhyZWFkc1BvbGxlckZvclJvb21JZChyb29tSWQpIHtcbiAgICBsZXQgcG9sbGVyID0gdGhyZWFkc1BvbGxlcnNCeVJvb21JZC5nZXQocm9vbUlkKTtcbiAgICBpZiAoIXBvbGxlcikge1xuICAgICAgcG9sbGVyID0gbWFrZVBvbGxlcjIoXG4gICAgICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLmZldGNoUm9vbVRocmVhZHNEZWx0YVVwZGF0ZShyb29tSWQsIHNpZ25hbCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlMy53YXJuKGBQb2xsaW5nIG5ldyB0aHJlYWRzIGZvciAnJHtyb29tSWR9JyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWcuUk9PTV9USFJFQURTX1BPTExfSU5URVJWQUwsXG4gICAgICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5ST09NX1RIUkVBRFNfTUFYX1NUQUxFX1RJTUUgfVxuICAgICAgKTtcbiAgICAgIHRocmVhZHNQb2xsZXJzQnlSb29tSWQuc2V0KHJvb21JZCwgcG9sbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbGxlcjtcbiAgfVxuICBmdW5jdGlvbiBnZXRPckNyZWF0ZVZlcnNpb25zUG9sbGVyRm9yUm9vbUlkKHJvb21JZCkge1xuICAgIGxldCBwb2xsZXIgPSB2ZXJzaW9uc1BvbGxlcnNCeVJvb21JZC5nZXQocm9vbUlkKTtcbiAgICBpZiAoIXBvbGxlcikge1xuICAgICAgcG9sbGVyID0gbWFrZVBvbGxlcjIoXG4gICAgICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLmZldGNoUm9vbVZlcnNpb25zRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZTMud2FybihgUG9sbGluZyBuZXcgaGlzdG9yeSB2ZXJzaW9ucyBmb3IgJyR7cm9vbUlkfScgZmFpbGVkOiAke1N0cmluZyhlcnIpfWApO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlnLkhJU1RPUllfVkVSU0lPTlNfUE9MTF9JTlRFUlZBTCxcbiAgICAgICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLkhJU1RPUllfVkVSU0lPTlNfTUFYX1NUQUxFX1RJTUUgfVxuICAgICAgKTtcbiAgICAgIHZlcnNpb25zUG9sbGVyc0J5Um9vbUlkLnNldChyb29tSWQsIHBvbGxlcik7XG4gICAgfVxuICAgIHJldHVybiBwb2xsZXI7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0T3JDcmVhdGVOb3RpZmljYXRpb25zU2V0dGluZ3NQb2xsZXJGb3JSb29tSWQocm9vbUlkKSB7XG4gICAgbGV0IHBvbGxlciA9IHJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1BvbGxlcnNCeVJvb21JZC5nZXQocm9vbUlkKTtcbiAgICBpZiAoIXBvbGxlcikge1xuICAgICAgcG9sbGVyID0gbWFrZVBvbGxlcjIoXG4gICAgICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLnJlZnJlc2hSb29tTm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzaWduYWwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZTMud2FybihgUG9sbGluZyBub3RpZmljYXRpb24gc2V0dGluZ3MgZm9yICcke3Jvb21JZH0nIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZy5OT1RJRklDQVRJT05fU0VUVElOR1NfUE9MTF9JTlRFUlZBTCxcbiAgICAgICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLk5PVElGSUNBVElPTl9TRVRUSU5HU19NQVhfU1RBTEVfVElNRSB9XG4gICAgICApO1xuICAgICAgcm9vbU5vdGlmaWNhdGlvblNldHRpbmdzUG9sbGVyc0J5Um9vbUlkLnNldChyb29tSWQsIHBvbGxlcik7XG4gICAgfVxuICAgIHJldHVybiBwb2xsZXI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdG9yZSxcbiAgICBjb21tZW50c0Vycm9yRXZlbnRTb3VyY2U6IGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZS5vYnNlcnZhYmxlLFxuICAgIG9uTXV0YXRpb25GYWlsdXJlLFxuICAgIGdldE9yQ3JlYXRlVGhyZWFkc1BvbGxlckZvclJvb21JZCxcbiAgICBnZXRPckNyZWF0ZVZlcnNpb25zUG9sbGVyRm9yUm9vbUlkLFxuICAgIGdldE9yQ3JlYXRlTm90aWZpY2F0aW9uc1NldHRpbmdzUG9sbGVyRm9yUm9vbUlkXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGZ1bmN0aW9uIFJvb21Qcm92aWRlcl93aXRoSW1wbGljaXRMaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQsIHsgY2xpZW50LCBhbGxvd05lc3Rpbmc6IHRydWUgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFJvb21Qcm92aWRlciwgeyAuLi5wcm9wcyB9KSk7XG4gIH1cbiAgY29uc3Qgc2hhcmVkID0gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpO1xuICBjb25zdCBidW5kbGUgPSB7XG4gICAgUm9vbUNvbnRleHQsXG4gICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICAgIHVzZVJvb20sXG4gICAgdXNlU3RhdHVzLFxuICAgIHVzZVN0b3JhZ2VTdGF0dXMsXG4gICAgdXNlQmF0Y2gsXG4gICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIsXG4gICAgdXNlSGlzdG9yeSxcbiAgICB1c2VVbmRvLFxuICAgIHVzZVJlZG8sXG4gICAgdXNlQ2FuUmVkbyxcbiAgICB1c2VDYW5VbmRvLFxuICAgIHVzZVN0b3JhZ2VSb290LFxuICAgIHVzZVN0b3JhZ2UsXG4gICAgdXNlU2VsZixcbiAgICB1c2VNeVByZXNlbmNlLFxuICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgdXNlT3RoZXJzLFxuICAgIHVzZU90aGVyc01hcHBlZCxcbiAgICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICAgIHVzZU90aGVyLFxuICAgIHVzZU11dGF0aW9uLFxuICAgIHVzZVRocmVhZHMsXG4gICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgIHVzZURlbGV0ZVRocmVhZCxcbiAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gICAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgIHVzZUVkaXRDb21tZW50LFxuICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgdXNlUmVtb3ZlUmVhY3Rpb24sXG4gICAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgICB1c2VUaHJlYWRTdWJzY3JpcHRpb24sXG4gICAgdXNlQXR0YWNobWVudFVybCxcbiAgICB1c2VIaXN0b3J5VmVyc2lvbnMsXG4gICAgdXNlSGlzdG9yeVZlcnNpb25EYXRhLFxuICAgIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgLi4uc2hhcmVkLmNsYXNzaWMsXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIFJvb21Db250ZXh0LFxuICAgICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICAgICAgdXNlUm9vbSxcbiAgICAgIHVzZVN0YXR1cyxcbiAgICAgIHVzZVN0b3JhZ2VTdGF0dXM6IHVzZVN0b3JhZ2VTdGF0dXNTdXNwZW5zZSxcbiAgICAgIHVzZUJhdGNoLFxuICAgICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICAgIHVzZUhpc3RvcnksXG4gICAgICB1c2VVbmRvLFxuICAgICAgdXNlUmVkbyxcbiAgICAgIHVzZUNhblJlZG8sXG4gICAgICB1c2VDYW5VbmRvLFxuICAgICAgdXNlU3RvcmFnZVJvb3QsXG4gICAgICB1c2VTdG9yYWdlOiB1c2VTdG9yYWdlU3VzcGVuc2UsXG4gICAgICB1c2VTZWxmOiB1c2VTZWxmU3VzcGVuc2UsXG4gICAgICB1c2VNeVByZXNlbmNlLFxuICAgICAgdXNlVXBkYXRlTXlQcmVzZW5jZSxcbiAgICAgIHVzZU90aGVyczogdXNlT3RoZXJzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNNYXBwZWQ6IHVzZU90aGVyc01hcHBlZFN1c3BlbnNlLFxuICAgICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkczogdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlLFxuICAgICAgdXNlT3RoZXI6IHVzZU90aGVyU3VzcGVuc2UsXG4gICAgICB1c2VNdXRhdGlvbixcbiAgICAgIHVzZVRocmVhZHM6IHVzZVRocmVhZHNTdXNwZW5zZSxcbiAgICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICAgIHVzZURlbGV0ZVRocmVhZCxcbiAgICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgICAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgICB1c2VFZGl0Q29tbWVudCxcbiAgICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgICB1c2VBZGRSZWFjdGlvbixcbiAgICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgICAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgICAgIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUF0dGFjaG1lbnRVcmw6IHVzZUF0dGFjaG1lbnRVcmxTdXNwZW5zZSxcbiAgICAgIC8vIFRPRE86IHVzZUhpc3RvcnlWZXJzaW9uRGF0YTogdXNlSGlzdG9yeVZlcnNpb25EYXRhU3VzcGVuc2UsXG4gICAgICB1c2VIaXN0b3J5VmVyc2lvbnM6IHVzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlLFxuICAgICAgdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzOiB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgICAgIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIC4uLnNoYXJlZC5zdXNwZW5zZVxuICAgIH0sXG4gICAgdXNlQ29tbWVudHNFcnJvckxpc3RlbmVyXG4gIH07XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVuZGxlLCBrSW50ZXJuYWwzLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBSb29tUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IFtjYWNoZV0gPSBSZWFjdDQudXNlU3RhdGUoXG4gICAgKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICApO1xuICBjb25zdCBzdGFibGVFbnRlclJvb20gPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHJvb21JZCwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHJvb21JZCk7XG4gICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgICAgY29uc3QgcnYgPSBjbGllbnQuZW50ZXJSb29tKHJvb21JZCwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBvcmlnTGVhdmUgPSBydi5sZWF2ZTtcbiAgICAgIHJ2LmxlYXZlID0gKCkgPT4ge1xuICAgICAgICBvcmlnTGVhdmUoKTtcbiAgICAgICAgY2FjaGUuZGVsZXRlKHJvb21JZCk7XG4gICAgICB9O1xuICAgICAgY2FjaGUuc2V0KHJvb21JZCwgcnYpO1xuICAgICAgcmV0dXJuIHJ2O1xuICAgIH0sXG4gICAgW2NsaWVudCwgY2FjaGVdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoXG4gICAgUm9vbVByb3ZpZGVySW5uZXIsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBzdGFibGVFbnRlclJvb21cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBSb29tUHJvdmlkZXJJbm5lcihwcm9wcykge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBpZDogcm9vbUlkLCBzdGFibGVFbnRlclJvb20gfSA9IHByb3BzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFyb29tSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgaXMgcmVxdWlyZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1yZWFjdC9Sb29tUHJvdmlkZXItaWQtcHJvcGVydHktaXMtcmVxdWlyZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyhyb29tSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgc2hvdWxkIGJlIGEgc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbWFqb3JSZWFjdFZlcnNpb24gPSBwYXJzZUludChSZWFjdDQudmVyc2lvbikgfHwgMTtcbiAgICBjb25zdCBvbGRSZWFjdFZlcnNpb24gPSBtYWpvclJlYWN0VmVyc2lvbiA8IDE4O1xuICAgIGVycm9ySWYoXG4gICAgICBvbGRSZWFjdFZlcnNpb24gJiYgcHJvcHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPT09IHZvaWQgMCxcbiAgICAgIG1pc3NpbmdfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMobWFqb3JSZWFjdFZlcnNpb24sIHJvb21JZClcbiAgICApO1xuICAgIGRlcHJlY2F0ZUlmKFxuICAgICAgIW9sZFJlYWN0VmVyc2lvbiAmJiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyAhPT0gdm9pZCAwLFxuICAgICAgc3VwZXJmbHVvdXNfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbiAgICApO1xuICB9XG4gIGNvbnN0IGZyb3plblByb3BzID0gdXNlSW5pdGlhbCh7XG4gICAgaW5pdGlhbFByZXNlbmNlOiBwcm9wcy5pbml0aWFsUHJlc2VuY2UsXG4gICAgaW5pdGlhbFN0b3JhZ2U6IHByb3BzLmluaXRpYWxTdG9yYWdlLFxuICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICBhdXRvQ29ubmVjdDogcHJvcHMuYXV0b0Nvbm5lY3QgPz8gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICB9KTtcbiAgY29uc3QgW3sgcm9vbSB9LCBzZXRSb29tTGVhdmVQYWlyXSA9IFJlYWN0NC51c2VTdGF0ZShcbiAgICAoKSA9PiBzdGFibGVFbnRlclJvb20ocm9vbUlkLCB7XG4gICAgICAuLi5mcm96ZW5Qcm9wcyxcbiAgICAgIGF1dG9Db25uZWN0OiBmYWxzZVxuICAgICAgLy8gRGVsaWJlcmF0ZWx5IHVzaW5nIGZhbHNlIGhlcmUgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlIGJlbG93XG4gICAgfSlcbiAgKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKSB7XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSBTZXJ2ZXJNc2dDb2RlLlRIUkVBRF9ERUxFVEVEKSB7XG4gICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZChtZXNzYWdlLnRocmVhZElkLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHJvb20uZ2V0VGhyZWFkKG1lc3NhZ2UudGhyZWFkSWQpO1xuICAgICAgaWYgKCFpbmZvLnRocmVhZCkge1xuICAgICAgICBzdG9yZS5kZWxldGVUaHJlYWQobWVzc2FnZS50aHJlYWRJZCwgbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbiB9ID0gaW5mbztcbiAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RvcmUuZ2V0RnVsbFN0YXRlKCkudGhyZWFkc0RCLmdldEV2ZW5JZkRlbGV0ZWQobWVzc2FnZS50aHJlYWRJZCk7XG4gICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9FRElURUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5USFJFQURfTUVUQURBVEFfVVBEQVRFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLlRIUkVBRF9VUERBVEVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9SRUFDVElPTl9BRERFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfREVMRVRFRDpcbiAgICAgICAgICBpZiAoIWV4aXN0aW5nVGhyZWFkKSBicmVhaztcbiAgICAgICAgICBzdG9yZS51cGRhdGVUaHJlYWRBbmROb3RpZmljYXRpb24odGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0NSRUFURUQ6XG4gICAgICAgICAgc3RvcmUudXBkYXRlVGhyZWFkQW5kTm90aWZpY2F0aW9uKHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm9vbS5ldmVudHMuY29tbWVudHMuc3Vic2NyaWJlKFxuICAgICAgKG1lc3NhZ2UpID0+IHZvaWQgaGFuZGxlQ29tbWVudEV2ZW50KG1lc3NhZ2UpXG4gICAgKTtcbiAgfSwgW2NsaWVudCwgcm9vbV0pO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBwYWlyID0gc3RhYmxlRW50ZXJSb29tKHJvb21JZCwgZnJvemVuUHJvcHMpO1xuICAgIHNldFJvb21MZWF2ZVBhaXIocGFpcik7XG4gICAgY29uc3QgeyByb29tOiByb29tMiwgbGVhdmUgfSA9IHBhaXI7XG4gICAgaWYgKGZyb3plblByb3BzLmF1dG9Db25uZWN0KSB7XG4gICAgICByb29tMi5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsZWF2ZSgpO1xuICAgIH07XG4gIH0sIFtyb29tSWQsIGZyb3plblByb3BzLCBzdGFibGVFbnRlclJvb21dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSb29tQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcm9vbSB9LCBwcm9wcy5jaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1c2VSb29tKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbU9yTnVsbCgpO1xuICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJvb21Qcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xuICB9XG4gIHJldHVybiByb29tO1xufVxuZnVuY3Rpb24gdXNlU3RhdHVzKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U3RhdHVzO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IHJvb20uZ2V0U3RhdHVzO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdGF0dXMob3B0aW9ucykge1xuICBjb25zdCBzbW9vdGggPSB1c2VJbml0aWFsKG9wdGlvbnM/LnNtb290aCA/PyBmYWxzZSk7XG4gIGlmIChzbW9vdGgpIHtcbiAgICByZXR1cm4gdXNlU3RvcmFnZVN0YXR1c1Ntb290aCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1c2VTdG9yYWdlU3RhdHVzSW1tZWRpYXRlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdGF0dXNJbW1lZGlhdGUoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U3RvcmFnZVN0YXR1cztcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSByb29tLmdldFN0b3JhZ2VTdGF0dXM7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xufVxuZnVuY3Rpb24gdXNlU3RvcmFnZVN0YXR1c1Ntb290aCgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IFJlYWN0NC51c2VTdGF0ZShyb29tLmdldFN0b3JhZ2VTdGF0dXMpO1xuICBjb25zdCBvbGRTdGF0dXMgPSB1c2VMYXRlc3Qocm9vbS5nZXRTdG9yYWdlU3RhdHVzKCkpO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IHVuc3ViID0gcm9vbS5ldmVudHMuc3RvcmFnZVN0YXR1cy5zdWJzY3JpYmUoKG5ld1N0YXR1cykgPT4ge1xuICAgICAgaWYgKG9sZFN0YXR1cy5jdXJyZW50ID09PSBcInN5bmNocm9uaXppbmdcIiAmJiBuZXdTdGF0dXMgPT09IFwic3luY2hyb25pemVkXCIpIHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBzZXRTdGF0dXMobmV3U3RhdHVzKSwgU01PT1RIX0RFTEFZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBzZXRTdGF0dXMobmV3U3RhdHVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB1bnN1YigpO1xuICAgIH07XG4gIH0sIFtyb29tLCBvbGRTdGF0dXNdKTtcbiAgcmV0dXJuIHN0YXR1cztcbn1cbmZ1bmN0aW9uIHVzZUJhdGNoKCkge1xuICByZXR1cm4gdXNlUm9vbSgpLmJhdGNoO1xufVxuZnVuY3Rpb24gdXNlQnJvYWRjYXN0RXZlbnQoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50LCBvcHRpb25zID0geyBzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeTogZmFsc2UgfSkgPT4ge1xuICAgICAgcm9vbS5icm9hZGNhc3RFdmVudChldmVudCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBbcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc0xpc3RlbmVyKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICBSZWFjdDQudXNlRWZmZWN0KFxuICAgICgpID0+IHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnQpKSxcbiAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gIFJlYWN0NC51c2VFZmZlY3QoXG4gICAgKCkgPT4gcm9vbS5ldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50KSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnQpXG4gICAgKSxcbiAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUVycm9yTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gIFJlYWN0NC51c2VFZmZlY3QoXG4gICAgKCkgPT4gcm9vbS5ldmVudHMuZXJyb3Iuc3Vic2NyaWJlKChlKSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZSkpLFxuICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnREYXRhKSA9PiB7XG4gICAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnREYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICB9LCBbcm9vbSwgc2F2ZWRDYWxsYmFja10pO1xufVxuZnVuY3Rpb24gdXNlSGlzdG9yeSgpIHtcbiAgcmV0dXJuIHVzZVJvb20oKS5oaXN0b3J5O1xufVxuZnVuY3Rpb24gdXNlVW5kbygpIHtcbiAgcmV0dXJuIHVzZUhpc3RvcnkoKS51bmRvO1xufVxuZnVuY3Rpb24gdXNlUmVkbygpIHtcbiAgcmV0dXJuIHVzZUhpc3RvcnkoKS5yZWRvO1xufVxuZnVuY3Rpb24gdXNlQ2FuVW5kbygpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuaGlzdG9yeS5zdWJzY3JpYmU7XG4gIGNvbnN0IGNhblVuZG8gPSByb29tLmhpc3RvcnkuY2FuVW5kbztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMihzdWJzY3JpYmUsIGNhblVuZG8sIGNhblVuZG8pO1xufVxuZnVuY3Rpb24gdXNlQ2FuUmVkbygpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuaGlzdG9yeS5zdWJzY3JpYmU7XG4gIGNvbnN0IGNhblJlZG8gPSByb29tLmhpc3RvcnkuY2FuUmVkbztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMihzdWJzY3JpYmUsIGNhblJlZG8sIGNhblJlZG8pO1xufVxuZnVuY3Rpb24gdXNlU2VsZihtYXliZVNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U2VsZjtcbiAgY29uc3Qgc2VsZWN0b3IgPSBtYXliZVNlbGVjdG9yID8/IGlkZW50aXR5MjtcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyBzZWxlY3RvcihtZSkgOiBudWxsLFxuICAgIFtzZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTbmFwc2hvdCxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlTXlQcmVzZW5jZSgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMubXlQcmVzZW5jZS5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRQcmVzZW5jZTtcbiAgY29uc3QgcHJlc2VuY2UgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U25hcHNob3QpO1xuICBjb25zdCBzZXRQcmVzZW5jZSA9IHJvb20udXBkYXRlUHJlc2VuY2U7XG4gIHJldHVybiBbcHJlc2VuY2UsIHNldFByZXNlbmNlXTtcbn1cbmZ1bmN0aW9uIHVzZVVwZGF0ZU15UHJlc2VuY2UoKSB7XG4gIHJldHVybiB1c2VSb29tKCkudXBkYXRlUHJlc2VuY2U7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnMoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldE90aGVycztcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNFbXB0eUxpc3Q7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFNuYXBzaG90LFxuICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgIHNlbGVjdG9yID8/IGlkZW50aXR5MixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNNYXBwZWQoaXRlbVNlbGVjdG9yLCBpdGVtSXNFcXVhbCkge1xuICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKG90aGVycykgPT4gb3RoZXJzLm1hcCgob3RoZXIpID0+IFtvdGhlci5jb25uZWN0aW9uSWQsIGl0ZW1TZWxlY3RvcihvdGhlcildKSxcbiAgICBbaXRlbVNlbGVjdG9yXVxuICApO1xuICBjb25zdCB3cmFwcGVkSXNFcXVhbCA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoYSwgYikgPT4ge1xuICAgICAgY29uc3QgZXEgPSBpdGVtSXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGF0dXBsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgYnR1cGxlID0gYltpbmRleF07XG4gICAgICAgIHJldHVybiBhdHVwbGVbMF0gPT09IGJ0dXBsZVswXSAmJiBlcShhdHVwbGVbMV0sIGJ0dXBsZVsxXSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtpdGVtSXNFcXVhbF1cbiAgKTtcbiAgcmV0dXJuIHVzZU90aGVycyh3cmFwcGVkU2VsZWN0b3IsIHdyYXBwZWRJc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMoKSB7XG4gIHJldHVybiB1c2VPdGhlcnMoc2VsZWN0b3JGb3JfdXNlT3RoZXJzQ29ubmVjdGlvbklkcywgc2hhbGxvdzQpO1xufVxudmFyIE5PVF9GT1VORCA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gdXNlT3RoZXIoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKG90aGVycykgPT4ge1xuICAgICAgY29uc3Qgb3RoZXIyID0gb3RoZXJzLmZpbmQoKG90aGVyMykgPT4gb3RoZXIzLmNvbm5lY3Rpb25JZCA9PT0gY29ubmVjdGlvbklkKTtcbiAgICAgIHJldHVybiBvdGhlcjIgIT09IHZvaWQgMCA/IHNlbGVjdG9yKG90aGVyMikgOiBOT1RfRk9VTkQ7XG4gICAgfSxcbiAgICBbY29ubmVjdGlvbklkLCBzZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3Qgd3JhcHBlZElzRXF1YWwgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHByZXYsIGN1cnIpID0+IHtcbiAgICAgIGlmIChwcmV2ID09PSBOT1RfRk9VTkQgfHwgY3VyciA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICAgIHJldHVybiBwcmV2ID09PSBjdXJyO1xuICAgICAgfVxuICAgICAgY29uc3QgZXEgPSBpc0VxdWFsID8/IE9iamVjdC5pcztcbiAgICAgIHJldHVybiBlcShwcmV2LCBjdXJyKTtcbiAgICB9LFxuICAgIFtpc0VxdWFsXVxuICApO1xuICBjb25zdCBvdGhlciA9IHVzZU90aGVycyh3cmFwcGVkU2VsZWN0b3IsIHdyYXBwZWRJc0VxdWFsKTtcbiAgaWYgKG90aGVyID09PSBOT1RfRk9VTkQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTm8gc3VjaCBvdGhlciB1c2VyIHdpdGggY29ubmVjdGlvbiBpZCAke2Nvbm5lY3Rpb25JZH0gZXhpc3RzYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG90aGVyO1xufVxuZnVuY3Rpb24gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zdG9yYWdlRGlkTG9hZC5zdWJzY3JpYmVPbmNlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90O1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xufVxuZnVuY3Rpb24gdXNlU3RvcmFnZVJvb3QoKSB7XG4gIHJldHVybiBbdXNlTXV0YWJsZVN0b3JhZ2VSb290KCldO1xufVxuZnVuY3Rpb24gdXNlU3RvcmFnZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCByb290T3JOdWxsID0gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCk7XG4gIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAocm9vdE9yTnVsbDIpID0+IHJvb3RPck51bGwyICE9PSBudWxsID8gc2VsZWN0b3Iocm9vdE9yTnVsbDIpIDogbnVsbCxcbiAgICBbc2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAob25TdG9yZUNoYW5nZSkgPT4gcm9vdE9yTnVsbCAhPT0gbnVsbCA/IHJvb20uc3Vic2NyaWJlKHJvb3RPck51bGwsIG9uU3RvcmVDaGFuZ2UsIHsgaXNEZWVwOiB0cnVlIH0pIDogbm9vcDMsXG4gICAgW3Jvb20sIHJvb3RPck51bGxdXG4gICk7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gUmVhY3Q0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvb3QgPSByb290T3JOdWxsO1xuICAgICAgY29uc3QgaW1tID0gcm9vdC50b0ltbXV0YWJsZSgpO1xuICAgICAgcmV0dXJuIGltbTtcbiAgICB9XG4gIH0sIFtyb290T3JOdWxsXSk7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU11dGF0aW9uKGNhbGxiYWNrLCBkZXBzKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlTWVtbyhcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJvb20uYmF0Y2goXG4gICAgICAgICAgKCkgPT4gKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSxcbiAgICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbcm9vbSwgLi4uZGVwc11cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZHMob3B0aW9ucyA9IHtcbiAgcXVlcnk6IHsgbWV0YWRhdGE6IHt9IH1cbn0pIHtcbiAgY29uc3QgeyBzY3JvbGxPbkxvYWQgPSB0cnVlIH0gPSBvcHRpb25zO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBzdG9yZSwgZ2V0T3JDcmVhdGVUaHJlYWRzUG9sbGVyRm9yUm9vbUlkIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHBvbGxlciA9IGdldE9yQ3JlYXRlVGhyZWFkc1BvbGxlckZvclJvb21JZChyb29tLmlkKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICB2b2lkIHN0b3JlLndhaXRVbnRpbFJvb21UaHJlYWRzTG9hZGVkKHJvb20uaWQsIG9wdGlvbnMucXVlcnkpO1xuICAgIH1cbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIFJlYWN0NC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHBvbGxlci5pbmMoKTtcbiAgICBwb2xsZXIucG9sbE5vd0lmU3RhbGUoKTtcbiAgICByZXR1cm4gKCkgPT4gcG9sbGVyLmRlYygpO1xuICB9LCBbcG9sbGVyXSk7XG4gIGNvbnN0IGdldHRlciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoKSA9PiBzdG9yZS5nZXRSb29tVGhyZWFkc0xvYWRpbmdTdGF0ZShyb29tLmlkLCBvcHRpb25zLnF1ZXJ5KSxcbiAgICBbc3RvcmUsIHJvb20uaWQsIG9wdGlvbnMucXVlcnldXG4gICk7XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICBnZXR0ZXIsXG4gICAgZ2V0dGVyLFxuICAgIGlkZW50aXR5MixcbiAgICBzaGFsbG93MlxuICAgIC8vIE5PVEU6IFVzaW5nIDItbGV2ZWwtZGVlcCBzaGFsbG93IGNoZWNrIGhlcmUsIGJlY2F1c2UgdGhlIHJlc3VsdCBvZiBzZWxlY3RUaHJlYWRzKCkgaXMgbm90IHN0YWJsZSFcbiAgKTtcbiAgdXNlU2Nyb2xsVG9Db21tZW50T25Mb2FkRWZmZWN0KHNjcm9sbE9uTG9hZCwgc3RhdGUpO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VDb21tZW50c0Vycm9yTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICBjb25zdCB7IGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gY29tbWVudHNFcnJvckV2ZW50U291cmNlLnN1YnNjcmliZShzYXZlZENhbGxiYWNrLmN1cnJlbnQpO1xuICB9LCBbc2F2ZWRDYWxsYmFjaywgY29tbWVudHNFcnJvckV2ZW50U291cmNlXSk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVUaHJlYWQoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhID8/IHt9O1xuICAgICAgY29uc3QgYXR0YWNobWVudHMgPSBvcHRpb25zLmF0dGFjaG1lbnRzO1xuICAgICAgY29uc3QgdGhyZWFkSWQgPSBjcmVhdGVUaHJlYWRJZCgpO1xuICAgICAgY29uc3QgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG5ld0NvbW1lbnQgPSB7XG4gICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIHVzZXJJZDogZ2V0Q3VycmVudFVzZXJJZChyb29tKSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgcmVhY3Rpb25zOiBbXSxcbiAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzID8/IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV3VGhyZWFkID0ge1xuICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgIHR5cGU6IFwidGhyZWFkXCIsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgdXBkYXRlZEF0OiBjcmVhdGVkQXQsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGNvbW1lbnRzOiBbbmV3Q29tbWVudF0sXG4gICAgICAgIHJlc29sdmVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJjcmVhdGUtdGhyZWFkXCIsXG4gICAgICAgIHRocmVhZDogbmV3VGhyZWFkLFxuICAgICAgICByb29tSWQ6IHJvb20uaWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXR0YWNobWVudElkcyA9IGF0dGFjaG1lbnRzPy5tYXAoKGF0dGFjaG1lbnQpID0+IGF0dGFjaG1lbnQuaWQpO1xuICAgICAgcm9vbS5jcmVhdGVUaHJlYWQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBtZXRhZGF0YSwgYXR0YWNobWVudElkcyB9KS50aGVuKFxuICAgICAgICAodGhyZWFkKSA9PiB7XG4gICAgICAgICAgc3RvcmUuY3JlYXRlVGhyZWFkKG9wdGltaXN0aWNVcGRhdGVJZCwgdGhyZWFkKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyMikgPT4gbmV3IENyZWF0ZVRocmVhZEVycm9yKGVycjIsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdUaHJlYWQ7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlVGhyZWFkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBzdG9yZS5nZXRGdWxsU3RhdGUoKS50aHJlYWRzREIuZ2V0KHRocmVhZElkKTtcbiAgICAgIGlmIChleGlzdGluZz8uY29tbWVudHM/LlswXT8udXNlcklkICE9PSB1c2VySWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSB0aGUgdGhyZWFkIGNyZWF0b3IgY2FuIGRlbGV0ZSB0aGUgdGhyZWFkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLXRocmVhZFwiLFxuICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBkZWxldGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICB9KTtcbiAgICAgIHJvb20uZGVsZXRlVGhyZWFkKHRocmVhZElkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuZGVsZXRlVGhyZWFkKHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnIyKSA9PiBuZXcgRGVsZXRlVGhyZWFkRXJyb3IoZXJyMiwgeyByb29tSWQ6IHJvb20uaWQsIHRocmVhZElkIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRWRpdFRocmVhZE1ldGFkYXRhKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKCFvcHRpb25zLm1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRocmVhZElkID0gb3B0aW9ucy50aHJlYWRJZDtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImVkaXQtdGhyZWFkLW1ldGFkYXRhXCIsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgdXBkYXRlZEF0XG4gICAgICB9KTtcbiAgICAgIHJvb20uZWRpdFRocmVhZE1ldGFkYXRhKHsgdGhyZWFkSWQsIG1ldGFkYXRhIH0pLnRoZW4oXG4gICAgICAgIChtZXRhZGF0YTIpID0+IChcbiAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBieSB0aGUgcmVhbCB0aGluZ1xuICAgICAgICAgIHN0b3JlLnBhdGNoVGhyZWFkKFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICB7IG1ldGFkYXRhOiBtZXRhZGF0YTIgfSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdFxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBFZGl0VGhyZWFkTWV0YWRhdGFFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlQ3JlYXRlQ29tbWVudCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHsgdGhyZWFkSWQsIGJvZHksIGF0dGFjaG1lbnRzIH0pID0+IHtcbiAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBjb21tZW50ID0ge1xuICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQocm9vbSksXG4gICAgICAgIGJvZHksXG4gICAgICAgIHJlYWN0aW9uczogW10sXG4gICAgICAgIGF0dGFjaG1lbnRzOiBhdHRhY2htZW50cyA/PyBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJjcmVhdGUtY29tbWVudFwiLFxuICAgICAgICBjb21tZW50XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBhdHRhY2htZW50cz8ubWFwKChhdHRhY2htZW50KSA9PiBhdHRhY2htZW50LmlkKTtcbiAgICAgIHJvb20uY3JlYXRlQ29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHksIGF0dGFjaG1lbnRJZHMgfSkudGhlbihcbiAgICAgICAgKG5ld0NvbW1lbnQpID0+IHtcbiAgICAgICAgICBzdG9yZS5jcmVhdGVDb21tZW50KG5ld0NvbW1lbnQsIG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycjIpID0+IG5ldyBDcmVhdGVDb21tZW50RXJyb3IoZXJyMiwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRDb21tZW50KCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBhdHRhY2htZW50cyB9KSA9PiB7XG4gICAgICBjb25zdCBlZGl0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gc3RvcmUuZ2V0RnVsbFN0YXRlKCkudGhyZWFkc0RCLmdldEV2ZW5JZkRlbGV0ZWQodGhyZWFkSWQpO1xuICAgICAgaWYgKGV4aXN0aW5nID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZTMud2FybihcbiAgICAgICAgICBgSW50ZXJuYWwgdW5leHBlY3RlZCBiZWhhdmlvci4gQ2Fubm90IGVkaXQgY29tbWVudCBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIHRocmVhZCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGUuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb21tZW50ID0gZXhpc3RpbmcuY29tbWVudHMuZmluZChcbiAgICAgICAgKGNvbW1lbnQyKSA9PiBjb21tZW50Mi5pZCA9PT0gY29tbWVudElkXG4gICAgICApO1xuICAgICAgaWYgKGNvbW1lbnQgPT09IHZvaWQgMCB8fCBjb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUzLndhcm4oXG4gICAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBlZGl0IGNvbW1lbnQgXCIke2NvbW1lbnRJZH1cIiBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIGNvbW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiZWRpdC1jb21tZW50XCIsXG4gICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAuLi5jb21tZW50LFxuICAgICAgICAgIGVkaXRlZEF0LFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzID8/IFtdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXR0YWNobWVudElkcyA9IGF0dGFjaG1lbnRzPy5tYXAoKGF0dGFjaG1lbnQpID0+IGF0dGFjaG1lbnQuaWQpO1xuICAgICAgcm9vbS5lZGl0Q29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHksIGF0dGFjaG1lbnRJZHMgfSkudGhlbihcbiAgICAgICAgKGVkaXRlZENvbW1lbnQpID0+IHtcbiAgICAgICAgICBzdG9yZS5lZGl0Q29tbWVudCh0aHJlYWRJZCwgb3B0aW1pc3RpY1VwZGF0ZUlkLCBlZGl0ZWRDb21tZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBFZGl0Q29tbWVudEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUNvbW1lbnQoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgICh7IHRocmVhZElkLCBjb21tZW50SWQgfSkgPT4ge1xuICAgICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLWNvbW1lbnRcIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgZGVsZXRlZEF0LFxuICAgICAgICByb29tSWQ6IHJvb20uaWRcbiAgICAgIH0pO1xuICAgICAgcm9vbS5kZWxldGVDb21tZW50KHsgdGhyZWFkSWQsIGNvbW1lbnRJZCB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuZGVsZXRlQ29tbWVudChcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZGVsZXRlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBEZWxldGVDb21tZW50RXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VBZGRSZWFjdGlvbigpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkgPT4ge1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImFkZC1yZWFjdGlvblwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICByZWFjdGlvbjoge1xuICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb29tLmFkZFJlYWN0aW9uKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkudGhlbihcbiAgICAgICAgKGFkZGVkUmVhY3Rpb24pID0+IHtcbiAgICAgICAgICBzdG9yZS5hZGRSZWFjdGlvbihcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgYWRkZWRSZWFjdGlvbixcbiAgICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgQWRkUmVhY3Rpb25FcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBlbW9qaVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlUmVtb3ZlUmVhY3Rpb24oKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQocm9vbSk7XG4gICAgICBjb25zdCByZW1vdmVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmUtcmVhY3Rpb25cIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgZW1vamksXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgcmVtb3ZlZEF0XG4gICAgICB9KTtcbiAgICAgIHJvb20ucmVtb3ZlUmVhY3Rpb24oeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucmVtb3ZlUmVhY3Rpb24oXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgcmVtb3ZlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBSZW1vdmVSZWFjdGlvbkVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGVtb2ppXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrVGhyZWFkQXNSZWFkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAodGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMoXG4gICAgICAgIHN0b3JlLmdldEZ1bGxTdGF0ZSgpLm5vdGlmaWNhdGlvbnNCeUlkXG4gICAgICApLmZpbmQoXG4gICAgICAgIChpbmJveE5vdGlmaWNhdGlvbjIpID0+IGluYm94Tm90aWZpY2F0aW9uMi5raW5kID09PSBcInRocmVhZFwiICYmIGluYm94Tm90aWZpY2F0aW9uMi50aHJlYWRJZCA9PT0gdGhyZWFkSWRcbiAgICAgICk7XG4gICAgICBpZiAoIWluYm94Tm90aWZpY2F0aW9uKSByZXR1cm47XG4gICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9uLWFzLXJlYWRcIixcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZDogaW5ib3hOb3RpZmljYXRpb24uaWQsXG4gICAgICAgIHJlYWRBdDogbm93XG4gICAgICB9KTtcbiAgICAgIHJvb20ubWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uLmlkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUudXBkYXRlSW5ib3hOb3RpZmljYXRpb24oXG4gICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbi5pZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChpbmJveE5vdGlmaWNhdGlvbjIpID0+ICh7IC4uLmluYm94Tm90aWZpY2F0aW9uMiwgcmVhZEF0OiBub3cgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyb3IpID0+IG5ldyBNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkOiBpbmJveE5vdGlmaWNhdGlvbi5pZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrVGhyZWFkQXNSZXNvbHZlZCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLXRocmVhZC1hcy1yZXNvbHZlZFwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgdXBkYXRlZEF0XG4gICAgICB9KTtcbiAgICAgIHJvb20ubWFya1RocmVhZEFzUmVzb2x2ZWQodGhyZWFkSWQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5wYXRjaFRocmVhZChcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgeyByZXNvbHZlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgdXBkYXRlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBNYXJrVGhyZWFkQXNSZXNvbHZlZEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLXRocmVhZC1hcy11bnJlc29sdmVkXCIsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICB1cGRhdGVkQXRcbiAgICAgIH0pO1xuICAgICAgcm9vbS5tYXJrVGhyZWFkQXNVbnJlc29sdmVkKHRocmVhZElkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucGF0Y2hUaHJlYWQoXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIHsgcmVzb2x2ZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB1cGRhdGVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnJvcikgPT4gbmV3IE1hcmtUaHJlYWRBc1VucmVzb2x2ZWRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZFN1YnNjcmlwdGlvbih0aHJlYWRJZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBzZWxlY3RvciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IHN0YXRlLmNsZWFuZWROb3RpZmljYXRpb25zLmZpbmQoXG4gICAgICAgIChpbmJveE5vdGlmaWNhdGlvbikgPT4gaW5ib3hOb3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBpbmJveE5vdGlmaWNhdGlvbi50aHJlYWRJZCA9PT0gdGhyZWFkSWRcbiAgICAgICk7XG4gICAgICBjb25zdCB0aHJlYWQgPSBzdGF0ZS50aHJlYWRzREIuZ2V0KHRocmVhZElkKTtcbiAgICAgIGlmIChub3RpZmljYXRpb24gPT09IHZvaWQgMCB8fCB0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwibm90LXN1YnNjcmliZWRcIiB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcInN1YnNjcmliZWRcIixcbiAgICAgICAgdW5yZWFkU2luY2U6IG5vdGlmaWNhdGlvbi5yZWFkQXRcbiAgICAgIH07XG4gICAgfSxcbiAgICBbdGhyZWFkSWRdXG4gICk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgIHN0b3JlLmdldEZ1bGxTdGF0ZSxcbiAgICBzdG9yZS5nZXRGdWxsU3RhdGUsXG4gICAgc2VsZWN0b3JcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgY29uc3QgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzID0gdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IHN0b3JlLCBnZXRPckNyZWF0ZU5vdGlmaWNhdGlvbnNTZXR0aW5nc1BvbGxlckZvclJvb21JZCB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBwb2xsZXIgPSBnZXRPckNyZWF0ZU5vdGlmaWNhdGlvbnNTZXR0aW5nc1BvbGxlckZvclJvb21JZChyb29tLmlkKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICB2b2lkIHN0b3JlLndhaXRVbnRpbFJvb21Ob3RpZmljYXRpb25TZXR0aW5nc0xvYWRlZChyb29tLmlkKTtcbiAgICB9XG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlci5kZWMoKTtcbiAgICB9O1xuICB9LCBbcG9sbGVyXSk7XG4gIGNvbnN0IGdldHRlciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoKSA9PiBzdG9yZS5nZXROb3RpZmljYXRpb25TZXR0aW5nc0xvYWRpbmdTdGF0ZShyb29tLmlkKSxcbiAgICBbc3RvcmUsIHJvb20uaWRdXG4gICk7XG4gIGNvbnN0IHNldHRpbmdzID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICBnZXR0ZXIsXG4gICAgZ2V0dGVyLFxuICAgIGlkZW50aXR5MixcbiAgICBzaGFsbG93MlxuICApO1xuICByZXR1cm4gUmVhY3Q0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc107XG4gIH0sIFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXSk7XG59XG5mdW5jdGlvbiB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2Uoc3RvcmUud2FpdFVudGlsUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzTG9hZGVkKHJvb20uaWQpKTtcbiAgY29uc3QgW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdID0gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gIGFzc2VydDIoIXNldHRpbmdzLmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQyKCFzZXR0aW5ncy5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICB9LCBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc10pO1xufVxuZnVuY3Rpb24gdXNlSGlzdG9yeVZlcnNpb25EYXRhKHZlcnNpb25JZCkge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0NC51c2VTdGF0ZSh7XG4gICAgaXNMb2FkaW5nOiB0cnVlXG4gIH0pO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICBjb25zdCBsb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByb29tW2tJbnRlcm5hbDNdLmdldFRleHRWZXJzaW9uKHZlcnNpb25JZCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIHRoaXMgdmVyc2lvblwiXG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZvaWQgbG9hZCgpO1xuICB9LCBbcm9vbSwgdmVyc2lvbklkXSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnlWZXJzaW9ucygpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgc3RvcmUsIGdldE9yQ3JlYXRlVmVyc2lvbnNQb2xsZXJGb3JSb29tSWQgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgcG9sbGVyID0gZ2V0T3JDcmVhdGVWZXJzaW9uc1BvbGxlckZvclJvb21JZChyb29tLmlkKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiBwb2xsZXIuZGVjKCk7XG4gIH0sIFtwb2xsZXJdKTtcbiAgY29uc3QgZ2V0dGVyID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgICgpID0+IHN0b3JlLmdldFJvb21WZXJzaW9uc0xvYWRpbmdTdGF0ZShyb29tLmlkKSxcbiAgICBbc3RvcmUsIHJvb20uaWRdXG4gICk7XG4gIFJlYWN0NC51c2VFZmZlY3QoXG4gICAgKCkgPT4ge1xuICAgICAgdm9pZCBzdG9yZS53YWl0VW50aWxSb29tVmVyc2lvbnNMb2FkZWQocm9vbS5pZCk7XG4gICAgfVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldHRlcixcbiAgICBnZXR0ZXIsXG4gICAgaWRlbnRpdHkyLFxuICAgIHNoYWxsb3cyXG4gICk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkuc3RvcmU7XG4gIHVzZShzdG9yZS53YWl0VW50aWxSb29tVmVyc2lvbnNMb2FkZWQocm9vbS5pZCkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VIaXN0b3J5VmVyc2lvbnMoKTtcbiAgYXNzZXJ0MighcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQyKCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChzZXR0aW5ncykgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcInVwZGF0ZS1ub3RpZmljYXRpb24tc2V0dGluZ3NcIixcbiAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICBzZXR0aW5nc1xuICAgICAgfSk7XG4gICAgICByb29tLnVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKS50aGVuKFxuICAgICAgICAoc2V0dGluZ3MyKSA9PiB7XG4gICAgICAgICAgc3RvcmUudXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzX2NvbmZpcm1PcHRpbWlzdGljVXBkYXRlKFxuICAgICAgICAgICAgcm9vbS5pZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIHNldHRpbmdzMlxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCB1c2UgdGhlIFN1c3BlbnNlIHZlcnNpb24gb2YgdGhpcyBob29rIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCB0aGVtIG9uIHRoZSBjbGllbnQgc2lkZS5cXG5Gb3IgdGlwcywgc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1yZWFjdCNzdXNwZW5zZS1hdm9pZC1zc3JcIlxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgdXNlKHJvb20ud2FpdFVudGlsUHJlc2VuY2VSZWFkeSgpKTtcbn1cbmZ1bmN0aW9uIHVzZVNlbGZTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VTZWxmKFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc1N1c3BlbnNlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVycyhcbiAgICBzZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UoKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMoKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyc01hcHBlZFN1c3BlbnNlKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VSZWFkeSgpO1xuICByZXR1cm4gdXNlT3RoZXJzTWFwcGVkKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJTdXNwZW5zZShjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVyKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpO1xufVxuZnVuY3Rpb24gdXNlU3VzcGVuZFVudGlsU3RvcmFnZVJlYWR5KCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHVzZShyb29tLndhaXRVbnRpbFN0b3JhZ2VSZWFkeSgpKTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxTdG9yYWdlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZVN0b3JhZ2UoXG4gICAgc2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlU3RvcmFnZVN0YXR1c1N1c3BlbnNlKG9wdGlvbnMpIHtcbiAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZVJlYWR5KCk7XG4gIHJldHVybiB1c2VTdG9yYWdlU3RhdHVzKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdXNlVGhyZWFkc1N1c3BlbnNlKG9wdGlvbnMgPSB7XG4gIHF1ZXJ5OiB7IG1ldGFkYXRhOiB7fSB9XG59KSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIHVzZShzdG9yZS53YWl0VW50aWxSb29tVGhyZWFkc0xvYWRlZChyb29tLmlkLCBvcHRpb25zLnF1ZXJ5KSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVRocmVhZHMob3B0aW9ucyk7XG4gIGFzc2VydDIoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0MighcmVzdWx0LmlzTG9hZGluZywgXCJEaWQgbm90IGV4cGVjdCBsb2FkaW5nXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlQXR0YWNobWVudFVybChzdGF0ZSkge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCB8fCBzdGF0ZT8uaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlID8/IHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbiAgaWYgKHN0YXRlLmVycm9yKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGFzc2VydDIoc3RhdGUuZGF0YSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyBhdHRhY2htZW50IFVSTFwiKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIHVybDogc3RhdGUuZGF0YVxuICB9O1xufVxuZnVuY3Rpb24gdXNlQXR0YWNobWVudFVybChhdHRhY2htZW50SWQpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBhdHRhY2htZW50VXJsc1N0b3JlIH0gPSByb29tW2tJbnRlcm5hbDNdO1xuICBjb25zdCBnZXRBdHRhY2htZW50VXJsU3RhdGUgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKCkgPT4gYXR0YWNobWVudFVybHNTdG9yZS5nZXRTdGF0ZShhdHRhY2htZW50SWQpLFxuICAgIFthdHRhY2htZW50VXJsc1N0b3JlLCBhdHRhY2htZW50SWRdXG4gICk7XG4gIFJlYWN0NC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZvaWQgYXR0YWNobWVudFVybHNTdG9yZS5nZXQoYXR0YWNobWVudElkKTtcbiAgfSwgW2F0dGFjaG1lbnRVcmxzU3RvcmUsIGF0dGFjaG1lbnRJZF0pO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIGF0dGFjaG1lbnRVcmxzU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldEF0dGFjaG1lbnRVcmxTdGF0ZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGUsXG4gICAgc2VsZWN0b3JGb3JfdXNlQXR0YWNobWVudFVybCxcbiAgICBzaGFsbG93NFxuICApO1xufVxuZnVuY3Rpb24gdXNlQXR0YWNobWVudFVybFN1c3BlbnNlKGF0dGFjaG1lbnRJZCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IGF0dGFjaG1lbnRVcmxzU3RvcmUgfSA9IHJvb21ba0ludGVybmFsM107XG4gIGNvbnN0IGdldEF0dGFjaG1lbnRVcmxTdGF0ZSA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoKSA9PiBhdHRhY2htZW50VXJsc1N0b3JlLmdldFN0YXRlKGF0dGFjaG1lbnRJZCksXG4gICAgW2F0dGFjaG1lbnRVcmxzU3RvcmUsIGF0dGFjaG1lbnRJZF1cbiAgKTtcbiAgY29uc3QgYXR0YWNobWVudFVybFN0YXRlID0gZ2V0QXR0YWNobWVudFVybFN0YXRlKCk7XG4gIGlmICghYXR0YWNobWVudFVybFN0YXRlIHx8IGF0dGFjaG1lbnRVcmxTdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICB0aHJvdyBhdHRhY2htZW50VXJsc1N0b3JlLmdldChhdHRhY2htZW50SWQpO1xuICB9XG4gIGlmIChhdHRhY2htZW50VXJsU3RhdGUuZXJyb3IpIHtcbiAgICB0aHJvdyBhdHRhY2htZW50VXJsU3RhdGUuZXJyb3I7XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgYXR0YWNobWVudFVybHNTdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0QXR0YWNobWVudFVybFN0YXRlLFxuICAgIGdldEF0dGFjaG1lbnRVcmxTdGF0ZVxuICApO1xuICBhc3NlcnQyKHN0YXRlICE9PSB2b2lkIDAsIFwiVW5leHBlY3RlZCBtaXNzaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQyKCFzdGF0ZS5pc0xvYWRpbmcsIFwiVW5leHBlY3RlZCBsb2FkaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQyKCFzdGF0ZS5lcnJvciwgXCJVbmV4cGVjdGVkIGVycm9yIHN0YXRlXCIpO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgdXJsOiBzdGF0ZS5kYXRhLFxuICAgIGVycm9yOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb21Db250ZXh0KGNsaWVudCkge1xuICByZXR1cm4gZ2V0T3JDcmVhdGVSb29tQ29udGV4dEJ1bmRsZShjbGllbnQpO1xufVxudmFyIF9Sb29tUHJvdmlkZXIgPSBSb29tUHJvdmlkZXI7XG52YXIgX3VzZUJyb2FkY2FzdEV2ZW50ID0gdXNlQnJvYWRjYXN0RXZlbnQ7XG52YXIgX3VzZU90aGVyc0xpc3RlbmVyID0gdXNlT3RoZXJzTGlzdGVuZXI7XG52YXIgX3VzZVJvb20gPSB1c2VSb29tO1xudmFyIF91c2VJc0luc2lkZVJvb20gPSB1c2VJc0luc2lkZVJvb207XG52YXIgX3VzZUFkZFJlYWN0aW9uID0gdXNlQWRkUmVhY3Rpb247XG52YXIgX3VzZU11dGF0aW9uID0gdXNlTXV0YXRpb247XG52YXIgX3VzZUNyZWF0ZVRocmVhZCA9IHVzZUNyZWF0ZVRocmVhZDtcbnZhciBfdXNlRGVsZXRlVGhyZWFkID0gdXNlRGVsZXRlVGhyZWFkO1xudmFyIF91c2VFZGl0VGhyZWFkTWV0YWRhdGEgPSB1c2VFZGl0VGhyZWFkTWV0YWRhdGE7XG52YXIgX3VzZUV2ZW50TGlzdGVuZXIgPSB1c2VFdmVudExpc3RlbmVyO1xudmFyIF91c2VNeVByZXNlbmNlID0gdXNlTXlQcmVzZW5jZTtcbnZhciBfdXNlT3RoZXJzTWFwcGVkID0gdXNlT3RoZXJzTWFwcGVkO1xudmFyIF91c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSA9IHVzZU90aGVyc01hcHBlZFN1c3BlbnNlO1xudmFyIF91c2VUaHJlYWRzID0gdXNlVGhyZWFkcztcbnZhciBfdXNlVGhyZWFkc1N1c3BlbnNlID0gdXNlVGhyZWFkc1N1c3BlbnNlO1xudmFyIF91c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MgPSB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3M7XG52YXIgX3VzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlID0gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2U7XG52YXIgX3VzZUhpc3RvcnlWZXJzaW9ucyA9IHVzZUhpc3RvcnlWZXJzaW9ucztcbnZhciBfdXNlSGlzdG9yeVZlcnNpb25zU3VzcGVuc2UgPSB1c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZTtcbnZhciBfdXNlT3RoZXIgPSB1c2VPdGhlcjtcbmZ1bmN0aW9uIF91c2VPdGhlcnMoLi4uYXJncykge1xuICByZXR1cm4gdXNlT3RoZXJzKC4uLmFyZ3MpO1xufVxudmFyIF91c2VPdGhlclN1c3BlbnNlID0gdXNlT3RoZXJTdXNwZW5zZTtcbmZ1bmN0aW9uIF91c2VPdGhlcnNTdXNwZW5zZSguLi5hcmdzKSB7XG4gIHJldHVybiB1c2VPdGhlcnNTdXNwZW5zZSguLi5hcmdzKTtcbn1cbnZhciBfdXNlU3RvcmFnZSA9IHVzZVN0b3JhZ2U7XG52YXIgX3VzZVN0b3JhZ2VTdXNwZW5zZSA9IHVzZVN0b3JhZ2VTdXNwZW5zZTtcbmZ1bmN0aW9uIF91c2VTZWxmKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHVzZVNlbGYoLi4uYXJncyk7XG59XG5mdW5jdGlvbiBfdXNlU2VsZlN1c3BlbnNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHVzZVNlbGZTdXNwZW5zZSguLi5hcmdzKTtcbn1cbnZhciBfdXNlU3RvcmFnZVJvb3QgPSB1c2VTdG9yYWdlUm9vdDtcbnZhciBfdXNlVXBkYXRlTXlQcmVzZW5jZSA9IHVzZVVwZGF0ZU15UHJlc2VuY2U7XG5cbmV4cG9ydCB7XG4gIFJvb21Db250ZXh0LFxuICBDbGllbnRDb250ZXh0LFxuICBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50LFxuICB1c2VDbGllbnQsXG4gIExpdmVibG9ja3NQcm92aWRlcixcbiAgY3JlYXRlTGl2ZWJsb2Nrc0NvbnRleHQsXG4gIHVzZUluYm94Tm90aWZpY2F0aW9ucyxcbiAgdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UsXG4gIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQsXG4gIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zLFxuICB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbixcbiAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2UsXG4gIHVzZVJvb21JbmZvLFxuICB1c2VSb29tSW5mb1N1c3BlbnNlLFxuICBfdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQsXG4gIF91c2VVc2VyLFxuICBfdXNlVXNlclN1c3BlbnNlLFxuICBfdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsLFxuICBfdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwsXG4gIENyZWF0ZVRocmVhZEVycm9yLFxuICB1c2VTdGF0dXMsXG4gIHVzZVN0b3JhZ2VTdGF0dXMsXG4gIHVzZUJhdGNoLFxuICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICB1c2VFcnJvckxpc3RlbmVyLFxuICB1c2VIaXN0b3J5LFxuICB1c2VVbmRvLFxuICB1c2VSZWRvLFxuICB1c2VDYW5VbmRvLFxuICB1c2VDYW5SZWRvLFxuICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICB1c2VDb21tZW50c0Vycm9yTGlzdGVuZXIsXG4gIHVzZUNyZWF0ZUNvbW1lbnQsXG4gIHVzZUVkaXRDb21tZW50LFxuICB1c2VEZWxldGVDb21tZW50LFxuICB1c2VSZW1vdmVSZWFjdGlvbixcbiAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gIHVzZU1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgdXNlSGlzdG9yeVZlcnNpb25EYXRhLFxuICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSxcbiAgdXNlU3RvcmFnZVN0YXR1c1N1c3BlbnNlLFxuICB1c2VBdHRhY2htZW50VXJsLFxuICB1c2VBdHRhY2htZW50VXJsU3VzcGVuc2UsXG4gIGNyZWF0ZVJvb21Db250ZXh0LFxuICBfUm9vbVByb3ZpZGVyLFxuICBfdXNlQnJvYWRjYXN0RXZlbnQsXG4gIF91c2VPdGhlcnNMaXN0ZW5lcixcbiAgX3VzZVJvb20sXG4gIF91c2VJc0luc2lkZVJvb20sXG4gIF91c2VBZGRSZWFjdGlvbixcbiAgX3VzZU11dGF0aW9uLFxuICBfdXNlQ3JlYXRlVGhyZWFkLFxuICBfdXNlRGVsZXRlVGhyZWFkLFxuICBfdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICBfdXNlRXZlbnRMaXN0ZW5lcixcbiAgX3VzZU15UHJlc2VuY2UsXG4gIF91c2VPdGhlcnNNYXBwZWQsXG4gIF91c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSxcbiAgX3VzZVRocmVhZHMsXG4gIF91c2VUaHJlYWRzU3VzcGVuc2UsXG4gIF91c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIF91c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgX3VzZUhpc3RvcnlWZXJzaW9ucyxcbiAgX3VzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlLFxuICBfdXNlT3RoZXIsXG4gIF91c2VPdGhlcnMsXG4gIF91c2VPdGhlclN1c3BlbnNlLFxuICBfdXNlT3RoZXJzU3VzcGVuc2UsXG4gIF91c2VTdG9yYWdlLFxuICBfdXNlU3RvcmFnZVN1c3BlbnNlLFxuICBfdXNlU2VsZixcbiAgX3VzZVNlbGZTdXNwZW5zZSxcbiAgX3VzZVN0b3JhZ2VSb290LFxuICBfdXNlVXBkYXRlTXlQcmVzZW5jZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUE3R0pOTjRMLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/chunk-A7GJNN4L.mjs\n");

/***/ })

};
;